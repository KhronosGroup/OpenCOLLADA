/*
    Copyright (c) 2008-2009 NetAllied Systems GmbH

    This file is part of COLLADASaxFrameworkLoader.

    Licensed under the MIT Open Source License,
    for details please see LICENSE file or the website
    http://www.opensource.org/licenses/mit-license.php
*/

#include "COLLADASaxFWLStableHeaders.h"
#include "GeneratedSaxParserUtils.h"

#include "COLLADASaxFWLColladaParserAutoGen15Private.h"


// disable warning "unused variable"
#if defined(__INTEL_COMPILER) && !defined(WIN32)
template <typename T>
inline void disable_warning_unused(T &x) { (void)x; }
#    define DISABLE_WARNING_UNUSED(x) disable_warning_unused(x);
#else
#    define DISABLE_WARNING_UNUSED(x) (void)x;
#endif



namespace COLLADASaxFWL15
{


//---------------------------------------------------------------------
ColladaParserAutoGen15Private::ColladaParserAutoGen15Private( COLLADASaxFWL15::ColladaParserAutoGen15* impl, GeneratedSaxParser::IErrorHandler* errorHandler 
)    : GeneratedSaxParser::ParserTemplate<ColladaParserAutoGen15Private, ColladaParserAutoGen15>(impl, errorHandler)
{
    initFunctionMap();
    initNameMap();
}

//---------------------------------------------------------------------
ColladaParserAutoGen15Private::~ColladaParserAutoGen15Private()
{
}


//---------------------------------------------------------------------
const char* NAME_NAMESPACE_COLLADA = "http://www.collada.org/2008/03/COLLADASchema";
const char* NAME_NAMESPACE_http___www_w3_org_2001_XMLSchema = "http://www.w3.org/2001/XMLSchema";
const char* NAME_NAMESPACE_http___www_w3_org_XML_1998_namespace = "http://www.w3.org/XML/1998/namespace";
const char* NAME_NAMESPACE_mathml = "http://www.w3.org/1998/Math/MathML";
const char* NAME_NAMESPACE_http___www_w3_org_1999_xlink = "http://www.w3.org/1999/xlink";

const char* NAME_ATTRIBUTE_ALTIMG = "altimg";
const char* NAME_ATTRIBUTE_ALTTEXT = "alttext";
const char* NAME_ATTRIBUTE_ARRAY_INDEX = "array_index";
const char* NAME_ATTRIBUTE_AUTO_GENERATE = "auto_generate";
const char* NAME_ATTRIBUTE_AXIS = NAME_ELEMENT_AXIS;
const char* NAME_ATTRIBUTE_BASE = "xml:base";
const char* NAME_ATTRIBUTE_BASELINE = "baseline";
const char* NAME_ATTRIBUTE_BODY = "body";
const char* NAME_ATTRIBUTE_CAMERA_NODE = "camera_node";
const char* NAME_ATTRIBUTE_CHANNELS = "channels";
const char* NAME_ATTRIBUTE_CLASS = "class";
const char* NAME_ATTRIBUTE_CLOSED = "closed";
const char* NAME_ATTRIBUTE_CLOSED_U = "closed_u";
const char* NAME_ATTRIBUTE_CLOSED_V = "closed_v";
const char* NAME_ATTRIBUTE_CLOSURE = "closure";
const char* NAME_ATTRIBUTE_CONSTRAINT = "constraint";
const char* NAME_ATTRIBUTE_CONVEX_HULL_OF = "convex_hull_of";
const char* NAME_ATTRIBUTE_COUNT = "count";
const char* NAME_ATTRIBUTE_DEFINITIONURL = "definitionURL";
const char* NAME_ATTRIBUTE_DEGREE = "degree";
const char* NAME_ATTRIBUTE_DEGREE_U = "degree_u";
const char* NAME_ATTRIBUTE_DEGREE_V = "degree_v";
const char* NAME_ATTRIBUTE_DEPTH = "depth";
const char* NAME_ATTRIBUTE_DIGITS = "digits";
const char* NAME_ATTRIBUTE_DISPLAY = "display";
const char* NAME_ATTRIBUTE_ENABLE = "enable";
const char* NAME_ATTRIBUTE_ENCODING = "encoding";
const char* NAME_ATTRIBUTE_END = "end";
const char* NAME_ATTRIBUTE_ENTRY = "entry";
const char* NAME_ATTRIBUTE_FACE = NAME_ELEMENT_FACE;
const char* NAME_ATTRIBUTE_FORMAT = "format";
const char* NAME_ATTRIBUTE_HEIGHT = "height";
const char* NAME_ATTRIBUTE_HREF = "href";
const char* NAME_ATTRIBUTE_ID = "id";
const char* NAME_ATTRIBUTE_INDEX = "index";
const char* NAME_ATTRIBUTE_INPUT_SEMANTIC = "input_semantic";
const char* NAME_ATTRIBUTE_INPUT_SET = "input_set";
const char* NAME_ATTRIBUTE_JOINT = NAME_ELEMENT_JOINT;
const char* NAME_ATTRIBUTE_LANGUAGE = "language";
const char* NAME_ATTRIBUTE_LAYER = "layer";
const char* NAME_ATTRIBUTE_LENGTH = "length";
const char* NAME_ATTRIBUTE_LEVELS = "levels";
const char* NAME_ATTRIBUTE_LINK = NAME_ELEMENT_LINK;
const char* NAME_ATTRIBUTE_MACROS = "macros";
const char* NAME_ATTRIBUTE_MAGNITUDE = "magnitude";
const char* NAME_ATTRIBUTE_MATERIAL = "material";
const char* NAME_ATTRIBUTE_MAXINCLUSIVE = "maxInclusive";
const char* NAME_ATTRIBUTE_METER = "meter";
const char* NAME_ATTRIBUTE_METHOD = "method";
const char* NAME_ATTRIBUTE_MININCLUSIVE = "minInclusive";
const char* NAME_ATTRIBUTE_MIP = "mip";
const char* NAME_ATTRIBUTE_MIPS_GENERATE = "mips_generate";
const char* NAME_ATTRIBUTE_MIP_INDEX = "mip_index";
const char* NAME_ATTRIBUTE_MODE = "mode";
const char* NAME_ATTRIBUTE_NAME = "name";
const char* NAME_ATTRIBUTE_NARGS = "nargs";
const char* NAME_ATTRIBUTE_NODE = NAME_ELEMENT_NODE;
const char* NAME_ATTRIBUTE_OCCURRENCE = "occurrence";
const char* NAME_ATTRIBUTE_OFFSET = "offset";
const char* NAME_ATTRIBUTE_OPAQUE = "opaque";
const char* NAME_ATTRIBUTE_OPERAND = "operand";
const char* NAME_ATTRIBUTE_OPERATOR = "operator";
const char* NAME_ATTRIBUTE_OPTIONS = "options";
const char* NAME_ATTRIBUTE_ORDER = "order";
const char* NAME_ATTRIBUTE_OVERFLOW = "overflow";
const char* NAME_ATTRIBUTE_PARAM = NAME_ELEMENT_PARAM;
const char* NAME_ATTRIBUTE_PARENT = "parent";
const char* NAME_ATTRIBUTE_PASS = NAME_ELEMENT_PASS;
const char* NAME_ATTRIBUTE_PLATFORM = "platform";
const char* NAME_ATTRIBUTE_PLATFORMS = "platforms";
const char* NAME_ATTRIBUTE_POST_BEHAVIOR = "post_behavior";
const char* NAME_ATTRIBUTE_PRECISION = "precision";
const char* NAME_ATTRIBUTE_PRE_BEHAVIOR = "pre_behavior";
const char* NAME_ATTRIBUTE_PROFILE = "profile";
const char* NAME_ATTRIBUTE_PROXY = "proxy";
const char* NAME_ATTRIBUTE_RANGE = "range";
const char* NAME_ATTRIBUTE_REF = "ref";
const char* NAME_ATTRIBUTE_RESIZABLE = "resizable";
const char* NAME_ATTRIBUTE_RIGID_BODY = NAME_ELEMENT_RIGID_BODY;
const char* NAME_ATTRIBUTE_SAMPLER = NAME_ELEMENT_SAMPLER;
const char* NAME_ATTRIBUTE_SCALE = "scale";
const char* NAME_ATTRIBUTE_SCOPE = "scope";
const char* NAME_ATTRIBUTE_SEMANTIC = "semantic";
const char* NAME_ATTRIBUTE_SET = "set";
const char* NAME_ATTRIBUTE_SHARE = "share";
const char* NAME_ATTRIBUTE_SID = "sid";
const char* NAME_ATTRIBUTE_SLICE = "slice";
const char* NAME_ATTRIBUTE_SOURCE = NAME_ELEMENT_SOURCE;
const char* NAME_ATTRIBUTE_SPACE = "space";
const char* NAME_ATTRIBUTE_STAGE = "stage";
const char* NAME_ATTRIBUTE_START = "start";
const char* NAME_ATTRIBUTE_STRIDE = "stride";
const char* NAME_ATTRIBUTE_STYLE = "style";
const char* NAME_ATTRIBUTE_SYMBOL = "symbol";
const char* NAME_ATTRIBUTE_TARGET = "target";
const char* NAME_ATTRIBUTE_TEXCOORD = "texcoord";
const char* NAME_ATTRIBUTE_TEXTURE = NAME_ELEMENT_TEXTURE;
const char* NAME_ATTRIBUTE_TYPE = "type";
const char* NAME_ATTRIBUTE_TYPENAME = "typename";
const char* NAME_ATTRIBUTE_URL = "url";
const char* NAME_ATTRIBUTE_VALUE = "value";
const char* NAME_ATTRIBUTE_VERSION = "version";
const char* NAME_ATTRIBUTE_WIDTH = "width";
const char* NAME_ATTRIBUTE_XMLNS = "xmlns";
const char* NAME_ATTRIBUTE_XREF = "xref";
const char* NAME_ELEMENT_ABS = "abs";
const char* NAME_ELEMENT_ACCELERATION = "acceleration";
const char* NAME_ELEMENT_ACCELERATION____COMMON_FLOAT2_OR_PARAM_TYPE = "acceleration____common_float2_or_param_type";
const char* NAME_ELEMENT_ACCELERATION____COMMON_FLOAT_OR_PARAM_TYPE = "acceleration____common_float_or_param_type";
const char* NAME_ELEMENT_ACCESSOR = "accessor";
const char* NAME_ELEMENT_ACTIVE = "active";
const char* NAME_ELEMENT_ALPHA = "alpha";
const char* NAME_ELEMENT_ALPHA_FUNC = "alpha_func";
const char* NAME_ELEMENT_ALPHA_TEST_ENABLE = "alpha_test_enable";
const char* NAME_ELEMENT_ALPHA____GLES_TEXCOMBINER_COMMAND_ALPHA_TYPE = "alpha____gles_texcombiner_command_alpha_type";
const char* NAME_ELEMENT_ALTITUDE = "altitude";
const char* NAME_ELEMENT_AMBIENT = "ambient";
const char* NAME_ELEMENT_AMBIENT____FX_COMMON_COLOR_OR_TEXTURE_TYPE = "ambient____fx_common_color_or_texture_type";
const char* NAME_ELEMENT_AND = "and";
const char* NAME_ELEMENT_ANGLE = "angle";
const char* NAME_ELEMENT_ANGULAR = "angular";
const char* NAME_ELEMENT_ANGULAR_VELOCITY = "angular_velocity";
const char* NAME_ELEMENT_ANIMATION = "animation";
const char* NAME_ELEMENT_ANIMATION_CLIP = "animation_clip";
const char* NAME_ELEMENT_ANNOTATE = "annotate";
const char* NAME_ELEMENT_ANNOTATION = "annotation";
const char* NAME_ELEMENT_ANNOTATION_XML = "annotation_xml";
const char* NAME_ELEMENT_APPLY = "apply";
const char* NAME_ELEMENT_APPROX = "approx";
const char* NAME_ELEMENT_ARCCOS = "arccos";
const char* NAME_ELEMENT_ARCCOSH = "arccosh";
const char* NAME_ELEMENT_ARCCOT = "arccot";
const char* NAME_ELEMENT_ARCCOTH = "arccoth";
const char* NAME_ELEMENT_ARCCSC = "arccsc";
const char* NAME_ELEMENT_ARCCSCH = "arccsch";
const char* NAME_ELEMENT_ARCSEC = "arcsec";
const char* NAME_ELEMENT_ARCSECH = "arcsech";
const char* NAME_ELEMENT_ARCSIN = "arcsin";
const char* NAME_ELEMENT_ARCSINH = "arcsinh";
const char* NAME_ELEMENT_ARCTAN = "arctan";
const char* NAME_ELEMENT_ARCTANH = "arctanh";
const char* NAME_ELEMENT_ARG = "arg";
const char* NAME_ELEMENT_ARGUMENT = "argument";
const char* NAME_ELEMENT_ARGUMENT____GLES_TEXCOMBINER_ARGUMENT_ALPHA_TYPE = "argument____gles_texcombiner_argument_alpha_type";
const char* NAME_ELEMENT_ARGUMENT____GLES_TEXCOMBINER_ARGUMENT_RGB_TYPE = "argument____gles_texcombiner_argument_rgb_type";
const char* NAME_ELEMENT_ARRAY = "array";
const char* NAME_ELEMENT_ARRAY____CG_ARRAY_TYPE = "array____cg_array_type";
const char* NAME_ELEMENT_ARRAY____GLSL_ARRAY_TYPE = "array____glsl_array_type";
const char* NAME_ELEMENT_ARTICULATED_SYSTEM = "articulated_system";
const char* NAME_ELEMENT_ASPECT_RATIO = "aspect_ratio";
const char* NAME_ELEMENT_ASSET = "asset";
const char* NAME_ELEMENT_ATTACHMENT = "attachment";
const char* NAME_ELEMENT_ATTACHMENT_END = "attachment_end";
const char* NAME_ELEMENT_ATTACHMENT_FULL = "attachment_full";
const char* NAME_ELEMENT_ATTACHMENT_START = "attachment_start";
const char* NAME_ELEMENT_AUTHOR = "author";
const char* NAME_ELEMENT_AUTHORING_TOOL = "authoring_tool";
const char* NAME_ELEMENT_AUTHOR_EMAIL = "author_email";
const char* NAME_ELEMENT_AUTHOR_WEBSITE = "author_website";
const char* NAME_ELEMENT_AXIS = "axis";
const char* NAME_ELEMENT_AXIS_INFO = "axis_info";
const char* NAME_ELEMENT_AXIS_INFO____KINEMATICS_AXIS_INFO_TYPE = "axis_info____kinematics_axis_info_type";
const char* NAME_ELEMENT_AXIS_INFO____MOTION_AXIS_INFO_TYPE = "axis_info____motion_axis_info_type";
const char* NAME_ELEMENT_AXIS____AXIS_TYPE = "axis____axis_type";
const char* NAME_ELEMENT_AXIS____COMMON_SIDREF_OR_PARAM_TYPE = "axis____common_sidref_or_param_type";
const char* NAME_ELEMENT_AXIS____FLOAT3_TYPE = "axis____float3_type";
const char* NAME_ELEMENT_BACK = "back";
const char* NAME_ELEMENT_BINARY = "binary";
const char* NAME_ELEMENT_BINARY__HEX = "binary__hex";
const char* NAME_ELEMENT_BIND = "bind";
const char* NAME_ELEMENT_BIND_ATTRIBUTE = "bind_attribute";
const char* NAME_ELEMENT_BIND_JOINT_AXIS = "bind_joint_axis";
const char* NAME_ELEMENT_BIND_KINEMATICS_MODEL = "bind_kinematics_model";
const char* NAME_ELEMENT_BIND_MATERIAL = "bind_material";
const char* NAME_ELEMENT_BIND_MATERIAL_TYPE____TECHNIQUE_COMMON = "bind_material_type____technique_common";
const char* NAME_ELEMENT_BIND_SHAPE_MATRIX = "bind_shape_matrix";
const char* NAME_ELEMENT_BIND_UNIFORM = "bind_uniform";
const char* NAME_ELEMENT_BIND_VERTEX_INPUT = "bind_vertex_input";
const char* NAME_ELEMENT_BIND____KINEMATICS_BIND_TYPE = "bind____kinematics_bind_type";
const char* NAME_ELEMENT_BLEND_COLOR = "blend_color";
const char* NAME_ELEMENT_BLEND_ENABLE = "blend_enable";
const char* NAME_ELEMENT_BLEND_EQUATION = "blend_equation";
const char* NAME_ELEMENT_BLEND_EQUATION_SEPARATE = "blend_equation_separate";
const char* NAME_ELEMENT_BLEND_FUNC = "blend_func";
const char* NAME_ELEMENT_BLEND_FUNC_SEPARATE = "blend_func_separate";
const char* NAME_ELEMENT_BLINN = "blinn";
const char* NAME_ELEMENT_BOOL = "bool";
const char* NAME_ELEMENT_BOOL2 = "bool2";
const char* NAME_ELEMENT_BOOL2X1 = "bool2x1";
const char* NAME_ELEMENT_BOOL2X2 = "bool2x2";
const char* NAME_ELEMENT_BOOL2X3 = "bool2x3";
const char* NAME_ELEMENT_BOOL2X4 = "bool2x4";
const char* NAME_ELEMENT_BOOL3 = "bool3";
const char* NAME_ELEMENT_BOOL3X1 = "bool3x1";
const char* NAME_ELEMENT_BOOL3X2 = "bool3x2";
const char* NAME_ELEMENT_BOOL3X3 = "bool3x3";
const char* NAME_ELEMENT_BOOL3X4 = "bool3x4";
const char* NAME_ELEMENT_BOOL4 = "bool4";
const char* NAME_ELEMENT_BOOL4X1 = "bool4x1";
const char* NAME_ELEMENT_BOOL4X2 = "bool4x2";
const char* NAME_ELEMENT_BOOL4X3 = "bool4x3";
const char* NAME_ELEMENT_BOOL4X4 = "bool4x4";
const char* NAME_ELEMENT_BOOL_ARRAY = "bool_array";
const char* NAME_ELEMENT_BORDER_COLOR = "border_color";
const char* NAME_ELEMENT_BOX = "box";
const char* NAME_ELEMENT_BREP = "brep";
const char* NAME_ELEMENT_BVAR = "bvar";
const char* NAME_ELEMENT_BVEC2 = "bvec2";
const char* NAME_ELEMENT_BVEC3 = "bvec3";
const char* NAME_ELEMENT_BVEC4 = "bvec4";
const char* NAME_ELEMENT_CAMERA = "camera";
const char* NAME_ELEMENT_CAPSULE = "capsule";
const char* NAME_ELEMENT_CARD = "card";
const char* NAME_ELEMENT_CARTESIANPRODUCT = "cartesianproduct";
const char* NAME_ELEMENT_CEILING = "ceiling";
const char* NAME_ELEMENT_CG_PASS_TYPE____EVALUATE = "cg_pass_type____evaluate";
const char* NAME_ELEMENT_CG_PASS_TYPE____PROGRAM = "cg_pass_type____program";
const char* NAME_ELEMENT_CG_PASS_TYPE____STATES = "cg_pass_type____states";
const char* NAME_ELEMENT_CHANNEL = "channel";
const char* NAME_ELEMENT_CI = "ci";
const char* NAME_ELEMENT_CIRCLE = "circle";
const char* NAME_ELEMENT_CLIP_PLANE = "clip_plane";
const char* NAME_ELEMENT_CLIP_PLANE_ENABLE = "clip_plane_enable";
const char* NAME_ELEMENT_CN = "cn";
const char* NAME_ELEMENT_CODE = "code";
const char* NAME_ELEMENT_CODOMAIN = "codomain";
const char* NAME_ELEMENT_COLLADA = "COLLADA";
const char* NAME_ELEMENT_COLOR = "color";
const char* NAME_ELEMENT_COLOR_CLEAR = "color_clear";
const char* NAME_ELEMENT_COLOR_LOGIC_OP_ENABLE = "color_logic_op_enable";
const char* NAME_ELEMENT_COLOR_MASK = "color_mask";
const char* NAME_ELEMENT_COLOR_MATERIAL = "color_material";
const char* NAME_ELEMENT_COLOR_MATERIAL_ENABLE = "color_material_enable";
const char* NAME_ELEMENT_COLOR_MATERIAL__FACE = "color_material__face";
const char* NAME_ELEMENT_COLOR_MATERIAL__MODE = "color_material__mode";
const char* NAME_ELEMENT_COLOR_TARGET = "color_target";
const char* NAME_ELEMENT_COLOR____TARGETABLE_FLOAT3_TYPE = "color____targetable_float3_type";
const char* NAME_ELEMENT_COMMENTS = "comments";
const char* NAME_ELEMENT_COMPILER = "compiler";
const char* NAME_ELEMENT_COMPLEXES = "complexes";
const char* NAME_ELEMENT_COMPOSE = "compose";
const char* NAME_ELEMENT_CONDITION = "condition";
const char* NAME_ELEMENT_CONE = "cone";
const char* NAME_ELEMENT_CONJUGATE = "conjugate";
const char* NAME_ELEMENT_CONNECT_PARAM = "connect_param";
const char* NAME_ELEMENT_CONSTANT = "constant";
const char* NAME_ELEMENT_CONSTANT_ATTENUATION = "constant_attenuation";
const char* NAME_ELEMENT_CONSTANT____GLES_TEXTURE_CONSTANT_TYPE = "constant____gles_texture_constant_type";
const char* NAME_ELEMENT_CONTRIBUTOR = "contributor";
const char* NAME_ELEMENT_CONTROLLER = "controller";
const char* NAME_ELEMENT_CONTROL_VERTICES = "control_vertices";
const char* NAME_ELEMENT_CONVEX_MESH = "convex_mesh";
const char* NAME_ELEMENT_COPYRIGHT = "copyright";
const char* NAME_ELEMENT_COS = "cos";
const char* NAME_ELEMENT_COSH = "cosh";
const char* NAME_ELEMENT_COT = "cot";
const char* NAME_ELEMENT_COTH = "coth";
const char* NAME_ELEMENT_COVERAGE = "coverage";
const char* NAME_ELEMENT_CREATED = "created";
const char* NAME_ELEMENT_CREATE_2D = "create_2d";
const char* NAME_ELEMENT_CREATE_2D__ARRAY = "create_2d__array";
const char* NAME_ELEMENT_CREATE_2D__FORMAT = "create_2d__format";
const char* NAME_ELEMENT_CREATE_2D__FORMAT__HINT = "create_2d__format__hint";
const char* NAME_ELEMENT_CREATE_2D__INIT_FROM = "create_2d__init_from";
const char* NAME_ELEMENT_CREATE_3D = "create_3d";
const char* NAME_ELEMENT_CREATE_3D__ARRAY = "create_3d__array";
const char* NAME_ELEMENT_CREATE_3D__FORMAT = "create_3d__format";
const char* NAME_ELEMENT_CREATE_3D__FORMAT__HINT = "create_3d__format__hint";
const char* NAME_ELEMENT_CREATE_3D__INIT_FROM = "create_3d__init_from";
const char* NAME_ELEMENT_CREATE_3D__SIZE = "create_3d__size";
const char* NAME_ELEMENT_CREATE_CUBE = "create_cube";
const char* NAME_ELEMENT_CREATE_CUBE__ARRAY = "create_cube__array";
const char* NAME_ELEMENT_CREATE_CUBE__FORMAT = "create_cube__format";
const char* NAME_ELEMENT_CREATE_CUBE__FORMAT__HINT = "create_cube__format__hint";
const char* NAME_ELEMENT_CREATE_CUBE__INIT_FROM = "create_cube__init_from";
const char* NAME_ELEMENT_CREATE_CUBE__SIZE = "create_cube__size";
const char* NAME_ELEMENT_CSC = "csc";
const char* NAME_ELEMENT_CSCH = "csch";
const char* NAME_ELEMENT_CSYMBOL = "csymbol";
const char* NAME_ELEMENT_CULL_FACE = "cull_face";
const char* NAME_ELEMENT_CULL_FACE_ENABLE = "cull_face_enable";
const char* NAME_ELEMENT_CURL = "curl";
const char* NAME_ELEMENT_CURVE = "curve";
const char* NAME_ELEMENT_CURVES = "curves";
const char* NAME_ELEMENT_CYLINDER = "cylinder";
const char* NAME_ELEMENT_CYLINDER____CYLINDER_TYPE = "cylinder____cylinder_type";
const char* NAME_ELEMENT_DAMPING = "damping";
const char* NAME_ELEMENT_DECELERATION = "deceleration";
const char* NAME_ELEMENT_DECELERATION____COMMON_FLOAT2_OR_PARAM_TYPE = "deceleration____common_float2_or_param_type";
const char* NAME_ELEMENT_DECELERATION____COMMON_FLOAT_OR_PARAM_TYPE = "deceleration____common_float_or_param_type";
const char* NAME_ELEMENT_DECLARE = "declare";
const char* NAME_ELEMENT_DEGREE = NAME_ATTRIBUTE_DEGREE;
const char* NAME_ELEMENT_DENSITY = "density";
const char* NAME_ELEMENT_DEPTH_BOUNDS = "depth_bounds";
const char* NAME_ELEMENT_DEPTH_BOUNDS_ENABLE = "depth_bounds_enable";
const char* NAME_ELEMENT_DEPTH_CLAMP_ENABLE = "depth_clamp_enable";
const char* NAME_ELEMENT_DEPTH_CLEAR = "depth_clear";
const char* NAME_ELEMENT_DEPTH_FUNC = "depth_func";
const char* NAME_ELEMENT_DEPTH_MASK = "depth_mask";
const char* NAME_ELEMENT_DEPTH_RANGE = "depth_range";
const char* NAME_ELEMENT_DEPTH_TARGET = "depth_target";
const char* NAME_ELEMENT_DEPTH_TEST_ENABLE = "depth_test_enable";
const char* NAME_ELEMENT_DEST = "dest";
const char* NAME_ELEMENT_DEST_ALPHA = "dest_alpha";
const char* NAME_ELEMENT_DEST_RGB = "dest_rgb";
const char* NAME_ELEMENT_DETERMINANT = "determinant";
const char* NAME_ELEMENT_DIFF = "diff";
const char* NAME_ELEMENT_DIFFUSE = "diffuse";
const char* NAME_ELEMENT_DIRECTION = "direction";
const char* NAME_ELEMENT_DIRECTIONAL = "directional";
const char* NAME_ELEMENT_DITHER_ENABLE = "dither_enable";
const char* NAME_ELEMENT_DIVERGENCE = "divergence";
const char* NAME_ELEMENT_DIVIDE = "divide";
const char* NAME_ELEMENT_DOMAIN = "domain";
const char* NAME_ELEMENT_DOMAINOFAPPLICATION = "domainofapplication";
const char* NAME_ELEMENT_DRAW = "draw";
const char* NAME_ELEMENT_DYNAMIC = "dynamic";
const char* NAME_ELEMENT_DYNAMIC_FRICTION = "dynamic_friction";
const char* NAME_ELEMENT_EDGES = "edges";
const char* NAME_ELEMENT_EFFECT = "effect";
const char* NAME_ELEMENT_EFFECTOR_INFO = "effector_info";
const char* NAME_ELEMENT_ELLIPSE = "ellipse";
const char* NAME_ELEMENT_EMISSION = "emission";
const char* NAME_ELEMENT_EMPTYSET = "emptyset";
const char* NAME_ELEMENT_ENABLED = "enabled";
const char* NAME_ELEMENT_ENUM = "enum";
const char* NAME_ELEMENT_ENUM____GLES_ENUMERATION_TYPE = "enum____gles_enumeration_type";
const char* NAME_ELEMENT_ENUM____GL_ENUMERATION_TYPE = "enum____gl_enumeration_type";
const char* NAME_ELEMENT_ENUM____STRING = "enum____string";
const char* NAME_ELEMENT_EQ = "eq";
const char* NAME_ELEMENT_EQUATION = "equation";
const char* NAME_ELEMENT_EQUIVALENT = "equivalent";
const char* NAME_ELEMENT_EULERGAMMA = "eulergamma";
const char* NAME_ELEMENT_EVALUATE = "evaluate";
const char* NAME_ELEMENT_EVALUATE_SCENE = "evaluate_scene";
const char* NAME_ELEMENT_EXACT = "exact";
const char* NAME_ELEMENT_EXISTS = "exists";
const char* NAME_ELEMENT_EXP = "exp";
const char* NAME_ELEMENT_EXPONENTIALE = "exponentiale";
const char* NAME_ELEMENT_EXTRA = "extra";
const char* NAME_ELEMENT_FACE = "face";
const char* NAME_ELEMENT_FACES = "faces";
const char* NAME_ELEMENT_FACTORIAL = "factorial";
const char* NAME_ELEMENT_FACTOROF = "factorof";
const char* NAME_ELEMENT_FAIL = "fail";
const char* NAME_ELEMENT_FALLOFF_ANGLE = "falloff_angle";
const char* NAME_ELEMENT_FALLOFF_EXPONENT = "falloff_exponent";
const char* NAME_ELEMENT_FALSE = "false";
const char* NAME_ELEMENT_FIXED = "fixed";
const char* NAME_ELEMENT_FIXED2 = "fixed2";
const char* NAME_ELEMENT_FIXED2X1 = "fixed2x1";
const char* NAME_ELEMENT_FIXED2X2 = "fixed2x2";
const char* NAME_ELEMENT_FIXED2X3 = "fixed2x3";
const char* NAME_ELEMENT_FIXED2X4 = "fixed2x4";
const char* NAME_ELEMENT_FIXED3 = "fixed3";
const char* NAME_ELEMENT_FIXED3X1 = "fixed3x1";
const char* NAME_ELEMENT_FIXED3X2 = "fixed3x2";
const char* NAME_ELEMENT_FIXED3X3 = "fixed3x3";
const char* NAME_ELEMENT_FIXED3X4 = "fixed3x4";
const char* NAME_ELEMENT_FIXED4 = "fixed4";
const char* NAME_ELEMENT_FIXED4X1 = "fixed4x1";
const char* NAME_ELEMENT_FIXED4X2 = "fixed4x2";
const char* NAME_ELEMENT_FIXED4X3 = "fixed4x3";
const char* NAME_ELEMENT_FIXED4X4 = "fixed4x4";
const char* NAME_ELEMENT_FLOAT = "float";
const char* NAME_ELEMENT_FLOAT1X1 = "float1x1";
const char* NAME_ELEMENT_FLOAT1X2 = "float1x2";
const char* NAME_ELEMENT_FLOAT1X3 = "float1x3";
const char* NAME_ELEMENT_FLOAT1X4 = "float1x4";
const char* NAME_ELEMENT_FLOAT2 = "float2";
const char* NAME_ELEMENT_FLOAT2X1 = "float2x1";
const char* NAME_ELEMENT_FLOAT2X2 = "float2x2";
const char* NAME_ELEMENT_FLOAT2X3 = "float2x3";
const char* NAME_ELEMENT_FLOAT2X4 = "float2x4";
const char* NAME_ELEMENT_FLOAT3 = "float3";
const char* NAME_ELEMENT_FLOAT3X1 = "float3x1";
const char* NAME_ELEMENT_FLOAT3X2 = "float3x2";
const char* NAME_ELEMENT_FLOAT3X3 = "float3x3";
const char* NAME_ELEMENT_FLOAT3X4 = "float3x4";
const char* NAME_ELEMENT_FLOAT4 = "float4";
const char* NAME_ELEMENT_FLOAT4X1 = "float4x1";
const char* NAME_ELEMENT_FLOAT4X2 = "float4x2";
const char* NAME_ELEMENT_FLOAT4X3 = "float4x3";
const char* NAME_ELEMENT_FLOAT4X4 = "float4x4";
const char* NAME_ELEMENT_FLOAT_ARRAY = "float_array";
const char* NAME_ELEMENT_FLOAT____FLOAT_TYPE = "float____float_type";
const char* NAME_ELEMENT_FLOOR = "floor";
const char* NAME_ELEMENT_FOCAL = "focal";
const char* NAME_ELEMENT_FOG_COLOR = "fog_color";
const char* NAME_ELEMENT_FOG_COORD_SRC = "fog_coord_src";
const char* NAME_ELEMENT_FOG_DENSITY = "fog_density";
const char* NAME_ELEMENT_FOG_ENABLE = "fog_enable";
const char* NAME_ELEMENT_FOG_END = "fog_end";
const char* NAME_ELEMENT_FOG_MODE = "fog_mode";
const char* NAME_ELEMENT_FOG_START = "fog_start";
const char* NAME_ELEMENT_FORALL = "forall";
const char* NAME_ELEMENT_FORCE_FIELD = "force_field";
const char* NAME_ELEMENT_FORMAT = NAME_ATTRIBUTE_FORMAT;
const char* NAME_ELEMENT_FORMULA = "formula";
const char* NAME_ELEMENT_FRAME_OBJECT = "frame_object";
const char* NAME_ELEMENT_FRAME_ORIGIN = "frame_origin";
const char* NAME_ELEMENT_FRAME_TCP = "frame_tcp";
const char* NAME_ELEMENT_FRAME_TIP = "frame_tip";
const char* NAME_ELEMENT_FRONT = "front";
const char* NAME_ELEMENT_FRONT_FACE = "front_face";
const char* NAME_ELEMENT_FUNC = "func";
const char* NAME_ELEMENT_FX_COLORTARGET_TYPE____PARAM = "fx_colortarget_type____param";
const char* NAME_ELEMENT_FX_COMMON_COLOR_OR_TEXTURE_TYPE____COLOR = "fx_common_color_or_texture_type____color";
const char* NAME_ELEMENT_FX_COMMON_COLOR_OR_TEXTURE_TYPE____PARAM = "fx_common_color_or_texture_type____param";
const char* NAME_ELEMENT_FX_COMMON_FLOAT_OR_PARAM_TYPE____FLOAT = "fx_common_float_or_param_type____float";
const char* NAME_ELEMENT_FX_COMMON_FLOAT_OR_PARAM_TYPE____PARAM = "fx_common_float_or_param_type____param";
const char* NAME_ELEMENT_GCD = "gcd";
const char* NAME_ELEMENT_GEOGRAPHIC_LOCATION = "geographic_location";
const char* NAME_ELEMENT_GEOMETRY = "geometry";
const char* NAME_ELEMENT_GEQ = "geq";
const char* NAME_ELEMENT_GLES2_PASS_TYPE____EVALUATE = "gles2_pass_type____evaluate";
const char* NAME_ELEMENT_GLES2_PASS_TYPE____STATES = "gles2_pass_type____states";
const char* NAME_ELEMENT_GLES2_PROGRAM_TYPE____BIND_ATTRIBUTE = "gles2_program_type____bind_attribute";
const char* NAME_ELEMENT_GLES2_PROGRAM_TYPE____BIND_UNIFORM = "gles2_program_type____bind_uniform";
const char* NAME_ELEMENT_GLES2_SHADER_TYPE____SOURCES = "gles2_shader_type____sources";
const char* NAME_ELEMENT_GLSL_PROGRAM_TYPE____BIND_ATTRIBUTE = "glsl_program_type____bind_attribute";
const char* NAME_ELEMENT_GLSL_PROGRAM_TYPE____BIND_UNIFORM = "glsl_program_type____bind_uniform";
const char* NAME_ELEMENT_GRAD = "grad";
const char* NAME_ELEMENT_GRAVITY = "gravity";
const char* NAME_ELEMENT_GT = "gt";
const char* NAME_ELEMENT_H = "h";
const char* NAME_ELEMENT_HALF = "half";
const char* NAME_ELEMENT_HALF2 = "half2";
const char* NAME_ELEMENT_HALF2X1 = "half2x1";
const char* NAME_ELEMENT_HALF2X2 = "half2x2";
const char* NAME_ELEMENT_HALF2X3 = "half2x3";
const char* NAME_ELEMENT_HALF2X4 = "half2x4";
const char* NAME_ELEMENT_HALF3 = "half3";
const char* NAME_ELEMENT_HALF3X1 = "half3x1";
const char* NAME_ELEMENT_HALF3X2 = "half3x2";
const char* NAME_ELEMENT_HALF3X3 = "half3x3";
const char* NAME_ELEMENT_HALF3X4 = "half3x4";
const char* NAME_ELEMENT_HALF4 = "half4";
const char* NAME_ELEMENT_HALF4X1 = "half4x1";
const char* NAME_ELEMENT_HALF4X2 = "half4x2";
const char* NAME_ELEMENT_HALF4X3 = "half4x3";
const char* NAME_ELEMENT_HALF4X4 = "half4x4";
const char* NAME_ELEMENT_HALF_EXTENTS = "half_extents";
const char* NAME_ELEMENT_HEIGHT = NAME_ATTRIBUTE_HEIGHT;
const char* NAME_ELEMENT_HEX = "hex";
const char* NAME_ELEMENT_HINT = "hint";
const char* NAME_ELEMENT_HOLLOW = "hollow";
const char* NAME_ELEMENT_HYPERBOLA = "hyperbola";
const char* NAME_ELEMENT_IDENT = "ident";
const char* NAME_ELEMENT_IDREF_ARRAY = "IDREF_array";
const char* NAME_ELEMENT_IMAGE = "image";
const char* NAME_ELEMENT_IMAGER = "imager";
const char* NAME_ELEMENT_IMAGE_TYPE____INIT_FROM = "image_type____init_from";
const char* NAME_ELEMENT_IMAGE____FUNCTIONS_TYPE = "image____Functions_type";
const char* NAME_ELEMENT_IMAGE____IMAGE_TYPE = "image____image_type";
const char* NAME_ELEMENT_IMAGINARY = "imaginary";
const char* NAME_ELEMENT_IMAGINARYI = "imaginaryi";
const char* NAME_ELEMENT_IMPLIES = "implies";
const char* NAME_ELEMENT_IMPORT = "import";
const char* NAME_ELEMENT_IN = "in";
const char* NAME_ELEMENT_INCLUDE = "include";
const char* NAME_ELEMENT_INDEX = NAME_ATTRIBUTE_INDEX;
const char* NAME_ELEMENT_INDEX_OF_REFRACTION = "index_of_refraction";
const char* NAME_ELEMENT_INERTIA = "inertia";
const char* NAME_ELEMENT_INFINITY = "infinity";
const char* NAME_ELEMENT_INIT_FROM = "init_from";
const char* NAME_ELEMENT_INLINE = "inline";
const char* NAME_ELEMENT_INPUT = "input";
const char* NAME_ELEMENT_INPUT____INPUT_LOCAL_OFFSET_TYPE = "input____input_local_offset_type";
const char* NAME_ELEMENT_INPUT____INPUT_LOCAL_TYPE = "input____input_local_type";
const char* NAME_ELEMENT_INSTANCE_ANIMATION = "instance_animation";
const char* NAME_ELEMENT_INSTANCE_ARTICULATED_SYSTEM = "instance_articulated_system";
const char* NAME_ELEMENT_INSTANCE_CAMERA = "instance_camera";
const char* NAME_ELEMENT_INSTANCE_CONTROLLER = "instance_controller";
const char* NAME_ELEMENT_INSTANCE_EFFECT = "instance_effect";
const char* NAME_ELEMENT_INSTANCE_EFFECT_TYPE____SETPARAM = "instance_effect_type____setparam";
const char* NAME_ELEMENT_INSTANCE_FORCE_FIELD = "instance_force_field";
const char* NAME_ELEMENT_INSTANCE_FORMULA = "instance_formula";
const char* NAME_ELEMENT_INSTANCE_GEOMETRY = "instance_geometry";
const char* NAME_ELEMENT_INSTANCE_IMAGE = "instance_image";
const char* NAME_ELEMENT_INSTANCE_JOINT = "instance_joint";
const char* NAME_ELEMENT_INSTANCE_KINEMATICS_MODEL = "instance_kinematics_model";
const char* NAME_ELEMENT_INSTANCE_KINEMATICS_SCENE = "instance_kinematics_scene";
const char* NAME_ELEMENT_INSTANCE_LIGHT = "instance_light";
const char* NAME_ELEMENT_INSTANCE_MATERIAL = "instance_material";
const char* NAME_ELEMENT_INSTANCE_MATERIAL_TYPE____BIND = "instance_material_type____bind";
const char* NAME_ELEMENT_INSTANCE_MATERIAL____INSTANCE_MATERIAL_TYPE = "instance_material____instance_material_type";
const char* NAME_ELEMENT_INSTANCE_NODE = "instance_node";
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MATERIAL = "instance_physics_material";
const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL = "instance_physics_model";
const char* NAME_ELEMENT_INSTANCE_PHYSICS_SCENE = "instance_physics_scene";
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY = "instance_rigid_body";
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY_TYPE____TECHNIQUE_COMMON = "instance_rigid_body_type____technique_common";
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE_COMMON__DYNAMIC = "instance_rigid_body__technique_common__dynamic";
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE_COMMON__MASS_FRAME = "instance_rigid_body__technique_common__mass_frame";
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE_COMMON__SHAPE = "instance_rigid_body__technique_common__shape";
const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE_COMMON__SHAPE__HOLLOW = "instance_rigid_body__technique_common__shape__hollow";
const char* NAME_ELEMENT_INSTANCE_RIGID_CONSTRAINT = "instance_rigid_constraint";
const char* NAME_ELEMENT_INSTANCE_VISUAL_SCENE = "instance_visual_scene";
const char* NAME_ELEMENT_INT = "int";
const char* NAME_ELEMENT_INT2 = "int2";
const char* NAME_ELEMENT_INT2X1 = "int2x1";
const char* NAME_ELEMENT_INT2X2 = "int2x2";
const char* NAME_ELEMENT_INT2X3 = "int2x3";
const char* NAME_ELEMENT_INT2X4 = "int2x4";
const char* NAME_ELEMENT_INT3 = "int3";
const char* NAME_ELEMENT_INT3X1 = "int3x1";
const char* NAME_ELEMENT_INT3X2 = "int3x2";
const char* NAME_ELEMENT_INT3X3 = "int3x3";
const char* NAME_ELEMENT_INT3X4 = "int3x4";
const char* NAME_ELEMENT_INT4 = "int4";
const char* NAME_ELEMENT_INT4X1 = "int4x1";
const char* NAME_ELEMENT_INT4X2 = "int4x2";
const char* NAME_ELEMENT_INT4X3 = "int4x3";
const char* NAME_ELEMENT_INT4X4 = "int4x4";
const char* NAME_ELEMENT_INTEGERS = "integers";
const char* NAME_ELEMENT_INTERPENETRATE = "interpenetrate";
const char* NAME_ELEMENT_INTERSECT = "intersect";
const char* NAME_ELEMENT_INTERVAL = "interval";
const char* NAME_ELEMENT_INT_ARRAY = "int_array";
const char* NAME_ELEMENT_INT____INT_TYPE = "int____int_type";
const char* NAME_ELEMENT_INT____INT_TYPE____MATHML = "int____int_type____mathml";
const char* NAME_ELEMENT_INVERSE = "inverse";
const char* NAME_ELEMENT_INVERT = "invert";
const char* NAME_ELEMENT_IVEC2 = "ivec2";
const char* NAME_ELEMENT_IVEC3 = "ivec3";
const char* NAME_ELEMENT_IVEC4 = "ivec4";
const char* NAME_ELEMENT_JERK = "jerk";
const char* NAME_ELEMENT_JERK____COMMON_FLOAT2_OR_PARAM_TYPE = "jerk____common_float2_or_param_type";
const char* NAME_ELEMENT_JERK____COMMON_FLOAT_OR_PARAM_TYPE = "jerk____common_float_or_param_type";
const char* NAME_ELEMENT_JOINT = "joint";
const char* NAME_ELEMENT_JOINTS = "joints";
const char* NAME_ELEMENT_KEYWORDS = "keywords";
const char* NAME_ELEMENT_KINEMATICS = "kinematics";
const char* NAME_ELEMENT_KINEMATICS_MODEL = "kinematics_model";
const char* NAME_ELEMENT_KINEMATICS_SCENE = "kinematics_scene";
const char* NAME_ELEMENT_LAMBDA = "lambda";
const char* NAME_ELEMENT_LAMBERT = "lambert";
const char* NAME_ELEMENT_LAPLACIAN = "laplacian";
const char* NAME_ELEMENT_LATITUDE = "latitude";
const char* NAME_ELEMENT_LAYER = NAME_ATTRIBUTE_LAYER;
const char* NAME_ELEMENT_LCM = "lcm";
const char* NAME_ELEMENT_LEQ = "leq";
const char* NAME_ELEMENT_LIBRARY_ANIMATIONS = "library_animations";
const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS = "library_animation_clips";
const char* NAME_ELEMENT_LIBRARY_ARTICULATED_SYSTEMS = "library_articulated_systems";
const char* NAME_ELEMENT_LIBRARY_CAMERAS = "library_cameras";
const char* NAME_ELEMENT_LIBRARY_CONTROLLERS = "library_controllers";
const char* NAME_ELEMENT_LIBRARY_EFFECTS = "library_effects";
const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS = "library_force_fields";
const char* NAME_ELEMENT_LIBRARY_FORMULAS = "library_formulas";
const char* NAME_ELEMENT_LIBRARY_GEOMETRIES = "library_geometries";
const char* NAME_ELEMENT_LIBRARY_IMAGES = "library_images";
const char* NAME_ELEMENT_LIBRARY_IMAGES__IMAGE__INIT_FROM__HEX = "library_images__image__init_from__hex";
const char* NAME_ELEMENT_LIBRARY_JOINTS = "library_joints";
const char* NAME_ELEMENT_LIBRARY_KINEMATICS_MODELS = "library_kinematics_models";
const char* NAME_ELEMENT_LIBRARY_KINEMATICS_SCENES = "library_kinematics_scenes";
const char* NAME_ELEMENT_LIBRARY_LIGHTS = "library_lights";
const char* NAME_ELEMENT_LIBRARY_MATERIALS = "library_materials";
const char* NAME_ELEMENT_LIBRARY_NODES = "library_nodes";
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS = "library_physics_materials";
const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS = "library_physics_models";
const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES = "library_physics_scenes";
const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES = "library_visual_scenes";
const char* NAME_ELEMENT_LIGHT = "light";
const char* NAME_ELEMENT_LIGHTING_ENABLE = "lighting_enable";
const char* NAME_ELEMENT_LIGHT_AMBIENT = "light_ambient";
const char* NAME_ELEMENT_LIGHT_CONSTANT_ATTENUATION = "light_constant_attenuation";
const char* NAME_ELEMENT_LIGHT_DIFFUSE = "light_diffuse";
const char* NAME_ELEMENT_LIGHT_ENABLE = "light_enable";
const char* NAME_ELEMENT_LIGHT_LINEAR_ATTENUATION = "light_linear_attenuation";
const char* NAME_ELEMENT_LIGHT_MODEL_AMBIENT = "light_model_ambient";
const char* NAME_ELEMENT_LIGHT_MODEL_COLOR_CONTROL = "light_model_color_control";
const char* NAME_ELEMENT_LIGHT_MODEL_LOCAL_VIEWER_ENABLE = "light_model_local_viewer_enable";
const char* NAME_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE = "light_model_two_side_enable";
const char* NAME_ELEMENT_LIGHT_POSITION = "light_position";
const char* NAME_ELEMENT_LIGHT_QUADRATIC_ATTENUATION = "light_quadratic_attenuation";
const char* NAME_ELEMENT_LIGHT_SPECULAR = "light_specular";
const char* NAME_ELEMENT_LIGHT_SPOT_CUTOFF = "light_spot_cutoff";
const char* NAME_ELEMENT_LIGHT_SPOT_DIRECTION = "light_spot_direction";
const char* NAME_ELEMENT_LIGHT_SPOT_EXPONENT = "light_spot_exponent";
const char* NAME_ELEMENT_LIGHT_TYPE____TECHNIQUE_COMMON = "light_type____technique_common";
const char* NAME_ELEMENT_LIGHT__TECHNIQUE_COMMON__AMBIENT = "light__technique_common__ambient";
const char* NAME_ELEMENT_LIMIT = "limit";
const char* NAME_ELEMENT_LIMITS = "limits";
const char* NAME_ELEMENT_LIMITS____JOINT_LIMITS_TYPE = "limits____joint_limits_type";
const char* NAME_ELEMENT_LIMITS____KINEMATICS_LIMITS_TYPE = "limits____kinematics_limits_type";
const char* NAME_ELEMENT_LINE = "line";
const char* NAME_ELEMENT_LINEAR = "linear";
const char* NAME_ELEMENT_LINEAR_ATTENUATION = "linear_attenuation";
const char* NAME_ELEMENT_LINES = "lines";
const char* NAME_ELEMENT_LINESTRIPS = "linestrips";
const char* NAME_ELEMENT_LINE_SMOOTH_ENABLE = "line_smooth_enable";
const char* NAME_ELEMENT_LINE_STIPPLE = "line_stipple";
const char* NAME_ELEMENT_LINE_STIPPLE_ENABLE = "line_stipple_enable";
const char* NAME_ELEMENT_LINE_WIDTH = "line_width";
const char* NAME_ELEMENT_LINK = "link";
const char* NAME_ELEMENT_LINKER = "linker";
const char* NAME_ELEMENT_LIST = "list";
const char* NAME_ELEMENT_LN = "ln";
const char* NAME_ELEMENT_LOCKED = "locked";
const char* NAME_ELEMENT_LOG = "log";
const char* NAME_ELEMENT_LOGBASE = "logbase";
const char* NAME_ELEMENT_LOGIC_OP = "logic_op";
const char* NAME_ELEMENT_LOGIC_OP_ENABLE = "logic_op_enable";
const char* NAME_ELEMENT_LONGITUDE = "longitude";
const char* NAME_ELEMENT_LOOKAT = "lookat";
const char* NAME_ELEMENT_LOWLIMIT = "lowlimit";
const char* NAME_ELEMENT_LT = "lt";
const char* NAME_ELEMENT_MAGFILTER = "magfilter";
const char* NAME_ELEMENT_MASK = "mask";
const char* NAME_ELEMENT_MASS = "mass";
const char* NAME_ELEMENT_MASS_FRAME = "mass_frame";
const char* NAME_ELEMENT_MAT2 = "mat2";
const char* NAME_ELEMENT_MAT3 = "mat3";
const char* NAME_ELEMENT_MAT4 = "mat4";
const char* NAME_ELEMENT_MATERIAL = NAME_ATTRIBUTE_MATERIAL;
const char* NAME_ELEMENT_MATERIAL_AMBIENT = "material_ambient";
const char* NAME_ELEMENT_MATERIAL_DIFFUSE = "material_diffuse";
const char* NAME_ELEMENT_MATERIAL_EMISSION = "material_emission";
const char* NAME_ELEMENT_MATERIAL_SHININESS = "material_shininess";
const char* NAME_ELEMENT_MATERIAL_SPECULAR = "material_specular";
const char* NAME_ELEMENT_MATH = "math";
const char* NAME_ELEMENT_MATRIX = "matrix";
const char* NAME_ELEMENT_MATRIXROW = "matrixrow";
const char* NAME_ELEMENT_MATRIX____MATRIX_TYPE = "matrix____matrix_type";
const char* NAME_ELEMENT_MATRIX____MATRIX_TYPE____MATHML = "matrix____matrix_type____mathml";
const char* NAME_ELEMENT_MAX = "max";
const char* NAME_ELEMENT_MAX_ANISOTROPY = "max_anisotropy";
const char* NAME_ELEMENT_MAX____ARITH_TYPE = "max____Arith_type";
const char* NAME_ELEMENT_MAX____COMMON_FLOAT_OR_PARAM_TYPE = "max____common_float_or_param_type";
const char* NAME_ELEMENT_MAX____MINMAX_TYPE = "max____minmax_type";
const char* NAME_ELEMENT_MAX____TARGETABLE_FLOAT3_TYPE = "max____targetable_float3_type";
const char* NAME_ELEMENT_MEAN = "mean";
const char* NAME_ELEMENT_MEDIAN = "median";
const char* NAME_ELEMENT_MESH = "mesh";
const char* NAME_ELEMENT_MIN = "min";
const char* NAME_ELEMENT_MINFILTER = "minfilter";
const char* NAME_ELEMENT_MINUS = "minus";
const char* NAME_ELEMENT_MIN____ARITH_TYPE = "min____Arith_type";
const char* NAME_ELEMENT_MIN____COMMON_FLOAT_OR_PARAM_TYPE = "min____common_float_or_param_type";
const char* NAME_ELEMENT_MIN____MINMAX_TYPE = "min____minmax_type";
const char* NAME_ELEMENT_MIN____TARGETABLE_FLOAT3_TYPE = "min____targetable_float3_type";
const char* NAME_ELEMENT_MIPFILTER = "mipfilter";
const char* NAME_ELEMENT_MIPS = "mips";
const char* NAME_ELEMENT_MIP_BIAS = "mip_bias";
const char* NAME_ELEMENT_MIP_MAX_LEVEL = "mip_max_level";
const char* NAME_ELEMENT_MIP_MIN_LEVEL = "mip_min_level";
const char* NAME_ELEMENT_MODE = NAME_ATTRIBUTE_MODE;
const char* NAME_ELEMENT_MODEL_VIEW_MATRIX = "model_view_matrix";
const char* NAME_ELEMENT_MODE____MODE_TYPE = "mode____mode_type";
const char* NAME_ELEMENT_MODIFIED = "modified";
const char* NAME_ELEMENT_MODIFIER = "modifier";
const char* NAME_ELEMENT_MOMENT = "moment";
const char* NAME_ELEMENT_MOMENTABOUT = "momentabout";
const char* NAME_ELEMENT_MORPH = "morph";
const char* NAME_ELEMENT_MOTION = "motion";
const char* NAME_ELEMENT_MULTISAMPLE_ENABLE = "multisample_enable";
const char* NAME_ELEMENT_NAME_ARRAY = "Name_array";
const char* NAME_ELEMENT_NATURALNUMBERS = "naturalnumbers";
const char* NAME_ELEMENT_NEQ = "neq";
const char* NAME_ELEMENT_NEWPARAM = "newparam";
const char* NAME_ELEMENT_NEWPARAM____CG_NEWPARAM_TYPE = "newparam____cg_newparam_type";
const char* NAME_ELEMENT_NEWPARAM____FORMULA_NEWPARAM_TYPE = "newparam____formula_newparam_type";
const char* NAME_ELEMENT_NEWPARAM____FX_COMMON_NEWPARAM_TYPE = "newparam____fx_common_newparam_type";
const char* NAME_ELEMENT_NEWPARAM____FX_NEWPARAM_TYPE = "newparam____fx_newparam_type";
const char* NAME_ELEMENT_NEWPARAM____GLES_NEWPARAM_TYPE = "newparam____gles_newparam_type";
const char* NAME_ELEMENT_NEWPARAM____GLSL_NEWPARAM_TYPE = "newparam____glsl_newparam_type";
const char* NAME_ELEMENT_NEWPARAM____KINEMATICS_NEWPARAM_TYPE = "newparam____kinematics_newparam_type";
const char* NAME_ELEMENT_NODE = "node";
const char* NAME_ELEMENT_NORMALIZE_ENABLE = "normalize_enable";
const char* NAME_ELEMENT_NOT = "not";
const char* NAME_ELEMENT_NOTANUMBER = "notanumber";
const char* NAME_ELEMENT_NOTIN = "notin";
const char* NAME_ELEMENT_NOTPRSUBSET = "notprsubset";
const char* NAME_ELEMENT_NOTSUBSET = "notsubset";
const char* NAME_ELEMENT_NURBS = "nurbs";
const char* NAME_ELEMENT_NURBS_SURFACE = "nurbs_surface";
const char* NAME_ELEMENT_NURBS_SURFACE_TYPE____CONTROL_VERTICES = "nurbs_surface_type____control_vertices";
const char* NAME_ELEMENT_NURBS_TYPE____CONTROL_VERTICES = "nurbs_type____control_vertices";
const char* NAME_ELEMENT_OPTICS = "optics";
const char* NAME_ELEMENT_OPTICS__TECHNIQUE_COMMON = "optics__technique_common";
const char* NAME_ELEMENT_OR = "or";
const char* NAME_ELEMENT_ORIENT = "orient";
const char* NAME_ELEMENT_ORIGIN = "origin";
const char* NAME_ELEMENT_ORIGIN____FLOAT3_TYPE = "origin____float3_type";
const char* NAME_ELEMENT_ORIGIN____ORIGIN_TYPE = "origin____origin_type";
const char* NAME_ELEMENT_ORTHOGRAPHIC = "orthographic";
const char* NAME_ELEMENT_OTHERWISE = "otherwise";
const char* NAME_ELEMENT_OUTERPRODUCT = "outerproduct";
const char* NAME_ELEMENT_P = "p";
const char* NAME_ELEMENT_PARABOLA = "parabola";
const char* NAME_ELEMENT_PARAM = "param";
const char* NAME_ELEMENT_PARAM____COMMON_PARAM_TYPE = "param____common_param_type";
const char* NAME_ELEMENT_PARAM____KINEMATICS_PARAM_TYPE = "param____kinematics_param_type";
const char* NAME_ELEMENT_PARAM____NCNAME = "param____NCName";
const char* NAME_ELEMENT_PARAM____PARAM_TYPE = "param____param_type";
const char* NAME_ELEMENT_PARTIALDIFF = "partialdiff";
const char* NAME_ELEMENT_PASS = "pass";
const char* NAME_ELEMENT_PASS____CG_PASS_TYPE = "pass____cg_pass_type";
const char* NAME_ELEMENT_PASS____GLES2_PASS_TYPE = "pass____gles2_pass_type";
const char* NAME_ELEMENT_PCURVES = "pcurves";
const char* NAME_ELEMENT_PERSPECTIVE = "perspective";
const char* NAME_ELEMENT_PH = "ph";
const char* NAME_ELEMENT_PHONG = "phong";
const char* NAME_ELEMENT_PHYSICS_MATERIAL = "physics_material";
const char* NAME_ELEMENT_PHYSICS_MATERIAL_TYPE____TECHNIQUE_COMMON = "physics_material_type____technique_common";
const char* NAME_ELEMENT_PHYSICS_MODEL = "physics_model";
const char* NAME_ELEMENT_PHYSICS_SCENE = "physics_scene";
const char* NAME_ELEMENT_PHYSICS_SCENE_TYPE____TECHNIQUE_COMMON = "physics_scene_type____technique_common";
const char* NAME_ELEMENT_PI = "pi";
const char* NAME_ELEMENT_PIECE = "piece";
const char* NAME_ELEMENT_PIECEWISE = "piecewise";
const char* NAME_ELEMENT_PLANE = "plane";
const char* NAME_ELEMENT_PLUS = "plus";
const char* NAME_ELEMENT_POINT = "point";
const char* NAME_ELEMENT_POINT_DISTANCE_ATTENUATION = "point_distance_attenuation";
const char* NAME_ELEMENT_POINT_FADE_THRESHOLD_SIZE = "point_fade_threshold_size";
const char* NAME_ELEMENT_POINT_SIZE = "point_size";
const char* NAME_ELEMENT_POINT_SIZE_ENABLE = "point_size_enable";
const char* NAME_ELEMENT_POINT_SIZE_MAX = "point_size_max";
const char* NAME_ELEMENT_POINT_SIZE_MIN = "point_size_min";
const char* NAME_ELEMENT_POINT_SMOOTH_ENABLE = "point_smooth_enable";
const char* NAME_ELEMENT_POLYGONS = "polygons";
const char* NAME_ELEMENT_POLYGON_MODE = "polygon_mode";
const char* NAME_ELEMENT_POLYGON_MODE__FACE = "polygon_mode__face";
const char* NAME_ELEMENT_POLYGON_MODE__MODE = "polygon_mode__mode";
const char* NAME_ELEMENT_POLYGON_OFFSET = "polygon_offset";
const char* NAME_ELEMENT_POLYGON_OFFSET_FILL_ENABLE = "polygon_offset_fill_enable";
const char* NAME_ELEMENT_POLYGON_OFFSET_LINE_ENABLE = "polygon_offset_line_enable";
const char* NAME_ELEMENT_POLYGON_OFFSET_POINT_ENABLE = "polygon_offset_point_enable";
const char* NAME_ELEMENT_POLYGON_SMOOTH_ENABLE = "polygon_smooth_enable";
const char* NAME_ELEMENT_POLYGON_STIPPLE_ENABLE = "polygon_stipple_enable";
const char* NAME_ELEMENT_POLYLIST = "polylist";
const char* NAME_ELEMENT_POWER = "power";
const char* NAME_ELEMENT_PRIMES = "primes";
const char* NAME_ELEMENT_PRISMATIC = "prismatic";
const char* NAME_ELEMENT_PRODUCT = "product";
const char* NAME_ELEMENT_PROFILE_BRIDGE = "profile_BRIDGE";
const char* NAME_ELEMENT_PROFILE_CG = "profile_CG";
const char* NAME_ELEMENT_PROFILE_CG_TYPE____TECHNIQUE = "profile_cg_type____technique";
const char* NAME_ELEMENT_PROFILE_CG__TECHNIQUE__PASS__PROGRAM__SHADER = "profile_CG__technique__pass__program__shader";
const char* NAME_ELEMENT_PROFILE_CG__TECHNIQUE__PASS__PROGRAM__SHADER__BIND_UNIFORM = "profile_CG__technique__pass__program__shader__bind_uniform";
const char* NAME_ELEMENT_PROFILE_CG__TECHNIQUE__PASS__PROGRAM__SHADER__BIND_UNIFORM__PARAM = "profile_CG__technique__pass__program__shader__bind_uniform__param";
const char* NAME_ELEMENT_PROFILE_CG__TECHNIQUE__PASS__PROGRAM__SHADER__SOURCES = "profile_CG__technique__pass__program__shader__sources";
const char* NAME_ELEMENT_PROFILE_COMMON = "profile_COMMON";
const char* NAME_ELEMENT_PROFILE_COMMON_TYPE____TECHNIQUE = "profile_common_type____technique";
const char* NAME_ELEMENT_PROFILE_COMMON__TECHNIQUE__CONSTANT = "profile_COMMON__technique__constant";
const char* NAME_ELEMENT_PROFILE_GLES = "profile_GLES";
const char* NAME_ELEMENT_PROFILE_GLES2 = "profile_GLES2";
const char* NAME_ELEMENT_PROFILE_GLES2_TYPE____NEWPARAM = "profile_gles2_type____newparam";
const char* NAME_ELEMENT_PROFILE_GLES2_TYPE____TECHNIQUE = "profile_gles2_type____technique";
const char* NAME_ELEMENT_PROFILE_GLES2__NEWPARAM__USERTYPE = "profile_GLES2__newparam__usertype";
const char* NAME_ELEMENT_PROFILE_GLES2__NEWPARAM__USERTYPE__SETPARAM = "profile_GLES2__newparam__usertype__setparam";
const char* NAME_ELEMENT_PROFILE_GLES2__NEWPARAM__USERTYPE__SETPARAM__ARRAY = "profile_GLES2__newparam__usertype__setparam__array";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__PROGRAM__BIND_UNIFORM__PARAM = "profile_GLES2__technique__pass__program__bind_uniform__param";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_COLOR = "profile_GLES2__technique__pass__states__blend_color";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_ENABLE = "profile_GLES2__technique__pass__states__blend_enable";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_EQUATION = "profile_GLES2__technique__pass__states__blend_equation";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_EQUATION_SEPARATE = "profile_GLES2__technique__pass__states__blend_equation_separate";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_EQUATION_SEPARATE__ALPHA = "profile_GLES2__technique__pass__states__blend_equation_separate__alpha";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_EQUATION_SEPARATE__RGB = "profile_GLES2__technique__pass__states__blend_equation_separate__rgb";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_FUNC = "profile_GLES2__technique__pass__states__blend_func";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE = "profile_GLES2__technique__pass__states__blend_func_separate";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE__DEST_ALPHA = "profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE__DEST_RGB = "profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE__SRC_ALPHA = "profile_GLES2__technique__pass__states__blend_func_separate__src_alpha";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE__SRC_RGB = "profile_GLES2__technique__pass__states__blend_func_separate__src_rgb";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_FUNC__DEST = "profile_GLES2__technique__pass__states__blend_func__dest";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__BLEND_FUNC__SRC = "profile_GLES2__technique__pass__states__blend_func__src";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__COLOR_MASK = "profile_GLES2__technique__pass__states__color_mask";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__CULL_FACE = "profile_GLES2__technique__pass__states__cull_face";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__CULL_FACE_ENABLE = "profile_GLES2__technique__pass__states__cull_face_enable";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__DEPTH_FUNC = "profile_GLES2__technique__pass__states__depth_func";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__DEPTH_MASK = "profile_GLES2__technique__pass__states__depth_mask";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__DEPTH_RANGE = "profile_GLES2__technique__pass__states__depth_range";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__DEPTH_TEST_ENABLE = "profile_GLES2__technique__pass__states__depth_test_enable";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__DITHER_ENABLE = "profile_GLES2__technique__pass__states__dither_enable";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__FRONT_FACE = "profile_GLES2__technique__pass__states__front_face";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__LINE_WIDTH = "profile_GLES2__technique__pass__states__line_width";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__POINT_SIZE = "profile_GLES2__technique__pass__states__point_size";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__POLYGON_OFFSET = "profile_GLES2__technique__pass__states__polygon_offset";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__POLYGON_OFFSET_FILL_ENABLE = "profile_GLES2__technique__pass__states__polygon_offset_fill_enable";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__SAMPLE_ALPHA_TO_COVERAGE_ENABLE = "profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__SAMPLE_COVERAGE_ENABLE = "profile_GLES2__technique__pass__states__sample_coverage_enable";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__SCISSOR = "profile_GLES2__technique__pass__states__scissor";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__SCISSOR_TEST_ENABLE = "profile_GLES2__technique__pass__states__scissor_test_enable";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC = "profile_GLES2__technique__pass__states__stencil_func";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE = "profile_GLES2__technique__pass__states__stencil_func_separate";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE__BACK = "profile_GLES2__technique__pass__states__stencil_func_separate__back";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE__FRONT = "profile_GLES2__technique__pass__states__stencil_func_separate__front";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE__MASK = "profile_GLES2__technique__pass__states__stencil_func_separate__mask";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE__REF = "profile_GLES2__technique__pass__states__stencil_func_separate__ref";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC__FUNC = "profile_GLES2__technique__pass__states__stencil_func__func";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC__MASK = "profile_GLES2__technique__pass__states__stencil_func__mask";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_FUNC__REF = "profile_GLES2__technique__pass__states__stencil_func__ref";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_MASK = "profile_GLES2__technique__pass__states__stencil_mask";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_MASK_SEPARATE = "profile_GLES2__technique__pass__states__stencil_mask_separate";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_MASK_SEPARATE__FACE = "profile_GLES2__technique__pass__states__stencil_mask_separate__face";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_MASK_SEPARATE__MASK = "profile_GLES2__technique__pass__states__stencil_mask_separate__mask";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP = "profile_GLES2__technique__pass__states__stencil_op";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE = "profile_GLES2__technique__pass__states__stencil_op_separate";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE__FACE = "profile_GLES2__technique__pass__states__stencil_op_separate__face";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE__FAIL = "profile_GLES2__technique__pass__states__stencil_op_separate__fail";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE__ZFAIL = "profile_GLES2__technique__pass__states__stencil_op_separate__zfail";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE__ZPASS = "profile_GLES2__technique__pass__states__stencil_op_separate__zpass";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP__FAIL = "profile_GLES2__technique__pass__states__stencil_op__fail";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP__ZFAIL = "profile_GLES2__technique__pass__states__stencil_op__zfail";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_OP__ZPASS = "profile_GLES2__technique__pass__states__stencil_op__zpass";
const char* NAME_ELEMENT_PROFILE_GLES2__TECHNIQUE__PASS__STATES__STENCIL_TEST_ENABLE = "profile_GLES2__technique__pass__states__stencil_test_enable";
const char* NAME_ELEMENT_PROFILE_GLES_TYPE____TECHNIQUE = "profile_gles_type____technique";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS = "profile_GLES__technique__pass";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__EVALUATE = "profile_GLES__technique__pass__evaluate";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES = "profile_GLES__technique__pass__states";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__ALPHA_FUNC = "profile_GLES__technique__pass__states__alpha_func";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__ALPHA_FUNC__FUNC = "profile_GLES__technique__pass__states__alpha_func__func";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__ALPHA_FUNC__VALUE = "profile_GLES__technique__pass__states__alpha_func__value";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__ALPHA_TEST_ENABLE = "profile_GLES__technique__pass__states__alpha_test_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__BLEND_ENABLE = "profile_GLES__technique__pass__states__blend_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__BLEND_FUNC = "profile_GLES__technique__pass__states__blend_func";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__BLEND_FUNC__DEST = "profile_GLES__technique__pass__states__blend_func__dest";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__BLEND_FUNC__SRC = "profile_GLES__technique__pass__states__blend_func__src";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__CLIP_PLANE = "profile_GLES__technique__pass__states__clip_plane";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__CLIP_PLANE_ENABLE = "profile_GLES__technique__pass__states__clip_plane_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__COLOR_LOGIC_OP_ENABLE = "profile_GLES__technique__pass__states__color_logic_op_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__COLOR_MASK = "profile_GLES__technique__pass__states__color_mask";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__COLOR_MATERIAL_ENABLE = "profile_GLES__technique__pass__states__color_material_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__CULL_FACE = "profile_GLES__technique__pass__states__cull_face";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__CULL_FACE_ENABLE = "profile_GLES__technique__pass__states__cull_face_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__DEPTH_FUNC = "profile_GLES__technique__pass__states__depth_func";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__DEPTH_MASK = "profile_GLES__technique__pass__states__depth_mask";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__DEPTH_RANGE = "profile_GLES__technique__pass__states__depth_range";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__DEPTH_TEST_ENABLE = "profile_GLES__technique__pass__states__depth_test_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__DITHER_ENABLE = "profile_GLES__technique__pass__states__dither_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__FOG_COLOR = "profile_GLES__technique__pass__states__fog_color";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__FOG_DENSITY = "profile_GLES__technique__pass__states__fog_density";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__FOG_ENABLE = "profile_GLES__technique__pass__states__fog_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__FOG_END = "profile_GLES__technique__pass__states__fog_end";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__FOG_MODE = "profile_GLES__technique__pass__states__fog_mode";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__FOG_START = "profile_GLES__technique__pass__states__fog_start";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__FRONT_FACE = "profile_GLES__technique__pass__states__front_face";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHTING_ENABLE = "profile_GLES__technique__pass__states__lighting_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_AMBIENT = "profile_GLES__technique__pass__states__light_ambient";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_CONSTANT_ATTENUATION = "profile_GLES__technique__pass__states__light_constant_attenuation";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_DIFFUSE = "profile_GLES__technique__pass__states__light_diffuse";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_ENABLE = "profile_GLES__technique__pass__states__light_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_LINEAR_ATTENUATION = "profile_GLES__technique__pass__states__light_linear_attenuation";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_MODEL_AMBIENT = "profile_GLES__technique__pass__states__light_model_ambient";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_MODEL_TWO_SIDE_ENABLE = "profile_GLES__technique__pass__states__light_model_two_side_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_POSITION = "profile_GLES__technique__pass__states__light_position";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_QUADRATIC_ATTENUATION = "profile_GLES__technique__pass__states__light_quadratic_attenuation";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_SPECULAR = "profile_GLES__technique__pass__states__light_specular";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_SPOT_CUTOFF = "profile_GLES__technique__pass__states__light_spot_cutoff";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_SPOT_DIRECTION = "profile_GLES__technique__pass__states__light_spot_direction";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LIGHT_SPOT_EXPONENT = "profile_GLES__technique__pass__states__light_spot_exponent";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LINE_SMOOTH_ENABLE = "profile_GLES__technique__pass__states__line_smooth_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LINE_WIDTH = "profile_GLES__technique__pass__states__line_width";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__LOGIC_OP = "profile_GLES__technique__pass__states__logic_op";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__MATERIAL_AMBIENT = "profile_GLES__technique__pass__states__material_ambient";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__MATERIAL_DIFFUSE = "profile_GLES__technique__pass__states__material_diffuse";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__MATERIAL_EMISSION = "profile_GLES__technique__pass__states__material_emission";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__MATERIAL_SHININESS = "profile_GLES__technique__pass__states__material_shininess";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__MATERIAL_SPECULAR = "profile_GLES__technique__pass__states__material_specular";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__MODEL_VIEW_MATRIX = "profile_GLES__technique__pass__states__model_view_matrix";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__MULTISAMPLE_ENABLE = "profile_GLES__technique__pass__states__multisample_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__NORMALIZE_ENABLE = "profile_GLES__technique__pass__states__normalize_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__POINT_DISTANCE_ATTENUATION = "profile_GLES__technique__pass__states__point_distance_attenuation";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__POINT_FADE_THRESHOLD_SIZE = "profile_GLES__technique__pass__states__point_fade_threshold_size";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__POINT_SIZE = "profile_GLES__technique__pass__states__point_size";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__POINT_SIZE_MAX = "profile_GLES__technique__pass__states__point_size_max";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__POINT_SIZE_MIN = "profile_GLES__technique__pass__states__point_size_min";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__POINT_SMOOTH_ENABLE = "profile_GLES__technique__pass__states__point_smooth_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__POLYGON_OFFSET = "profile_GLES__technique__pass__states__polygon_offset";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__POLYGON_OFFSET_FILL_ENABLE = "profile_GLES__technique__pass__states__polygon_offset_fill_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__PROJECTION_MATRIX = "profile_GLES__technique__pass__states__projection_matrix";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__RESCALE_NORMAL_ENABLE = "profile_GLES__technique__pass__states__rescale_normal_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__SAMPLE_ALPHA_TO_COVERAGE_ENABLE = "profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__SAMPLE_ALPHA_TO_ONE_ENABLE = "profile_GLES__technique__pass__states__sample_alpha_to_one_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__SAMPLE_COVERAGE_ENABLE = "profile_GLES__technique__pass__states__sample_coverage_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__SCISSOR = "profile_GLES__technique__pass__states__scissor";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__SCISSOR_TEST_ENABLE = "profile_GLES__technique__pass__states__scissor_test_enable";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__SHADE_MODEL = "profile_GLES__technique__pass__states__shade_model";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_FUNC = "profile_GLES__technique__pass__states__stencil_func";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_FUNC__FUNC = "profile_GLES__technique__pass__states__stencil_func__func";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_FUNC__MASK = "profile_GLES__technique__pass__states__stencil_func__mask";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_FUNC__REF = "profile_GLES__technique__pass__states__stencil_func__ref";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_MASK = "profile_GLES__technique__pass__states__stencil_mask";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_OP = "profile_GLES__technique__pass__states__stencil_op";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_OP__FAIL = "profile_GLES__technique__pass__states__stencil_op__fail";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_OP__ZFAIL = "profile_GLES__technique__pass__states__stencil_op__zfail";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_OP__ZPASS = "profile_GLES__technique__pass__states__stencil_op__zpass";
const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE__PASS__STATES__STENCIL_TEST_ENABLE = "profile_GLES__technique__pass__states__stencil_test_enable";
const char* NAME_ELEMENT_PROFILE_GLSL = "profile_GLSL";
const char* NAME_ELEMENT_PROFILE_GLSL_TYPE____TECHNIQUE = "profile_glsl_type____technique";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS = "profile_GLSL__technique__pass";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__EVALUATE = "profile_GLSL__technique__pass__evaluate";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__PROGRAM__BIND_UNIFORM__PARAM = "profile_GLSL__technique__pass__program__bind_uniform__param";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES = "profile_GLSL__technique__pass__states";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__ALPHA_FUNC = "profile_GLSL__technique__pass__states__alpha_func";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__ALPHA_FUNC__FUNC = "profile_GLSL__technique__pass__states__alpha_func__func";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__ALPHA_FUNC__VALUE = "profile_GLSL__technique__pass__states__alpha_func__value";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__ALPHA_TEST_ENABLE = "profile_GLSL__technique__pass__states__alpha_test_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_COLOR = "profile_GLSL__technique__pass__states__blend_color";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_ENABLE = "profile_GLSL__technique__pass__states__blend_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_EQUATION = "profile_GLSL__technique__pass__states__blend_equation";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_EQUATION_SEPARATE = "profile_GLSL__technique__pass__states__blend_equation_separate";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_EQUATION_SEPARATE__ALPHA = "profile_GLSL__technique__pass__states__blend_equation_separate__alpha";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_EQUATION_SEPARATE__RGB = "profile_GLSL__technique__pass__states__blend_equation_separate__rgb";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_FUNC = "profile_GLSL__technique__pass__states__blend_func";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE = "profile_GLSL__technique__pass__states__blend_func_separate";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE__DEST_ALPHA = "profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE__DEST_RGB = "profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE__SRC_ALPHA = "profile_GLSL__technique__pass__states__blend_func_separate__src_alpha";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_FUNC_SEPARATE__SRC_RGB = "profile_GLSL__technique__pass__states__blend_func_separate__src_rgb";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_FUNC__DEST = "profile_GLSL__technique__pass__states__blend_func__dest";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__BLEND_FUNC__SRC = "profile_GLSL__technique__pass__states__blend_func__src";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__CLIP_PLANE = "profile_GLSL__technique__pass__states__clip_plane";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__CLIP_PLANE_ENABLE = "profile_GLSL__technique__pass__states__clip_plane_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__COLOR_LOGIC_OP_ENABLE = "profile_GLSL__technique__pass__states__color_logic_op_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__COLOR_MASK = "profile_GLSL__technique__pass__states__color_mask";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__COLOR_MATERIAL_ENABLE = "profile_GLSL__technique__pass__states__color_material_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__CULL_FACE = "profile_GLSL__technique__pass__states__cull_face";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__CULL_FACE_ENABLE = "profile_GLSL__technique__pass__states__cull_face_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__DEPTH_FUNC = "profile_GLSL__technique__pass__states__depth_func";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__DEPTH_MASK = "profile_GLSL__technique__pass__states__depth_mask";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__DEPTH_RANGE = "profile_GLSL__technique__pass__states__depth_range";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__DEPTH_TEST_ENABLE = "profile_GLSL__technique__pass__states__depth_test_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__DITHER_ENABLE = "profile_GLSL__technique__pass__states__dither_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__FOG_COLOR = "profile_GLSL__technique__pass__states__fog_color";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__FOG_DENSITY = "profile_GLSL__technique__pass__states__fog_density";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__FOG_ENABLE = "profile_GLSL__technique__pass__states__fog_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__FOG_END = "profile_GLSL__technique__pass__states__fog_end";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__FOG_MODE = "profile_GLSL__technique__pass__states__fog_mode";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__FOG_START = "profile_GLSL__technique__pass__states__fog_start";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__FRONT_FACE = "profile_GLSL__technique__pass__states__front_face";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHTING_ENABLE = "profile_GLSL__technique__pass__states__lighting_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_AMBIENT = "profile_GLSL__technique__pass__states__light_ambient";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_CONSTANT_ATTENUATION = "profile_GLSL__technique__pass__states__light_constant_attenuation";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_DIFFUSE = "profile_GLSL__technique__pass__states__light_diffuse";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_ENABLE = "profile_GLSL__technique__pass__states__light_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_LINEAR_ATTENUATION = "profile_GLSL__technique__pass__states__light_linear_attenuation";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_MODEL_AMBIENT = "profile_GLSL__technique__pass__states__light_model_ambient";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_MODEL_TWO_SIDE_ENABLE = "profile_GLSL__technique__pass__states__light_model_two_side_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_POSITION = "profile_GLSL__technique__pass__states__light_position";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_QUADRATIC_ATTENUATION = "profile_GLSL__technique__pass__states__light_quadratic_attenuation";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_SPECULAR = "profile_GLSL__technique__pass__states__light_specular";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_SPOT_CUTOFF = "profile_GLSL__technique__pass__states__light_spot_cutoff";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_SPOT_DIRECTION = "profile_GLSL__technique__pass__states__light_spot_direction";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LIGHT_SPOT_EXPONENT = "profile_GLSL__technique__pass__states__light_spot_exponent";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LINE_SMOOTH_ENABLE = "profile_GLSL__technique__pass__states__line_smooth_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LINE_WIDTH = "profile_GLSL__technique__pass__states__line_width";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__LOGIC_OP = "profile_GLSL__technique__pass__states__logic_op";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__MATERIAL_AMBIENT = "profile_GLSL__technique__pass__states__material_ambient";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__MATERIAL_DIFFUSE = "profile_GLSL__technique__pass__states__material_diffuse";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__MATERIAL_EMISSION = "profile_GLSL__technique__pass__states__material_emission";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__MATERIAL_SHININESS = "profile_GLSL__technique__pass__states__material_shininess";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__MATERIAL_SPECULAR = "profile_GLSL__technique__pass__states__material_specular";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__MODEL_VIEW_MATRIX = "profile_GLSL__technique__pass__states__model_view_matrix";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__MULTISAMPLE_ENABLE = "profile_GLSL__technique__pass__states__multisample_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__NORMALIZE_ENABLE = "profile_GLSL__technique__pass__states__normalize_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__POINT_DISTANCE_ATTENUATION = "profile_GLSL__technique__pass__states__point_distance_attenuation";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__POINT_FADE_THRESHOLD_SIZE = "profile_GLSL__technique__pass__states__point_fade_threshold_size";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__POINT_SIZE = "profile_GLSL__technique__pass__states__point_size";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__POINT_SIZE_MAX = "profile_GLSL__technique__pass__states__point_size_max";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__POINT_SIZE_MIN = "profile_GLSL__technique__pass__states__point_size_min";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__POINT_SMOOTH_ENABLE = "profile_GLSL__technique__pass__states__point_smooth_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__POLYGON_OFFSET = "profile_GLSL__technique__pass__states__polygon_offset";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__POLYGON_OFFSET_FILL_ENABLE = "profile_GLSL__technique__pass__states__polygon_offset_fill_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__PROJECTION_MATRIX = "profile_GLSL__technique__pass__states__projection_matrix";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__RESCALE_NORMAL_ENABLE = "profile_GLSL__technique__pass__states__rescale_normal_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__SAMPLE_ALPHA_TO_COVERAGE_ENABLE = "profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__SAMPLE_ALPHA_TO_ONE_ENABLE = "profile_GLSL__technique__pass__states__sample_alpha_to_one_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__SAMPLE_COVERAGE_ENABLE = "profile_GLSL__technique__pass__states__sample_coverage_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__SCISSOR = "profile_GLSL__technique__pass__states__scissor";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__SCISSOR_TEST_ENABLE = "profile_GLSL__technique__pass__states__scissor_test_enable";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__SHADE_MODEL = "profile_GLSL__technique__pass__states__shade_model";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC = "profile_GLSL__technique__pass__states__stencil_func";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE = "profile_GLSL__technique__pass__states__stencil_func_separate";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE__BACK = "profile_GLSL__technique__pass__states__stencil_func_separate__back";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE__FRONT = "profile_GLSL__technique__pass__states__stencil_func_separate__front";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE__MASK = "profile_GLSL__technique__pass__states__stencil_func_separate__mask";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC_SEPARATE__REF = "profile_GLSL__technique__pass__states__stencil_func_separate__ref";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC__FUNC = "profile_GLSL__technique__pass__states__stencil_func__func";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC__MASK = "profile_GLSL__technique__pass__states__stencil_func__mask";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_FUNC__REF = "profile_GLSL__technique__pass__states__stencil_func__ref";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_MASK = "profile_GLSL__technique__pass__states__stencil_mask";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_MASK_SEPARATE = "profile_GLSL__technique__pass__states__stencil_mask_separate";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_MASK_SEPARATE__FACE = "profile_GLSL__technique__pass__states__stencil_mask_separate__face";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_MASK_SEPARATE__MASK = "profile_GLSL__technique__pass__states__stencil_mask_separate__mask";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP = "profile_GLSL__technique__pass__states__stencil_op";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE = "profile_GLSL__technique__pass__states__stencil_op_separate";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE__FACE = "profile_GLSL__technique__pass__states__stencil_op_separate__face";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE__FAIL = "profile_GLSL__technique__pass__states__stencil_op_separate__fail";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE__ZFAIL = "profile_GLSL__technique__pass__states__stencil_op_separate__zfail";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP_SEPARATE__ZPASS = "profile_GLSL__technique__pass__states__stencil_op_separate__zpass";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP__FAIL = "profile_GLSL__technique__pass__states__stencil_op__fail";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP__ZFAIL = "profile_GLSL__technique__pass__states__stencil_op__zfail";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_OP__ZPASS = "profile_GLSL__technique__pass__states__stencil_op__zpass";
const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE__PASS__STATES__STENCIL_TEST_ENABLE = "profile_GLSL__technique__pass__states__stencil_test_enable";
const char* NAME_ELEMENT_PROGRAM = "program";
const char* NAME_ELEMENT_PROGRAM____GLES2_PROGRAM_TYPE = "program____gles2_program_type";
const char* NAME_ELEMENT_PROGRAM____GLSL_PROGRAM_TYPE = "program____glsl_program_type";
const char* NAME_ELEMENT_PROJECTION_MATRIX = "projection_matrix";
const char* NAME_ELEMENT_PRSUBSET = "prsubset";
const char* NAME_ELEMENT_QUADRATIC_ATTENUATION = "quadratic_attenuation";
const char* NAME_ELEMENT_QUOTIENT = "quotient";
const char* NAME_ELEMENT_RADIUS = "radius";
const char* NAME_ELEMENT_RADIUS____FLOAT2_TYPE = "radius____float2_type";
const char* NAME_ELEMENT_RADIUS____FLOAT3_TYPE = "radius____float3_type";
const char* NAME_ELEMENT_RADIUS____FLOAT_TYPE = "radius____float_type";
const char* NAME_ELEMENT_RATIONALS = "rationals";
const char* NAME_ELEMENT_REAL = "real";
const char* NAME_ELEMENT_REALS = "reals";
const char* NAME_ELEMENT_REF = NAME_ATTRIBUTE_REF;
const char* NAME_ELEMENT_REFLECTIVE = "reflective";
const char* NAME_ELEMENT_REFLECTIVITY = "reflectivity";
const char* NAME_ELEMENT_REF_ATTACHMENT = "ref_attachment";
const char* NAME_ELEMENT_REF____ANYURI = "ref____anyURI";
const char* NAME_ELEMENT_REM = "rem";
const char* NAME_ELEMENT_RENDER = "render";
const char* NAME_ELEMENT_RENDERABLE = "renderable";
const char* NAME_ELEMENT_RENDER__INSTANCE_MATERIAL = "render__instance_material";
const char* NAME_ELEMENT_RENDER__INSTANCE_MATERIAL__BIND = "render__instance_material__bind";
const char* NAME_ELEMENT_RESCALE_NORMAL_ENABLE = "rescale_normal_enable";
const char* NAME_ELEMENT_RESTITUTION = "restitution";
const char* NAME_ELEMENT_REVISION = "revision";
const char* NAME_ELEMENT_REVOLUTE = "revolute";
const char* NAME_ELEMENT_RGB = "rgb";
const char* NAME_ELEMENT_RIGID_BODY = "rigid_body";
const char* NAME_ELEMENT_RIGID_BODY_TYPE____TECHNIQUE_COMMON = "rigid_body_type____technique_common";
const char* NAME_ELEMENT_RIGID_BODY__TECHNIQUE_COMMON__DYNAMIC = "rigid_body__technique_common__dynamic";
const char* NAME_ELEMENT_RIGID_BODY__TECHNIQUE_COMMON__MASS_FRAME = "rigid_body__technique_common__mass_frame";
const char* NAME_ELEMENT_RIGID_BODY__TECHNIQUE_COMMON__SHAPE = "rigid_body__technique_common__shape";
const char* NAME_ELEMENT_RIGID_BODY__TECHNIQUE_COMMON__SHAPE__HOLLOW = "rigid_body__technique_common__shape__hollow";
const char* NAME_ELEMENT_RIGID_CONSTRAINT = "rigid_constraint";
const char* NAME_ELEMENT_RIGID_CONSTRAINT_TYPE____TECHNIQUE_COMMON = "rigid_constraint_type____technique_common";
const char* NAME_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE_COMMON__LIMITS = "rigid_constraint__technique_common__limits";
const char* NAME_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE_COMMON__LIMITS__LINEAR = "rigid_constraint__technique_common__limits__linear";
const char* NAME_ELEMENT_ROOT = "root";
const char* NAME_ELEMENT_ROTATE = "rotate";
const char* NAME_ELEMENT_SAMPLER = "sampler";
const char* NAME_ELEMENT_SAMPLER1D = "sampler1D";
const char* NAME_ELEMENT_SAMPLER2D = "sampler2D";
const char* NAME_ELEMENT_SAMPLER2D____FX_SAMPLER2D_TYPE = "sampler2D____fx_sampler2D_type";
const char* NAME_ELEMENT_SAMPLER2D____GLES_SAMPLER_TYPE = "sampler2D____gles_sampler_type";
const char* NAME_ELEMENT_SAMPLER3D = "sampler3D";
const char* NAME_ELEMENT_SAMPLERCUBE = "samplerCUBE";
const char* NAME_ELEMENT_SAMPLERDEPTH = "samplerDEPTH";
const char* NAME_ELEMENT_SAMPLERRECT = "samplerRECT";
const char* NAME_ELEMENT_SAMPLER_IMAGE = "sampler_image";
const char* NAME_ELEMENT_SAMPLER_STATES = "sampler_states";
const char* NAME_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE = "sample_alpha_to_coverage_enable";
const char* NAME_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE = "sample_alpha_to_one_enable";
const char* NAME_ELEMENT_SAMPLE_COVERAGE = "sample_coverage";
const char* NAME_ELEMENT_SAMPLE_COVERAGE_ENABLE = "sample_coverage_enable";
const char* NAME_ELEMENT_SAMPLE_COVERAGE__VALUE = "sample_coverage__value";
const char* NAME_ELEMENT_SCALARPRODUCT = "scalarproduct";
const char* NAME_ELEMENT_SCALE = NAME_ATTRIBUTE_SCALE;
const char* NAME_ELEMENT_SCENE = "scene";
const char* NAME_ELEMENT_SCISSOR = "scissor";
const char* NAME_ELEMENT_SCISSOR_TEST_ENABLE = "scissor_test_enable";
const char* NAME_ELEMENT_SDEV = "sdev";
const char* NAME_ELEMENT_SEC = "sec";
const char* NAME_ELEMENT_SECH = "sech";
const char* NAME_ELEMENT_SELECTOR = "selector";
const char* NAME_ELEMENT_SEMANTIC = NAME_ATTRIBUTE_SEMANTIC;
const char* NAME_ELEMENT_SEMANTICS = "semantics";
const char* NAME_ELEMENT_SEMANTIC____NCNAME = "semantic____NCName";
const char* NAME_ELEMENT_SEMANTIC____TOKEN = "semantic____token";
const char* NAME_ELEMENT_SEP = "sep";
const char* NAME_ELEMENT_SET = NAME_ATTRIBUTE_SET;
const char* NAME_ELEMENT_SETDIFF = "setdiff";
const char* NAME_ELEMENT_SETPARAM = "setparam";
const char* NAME_ELEMENT_SETPARAM____CG_SETPARAM_TYPE = "setparam____cg_setparam_type";
const char* NAME_ELEMENT_SETPARAM____FORMULA_SETPARAM_TYPE = "setparam____formula_setparam_type";
const char* NAME_ELEMENT_SETPARAM____KINEMATICS_SETPARAM_TYPE = "setparam____kinematics_setparam_type";
const char* NAME_ELEMENT_SHADER = "shader";
const char* NAME_ELEMENT_SHADER____GLES2_SHADER_TYPE = "shader____gles2_shader_type";
const char* NAME_ELEMENT_SHADER____GLSL_SHADER_TYPE = "shader____glsl_shader_type";
const char* NAME_ELEMENT_SHADE_MODEL = "shade_model";
const char* NAME_ELEMENT_SHAPE = "shape";
const char* NAME_ELEMENT_SHELLS = "shells";
const char* NAME_ELEMENT_SHININESS = "shininess";
const char* NAME_ELEMENT_SIDREF = "SIDREF";
const char* NAME_ELEMENT_SIDREF_ARRAY = "SIDREF_array";
const char* NAME_ELEMENT_SIN = "sin";
const char* NAME_ELEMENT_SINH = "sinh";
const char* NAME_ELEMENT_SIZE = "size";
const char* NAME_ELEMENT_SIZE_EXACT = "size_exact";
const char* NAME_ELEMENT_SIZE_RATIO = "size_ratio";
const char* NAME_ELEMENT_SKELETON = "skeleton";
const char* NAME_ELEMENT_SKEW = "skew";
const char* NAME_ELEMENT_SKIN = "skin";
const char* NAME_ELEMENT_SOLIDS = "solids";
const char* NAME_ELEMENT_SOURCE = "source";
const char* NAME_ELEMENT_SOURCES = "sources";
const char* NAME_ELEMENT_SOURCES____FX_SOURCES_TYPE = "sources____fx_sources_type";
const char* NAME_ELEMENT_SOURCE_DATA = "source_data";
const char* NAME_ELEMENT_SOURCE_TYPE____TECHNIQUE_COMMON = "source_type____technique_common";
const char* NAME_ELEMENT_SPECULAR = "specular";
const char* NAME_ELEMENT_SPEED = "speed";
const char* NAME_ELEMENT_SPEED____COMMON_FLOAT2_OR_PARAM_TYPE = "speed____common_float2_or_param_type";
const char* NAME_ELEMENT_SPEED____COMMON_FLOAT_OR_PARAM_TYPE = "speed____common_float_or_param_type";
const char* NAME_ELEMENT_SPHERE = "sphere";
const char* NAME_ELEMENT_SPLINE = "spline";
const char* NAME_ELEMENT_SPLINE_TYPE____CONTROL_VERTICES = "spline_type____control_vertices";
const char* NAME_ELEMENT_SPOT = "spot";
const char* NAME_ELEMENT_SPRING = "spring";
const char* NAME_ELEMENT_SPRING__LINEAR = "spring__linear";
const char* NAME_ELEMENT_SRC = "src";
const char* NAME_ELEMENT_SRC_ALPHA = "src_alpha";
const char* NAME_ELEMENT_SRC_RGB = "src_rgb";
const char* NAME_ELEMENT_STATES = "states";
const char* NAME_ELEMENT_STATIC_FRICTION = "static_friction";
const char* NAME_ELEMENT_STENCIL_CLEAR = "stencil_clear";
const char* NAME_ELEMENT_STENCIL_FUNC = "stencil_func";
const char* NAME_ELEMENT_STENCIL_FUNC_SEPARATE = "stencil_func_separate";
const char* NAME_ELEMENT_STENCIL_MASK = "stencil_mask";
const char* NAME_ELEMENT_STENCIL_MASK_SEPARATE = "stencil_mask_separate";
const char* NAME_ELEMENT_STENCIL_OP = "stencil_op";
const char* NAME_ELEMENT_STENCIL_OP_SEPARATE = "stencil_op_separate";
const char* NAME_ELEMENT_STENCIL_TARGET = "stencil_target";
const char* NAME_ELEMENT_STENCIL_TEST_ENABLE = "stencil_test_enable";
const char* NAME_ELEMENT_STIFFNESS = "stiffness";
const char* NAME_ELEMENT_STRING = "string";
const char* NAME_ELEMENT_SUBJECT = "subject";
const char* NAME_ELEMENT_SUBSET = "subset";
const char* NAME_ELEMENT_SUM = "sum";
const char* NAME_ELEMENT_SURFACE = "surface";
const char* NAME_ELEMENT_SURFACES = "surfaces";
const char* NAME_ELEMENT_SURFACE_CURVES = "surface_curves";
const char* NAME_ELEMENT_SURFACE_TYPE____CYLINDER = "surface_type____cylinder";
const char* NAME_ELEMENT_SWEPT_SURFACE = "swept_surface";
const char* NAME_ELEMENT_SWING_CONE_AND_TWIST = "swing_cone_and_twist";
const char* NAME_ELEMENT_TAN = "tan";
const char* NAME_ELEMENT_TANH = "tanh";
const char* NAME_ELEMENT_TARGET = NAME_ATTRIBUTE_TARGET;
const char* NAME_ELEMENT_TARGETS = "targets";
const char* NAME_ELEMENT_TARGET_VALUE = "target_value";
const char* NAME_ELEMENT_TECHNIQUE = "technique";
const char* NAME_ELEMENT_TECHNIQUE_COMMON = "technique_common";
const char* NAME_ELEMENT_TECHNIQUE_COMMON____FORMULA_TECHNIQUE_TYPE = "technique_common____formula_technique_type";
const char* NAME_ELEMENT_TECHNIQUE_COMMON____KINEMATICS_MODEL_TECHNIQUE_TYPE = "technique_common____kinematics_model_technique_type";
const char* NAME_ELEMENT_TECHNIQUE_COMMON____KINEMATICS_TECHNIQUE_TYPE = "technique_common____kinematics_technique_type";
const char* NAME_ELEMENT_TECHNIQUE_COMMON____MOTION_TECHNIQUE_TYPE = "technique_common____motion_technique_type";
const char* NAME_ELEMENT_TECHNIQUE_HINT = "technique_hint";
const char* NAME_ELEMENT_TECHNIQUE_OVERRIDE = "technique_override";
const char* NAME_ELEMENT_TECHNIQUE____TECHNIQUE_TYPE = "technique____technique_type";
const char* NAME_ELEMENT_TENDSTO = "tendsto";
const char* NAME_ELEMENT_TEXCOMBINER = "texcombiner";
const char* NAME_ELEMENT_TEXCOORD = NAME_ATTRIBUTE_TEXCOORD;
const char* NAME_ELEMENT_TEXENV = "texenv";
const char* NAME_ELEMENT_TEXTURE = "texture";
const char* NAME_ELEMENT_TEXTURE1D = "texture1D";
const char* NAME_ELEMENT_TEXTURE1D_ENABLE = "texture1D_enable";
const char* NAME_ELEMENT_TEXTURE2D = "texture2D";
const char* NAME_ELEMENT_TEXTURE2D_ENABLE = "texture2D_enable";
const char* NAME_ELEMENT_TEXTURE3D = "texture3D";
const char* NAME_ELEMENT_TEXTURE3D_ENABLE = "texture3D_enable";
const char* NAME_ELEMENT_TEXTURECUBE = "textureCUBE";
const char* NAME_ELEMENT_TEXTURECUBE_ENABLE = "textureCUBE_enable";
const char* NAME_ELEMENT_TEXTUREDEPTH = "textureDEPTH";
const char* NAME_ELEMENT_TEXTUREDEPTH_ENABLE = "textureDEPTH_enable";
const char* NAME_ELEMENT_TEXTURERECT = "textureRECT";
const char* NAME_ELEMENT_TEXTURERECT_ENABLE = "textureRECT_enable";
const char* NAME_ELEMENT_TEXTURE_ENV_COLOR = "texture_env_color";
const char* NAME_ELEMENT_TEXTURE_ENV_MODE = "texture_env_mode";
const char* NAME_ELEMENT_TEXTURE_PIPELINE = "texture_pipeline";
const char* NAME_ELEMENT_TIMES = "times";
const char* NAME_ELEMENT_TIME_STEP = "time_step";
const char* NAME_ELEMENT_TITLE = "title";
const char* NAME_ELEMENT_TOKEN_ARRAY = "token_array";
const char* NAME_ELEMENT_TORUS = "torus";
const char* NAME_ELEMENT_TRANSLATE = "translate";
const char* NAME_ELEMENT_TRANSPARENCY = "transparency";
const char* NAME_ELEMENT_TRANSPARENT = "transparent";
const char* NAME_ELEMENT_TRANSPOSE = "transpose";
const char* NAME_ELEMENT_TRIANGLES = "triangles";
const char* NAME_ELEMENT_TRIFANS = "trifans";
const char* NAME_ELEMENT_TRISTRIPS = "tristrips";
const char* NAME_ELEMENT_TRUE = "true";
const char* NAME_ELEMENT_UNION = "union";
const char* NAME_ELEMENT_UNIT = "unit";
const char* NAME_ELEMENT_UNNORMALIZED = "unnormalized";
const char* NAME_ELEMENT_UPLIMIT = "uplimit";
const char* NAME_ELEMENT_UP_AXIS = "up_axis";
const char* NAME_ELEMENT_USERTYPE = "usertype";
const char* NAME_ELEMENT_USERTYPE____CG_USER_TYPE = "usertype____cg_user_type";
const char* NAME_ELEMENT_V = "v";
const char* NAME_ELEMENT_VALUE = NAME_ATTRIBUTE_VALUE;
const char* NAME_ELEMENT_VALUE____COMMON_FLOAT_OR_PARAM_TYPE = "value____common_float_or_param_type";
const char* NAME_ELEMENT_VALUE____FX_SAMPLER1D_TYPE = "value____fx_sampler1D_type";
const char* NAME_ELEMENT_VALUE____FX_SAMPLER2D_TYPE = "value____fx_sampler2D_type";
const char* NAME_ELEMENT_VALUE____FX_SAMPLER3D_TYPE = "value____fx_sampler3D_type";
const char* NAME_ELEMENT_VALUE____FX_SAMPLERCUBE_TYPE = "value____fx_samplerCUBE_type";
const char* NAME_ELEMENT_VALUE____FX_SAMPLERDEPTH_TYPE = "value____fx_samplerDEPTH_type";
const char* NAME_ELEMENT_VALUE____FX_SAMPLERRECT_TYPE = "value____fx_samplerRECT_type";
const char* NAME_ELEMENT_VALUE____GLES_TEXTURE_PIPELINE_TYPE = "value____gles_texture_pipeline_type";
const char* NAME_ELEMENT_VARIANCE = "variance";
const char* NAME_ELEMENT_VCOUNT = "vcount";
const char* NAME_ELEMENT_VEC2 = "vec2";
const char* NAME_ELEMENT_VEC3 = "vec3";
const char* NAME_ELEMENT_VEC4 = "vec4";
const char* NAME_ELEMENT_VECTOR = "vector";
const char* NAME_ELEMENT_VECTORPRODUCT = "vectorproduct";
const char* NAME_ELEMENT_VELOCITY = "velocity";
const char* NAME_ELEMENT_VERTEX_WEIGHTS = "vertex_weights";
const char* NAME_ELEMENT_VERTICES = "vertices";
const char* NAME_ELEMENT_VISUAL_SCENE = "visual_scene";
const char* NAME_ELEMENT_WIRES = "wires";
const char* NAME_ELEMENT_WRAP_P = "wrap_p";
const char* NAME_ELEMENT_WRAP_S = "wrap_s";
const char* NAME_ELEMENT_WRAP_S____FX_SAMPLER_WRAP_ENUM = "wrap_s____fx_sampler_wrap_enum";
const char* NAME_ELEMENT_WRAP_S____GLES_SAMPLER_WRAP_ENUM = "wrap_s____gles_sampler_wrap_enum";
const char* NAME_ELEMENT_WRAP_T = "wrap_t";
const char* NAME_ELEMENT_WRAP_T____FX_SAMPLER_WRAP_ENUM = "wrap_t____fx_sampler_wrap_enum";
const char* NAME_ELEMENT_WRAP_T____GLES_SAMPLER_WRAP_ENUM = "wrap_t____gles_sampler_wrap_enum";
const char* NAME_ELEMENT_XFOV = "xfov";
const char* NAME_ELEMENT_XMAG = "xmag";
const char* NAME_ELEMENT_XOR = "xor";
const char* NAME_ELEMENT_YFOV = "yfov";
const char* NAME_ELEMENT_YMAG = "ymag";
const char* NAME_ELEMENT_ZFAIL = "zfail";
const char* NAME_ELEMENT_ZFAR = "zfar";
const char* NAME_ELEMENT_ZNEAR = "znear";
const char* NAME_ELEMENT_ZPASS = "zpass";



//---------------------------------------------------------------------
const COLLADA__AttributeData COLLADA__AttributeData::DEFAULT = {0, ENUM__version_enum__NOT_PRESENT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__COLLADA( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__COLLADA( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__COLLADA( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

COLLADA__AttributeData* attributeData = newData<COLLADA__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VERSION:
    {
bool failed;
attributeData->version = Utils::toEnum<ENUM__version_enum, StringHash, ENUM__version_enum__COUNT>(attributeValue, failed, ENUM__version_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLLADA,
        HASH_ATTRIBUTE_VERSION,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_BASE:
    {
bool failed;
attributeData->base = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLLADA,
        HASH_ATTRIBUTE_BASE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= COLLADA__AttributeData::ATTRIBUTE_BASE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_XMLNS:
    {
    // ignore

    break;
    }
    default:
    {
        StringHashPair hashPair = Utils::calculateStringHashWithNamespace( attribute );
        if ( hashPair.first != HASH_ATTRIBUTE_XMLNS )
        {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLLADA, attribute, attributeValue))
            {return false;}        }
        else
        {
            // ignore
        }

    }
    }
    }
}
if ((attributeData->present_attributes & COLLADA__AttributeData::ATTRIBUTE_BASE_PRESENT) == 0)
{
    attributeData->base = COLLADABU::URI("");
}
if ( attributeData->version == ENUM__version_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_COLLADA, HASH_ATTRIBUTE_VERSION, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__COLLADA()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__COLLADA();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__COLLADA( void* attributeData )
{
    COLLADA__AttributeData* typedAttributeData = static_cast<COLLADA__AttributeData*>(attributeData);

    typedAttributeData->~COLLADA__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__version_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__version_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__version_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__version_enum, StringHash, ENUM__version_enum__COUNT, &toEnum_ENUM__version_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__version_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__version_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__version_enum, StringHash, ENUM__version_enum__COUNT>(text, textLength, dataFunction, ENUM__version_enumMap, baseConversionFunc, &toEnum_ENUM__version_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__version_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__version_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__version_enum*, size_t ),
    const std::pair<StringHash, ENUM__version_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__version_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__version_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__version_enum, StringHash, ENUM__version_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__asset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__asset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__asset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__asset( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__contributor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__contributor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__contributor( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__contributor()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__contributor();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__contributor( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__author( const ParserChar* text, size_t textLength )
{

return mImpl->data__author(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__author( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__author( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__author()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__author();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__author( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__author_email( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__author_email( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__author_email( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__author_email()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__author_email();
        if ( !validationResult ) return false;

    } // validation
#endif

bool returnValue = true;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
ParserError::ErrorType simpleTypeValidationResult = validate__author_email(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
{
    ParserChar msg[21];
    Utils::fillErrorMsg(msg, mLastIncompleteFragmentInCharacterData, 20);
    if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        simpleTypeValidationResult,
        0,
        msg) )
    {
        returnValue =  false;
    }
}
if (!returnValue)
{
    mStackMemoryManager.deleteObject();
    mLastIncompleteFragmentInCharacterData = 0;
    mEndOfDataInCurrentObjectOnStack = 0;
    return returnValue;
}
    } // validation
#endif
returnValue = mImpl->data__author_email(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__author_email( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__author_website( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__author_website( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__author_website( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__author_website()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__author_website();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
COLLADABU::URI parameter = GeneratedSaxParser::Utils::toURI((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__author_website(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_AUTHOR_WEBSITE, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__author_website( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__authoring_tool( const ParserChar* text, size_t textLength )
{

return mImpl->data__authoring_tool(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__authoring_tool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__authoring_tool( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__authoring_tool()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__authoring_tool();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__authoring_tool( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__comments( const ParserChar* text, size_t textLength )
{

return mImpl->data__comments(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__comments( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__comments( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__comments()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__comments();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__comments( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__copyright( const ParserChar* text, size_t textLength )
{

return mImpl->data__copyright(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__copyright( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__copyright( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__copyright()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__copyright();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__copyright( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__source_data( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__source_data( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__source_data( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__source_data()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__source_data();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
COLLADABU::URI parameter = GeneratedSaxParser::Utils::toURI((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__source_data(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SOURCE_DATA, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__source_data( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__coverage( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__coverage( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__coverage( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__coverage()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__coverage();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__coverage( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__geographic_location( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__geographic_location( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__geographic_location( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__geographic_location()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__geographic_location();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__geographic_location( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__longitude( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__longitude( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__longitude( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__longitude()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__longitude();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__longitude(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_LONGITUDE, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__longitude( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__latitude( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__latitude( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__latitude( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__latitude()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__latitude();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__latitude(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_LATITUDE, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__latitude( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const altitude__AttributeData altitude__AttributeData::DEFAULT = {ENUM__altitude_mode_enum__relativeToGround};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__altitude( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__altitude( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__altitude( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

altitude__AttributeData* attributeData = newData<altitude__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_MODE:
    {
bool failed;
attributeData->mode = Utils::toEnum<ENUM__altitude_mode_enum, StringHash, ENUM__altitude_mode_enum__COUNT>(attributeValue, failed, ENUM__altitude_mode_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ALTITUDE,
        HASH_ATTRIBUTE_MODE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALTITUDE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__altitude()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__altitude();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__altitude(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ALTITUDE, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__altitude( void* attributeData )
{
    altitude__AttributeData* typedAttributeData = static_cast<altitude__AttributeData*>(attributeData);

    typedAttributeData->~altitude__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__altitude_mode_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__altitude_mode_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__altitude_mode_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__altitude_mode_enum, StringHash, ENUM__altitude_mode_enum__COUNT, &toEnum_ENUM__altitude_mode_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__altitude_mode_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__altitude_mode_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__altitude_mode_enum, StringHash, ENUM__altitude_mode_enum__COUNT>(text, textLength, dataFunction, ENUM__altitude_mode_enumMap, baseConversionFunc, &toEnum_ENUM__altitude_mode_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__altitude_mode_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__altitude_mode_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__altitude_mode_enum*, size_t ),
    const std::pair<StringHash, ENUM__altitude_mode_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__altitude_mode_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__altitude_mode_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__altitude_mode_enum, StringHash, ENUM__altitude_mode_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__created( const ParserChar* text, size_t textLength )
{

return mImpl->data__created(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__created( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__created( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__created()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__created();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__created( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__keywords( const ParserChar* text, size_t textLength )
{

return mImpl->data__keywords(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__keywords( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__keywords( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__keywords()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__keywords();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__keywords( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__modified( const ParserChar* text, size_t textLength )
{

return mImpl->data__modified(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__modified( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__modified( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__modified()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__modified();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__modified( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__revision( const ParserChar* text, size_t textLength )
{

return mImpl->data__revision(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__revision( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__revision( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__revision()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__revision();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__revision( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__subject( const ParserChar* text, size_t textLength )
{

return mImpl->data__subject(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__subject( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__subject( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__subject()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__subject();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__subject( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__title( const ParserChar* text, size_t textLength )
{

return mImpl->data__title(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__title( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__title( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__title()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__title();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__title( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const unit__AttributeData unit__AttributeData::DEFAULT = {1.0E0, (const ParserChar*)"meter"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__unit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__unit( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

unit__AttributeData* attributeData = newData<unit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_METER:
    {
bool failed;
attributeData->meter = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_UNIT,
        HASH_ATTRIBUTE_METER,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKEN(attributeData->name, strlen(attributeData->name));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_UNIT,
            HASH_ATTRIBUTE_NAME,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_UNIT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__unit()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__unit();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__unit( void* attributeData )
{
    unit__AttributeData* typedAttributeData = static_cast<unit__AttributeData*>(attributeData);

    typedAttributeData->~unit__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__up_axis( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__up_axis( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__up_axis( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__up_axis()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__up_axis();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__up_axis_enum parameter = Utils::toEnum<ENUM__up_axis_enum, StringHash, ENUM__up_axis_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__up_axis_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__up_axis(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_UP_AXIS, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__up_axis( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
ENUM__up_axis_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__up_axis_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__up_axis_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__up_axis_enum, StringHash, ENUM__up_axis_enum__COUNT, &toEnum_ENUM__up_axis_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__up_axis_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__up_axis_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__up_axis_enum, StringHash, ENUM__up_axis_enum__COUNT>(text, textLength, dataFunction, ENUM__up_axis_enumMap, baseConversionFunc, &toEnum_ENUM__up_axis_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__up_axis_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__up_axis_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__up_axis_enum*, size_t ),
    const std::pair<StringHash, ENUM__up_axis_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__up_axis_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__up_axis_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__up_axis_enum, StringHash, ENUM__up_axis_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const extra__AttributeData extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__extra( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKEN(attributeData->type, strlen(attributeData->type));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EXTRA,
            HASH_ATTRIBUTE_TYPE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EXTRA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__extra()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__extra();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__extra( void* attributeData )
{
    extra__AttributeData* typedAttributeData = static_cast<extra__AttributeData*>(attributeData);

    typedAttributeData->~extra__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const technique____technique_type__AttributeData technique____technique_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__technique____technique_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__technique____technique_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__technique____technique_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

technique____technique_type__AttributeData* attributeData = newData<technique____technique_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKEN(attributeData->profile, strlen(attributeData->profile));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE,
            HASH_ATTRIBUTE_PROFILE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->profile )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TECHNIQUE, HASH_ATTRIBUTE_PROFILE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__technique____technique_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__technique____technique_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__technique____technique_type( void* attributeData )
{
    technique____technique_type__AttributeData* typedAttributeData = static_cast<technique____technique_type__AttributeData*>(attributeData);

    typedAttributeData->~technique____technique_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_animations__AttributeData library_animations__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_animations( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_animations( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_animations( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_animations__AttributeData* attributeData = newData<library_animations__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_ANIMATIONS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_animations()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_animations();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_animations( void* attributeData )
{
    library_animations__AttributeData* typedAttributeData = static_cast<library_animations__AttributeData*>(attributeData);

    typedAttributeData->~library_animations__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const animation__AttributeData animation__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__animation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__animation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

animation__AttributeData* attributeData = newData<animation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANIMATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__animation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__animation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__animation( void* attributeData )
{
    animation__AttributeData* typedAttributeData = static_cast<animation__AttributeData*>(attributeData);

    typedAttributeData->~animation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const source__AttributeData source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__source( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

source__AttributeData* attributeData = newData<source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SOURCE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SOURCE, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__source()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__source();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__source( void* attributeData )
{
    source__AttributeData* typedAttributeData = static_cast<source__AttributeData*>(attributeData);

    typedAttributeData->~source__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const token_array__AttributeData token_array__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__token_array( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__token_array, 0, 0, 0);
    }
    else
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__token_array);
    }
#else
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__token_array);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__token_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__token_array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

token_array__AttributeData* attributeData = newData<token_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TOKEN_ARRAY,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= token_array__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TOKEN_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & token_array__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TOKEN_ARRAY, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__token_array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__token_array();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = stringListDataEnd( &ColladaParserAutoGen15::data__token_array, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return stringListDataEnd( &ColladaParserAutoGen15::data__token_array );
    }
#else
    {
return stringListDataEnd( &ColladaParserAutoGen15::data__token_array );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__token_array( void* attributeData )
{
    token_array__AttributeData* typedAttributeData = static_cast<token_array__AttributeData*>(attributeData);

    typedAttributeData->~token_array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const IDREF_array__AttributeData IDREF_array__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__IDREF_array( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        IDREF_array__ValidationData* validationData = (IDREF_array__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__IDREF_array, &validate__IDREFS__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__IDREF_array);
    }
#else
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__IDREF_array);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__IDREF_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__IDREF_array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

IDREF_array__AttributeData* attributeData = newData<IDREF_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IDREF_ARRAY,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= IDREF_array__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_IDREF_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & IDREF_array__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_IDREF_ARRAY, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__IDREF_array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__IDREF_array();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        IDREF_array__ValidationData* validationData = (IDREF_array__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = stringListDataEnd( &ColladaParserAutoGen15::data__IDREF_array, &validate__IDREFS__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__IDREFS(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_IDREF_ARRAY,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return stringListDataEnd( &ColladaParserAutoGen15::data__IDREF_array );
    }
#else
    {
return stringListDataEnd( &ColladaParserAutoGen15::data__IDREF_array );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__IDREF_array( void* attributeData )
{
    IDREF_array__AttributeData* typedAttributeData = static_cast<IDREF_array__AttributeData*>(attributeData);

    typedAttributeData->~IDREF_array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const Name_array__AttributeData Name_array__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__Name_array( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__Name_array, 0, 0, &validate__Name);
    }
    else
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__Name_array);
    }
#else
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__Name_array);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__Name_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__Name_array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

Name_array__AttributeData* attributeData = newData<Name_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NAME_ARRAY,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= Name_array__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NAME_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & Name_array__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NAME_ARRAY, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__Name_array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__Name_array();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = stringListDataEnd( &ColladaParserAutoGen15::data__Name_array, 0, 0, &validate__Name );
        return returnValue;
    }
    else
    {
return stringListDataEnd( &ColladaParserAutoGen15::data__Name_array );
    }
#else
    {
return stringListDataEnd( &ColladaParserAutoGen15::data__Name_array );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__Name_array( void* attributeData )
{
    Name_array__AttributeData* typedAttributeData = static_cast<Name_array__AttributeData*>(attributeData);

    typedAttributeData->~Name_array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const bool_array__AttributeData bool_array__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool_array( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool_array, 0, 0, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool_array);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool_array);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool_array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

bool_array__AttributeData* attributeData = newData<bool_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BOOL_ARRAY,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= bool_array__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BOOL_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & bool_array__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BOOL_ARRAY, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool_array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool_array();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool_array, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool_array );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool_array );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool_array( void* attributeData )
{
    bool_array__AttributeData* typedAttributeData = static_cast<bool_array__AttributeData*>(attributeData);

    typedAttributeData->~bool_array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const float_array__AttributeData float_array__AttributeData::DEFAULT = {0, 0, 0, 0, 6, 38};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float_array( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float_array, 0, 0, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float_array);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float_array);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float_array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

float_array__AttributeData* attributeData = newData<float_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FLOAT_ARRAY,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= float_array__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_DIGITS:
    {
bool failed;
attributeData->digits = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FLOAT_ARRAY,
        HASH_ATTRIBUTE_DIGITS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__digits_type(attributeData->digits);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FLOAT_ARRAY,
            HASH_ATTRIBUTE_DIGITS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_MAGNITUDE:
    {
bool failed;
attributeData->magnitude = GeneratedSaxParser::Utils::toSint16(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FLOAT_ARRAY,
        HASH_ATTRIBUTE_MAGNITUDE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__magnitude_type(attributeData->magnitude);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FLOAT_ARRAY,
            HASH_ATTRIBUTE_MAGNITUDE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FLOAT_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & float_array__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_FLOAT_ARRAY, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float_array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float_array();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float_array, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float_array );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float_array );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float_array( void* attributeData )
{
    float_array__AttributeData* typedAttributeData = static_cast<float_array__AttributeData*>(attributeData);

    typedAttributeData->~float_array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const int_array__AttributeData int_array__AttributeData::DEFAULT = {0, 0, 0, 0, -2147483647-1, 2147483647};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int_array( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int_array, 0, 0, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int_array);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int_array);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int_array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

int_array__AttributeData* attributeData = newData<int_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INT_ARRAY,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= int_array__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MININCLUSIVE:
    {
bool failed;
attributeData->minInclusive = GeneratedSaxParser::Utils::toSint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INT_ARRAY,
        HASH_ATTRIBUTE_MININCLUSIVE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_MAXINCLUSIVE:
    {
bool failed;
attributeData->maxInclusive = GeneratedSaxParser::Utils::toSint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INT_ARRAY,
        HASH_ATTRIBUTE_MAXINCLUSIVE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INT_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & int_array__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INT_ARRAY, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int_array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int_array();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int_array, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int_array );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int_array );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int_array( void* attributeData )
{
    int_array__AttributeData* typedAttributeData = static_cast<int_array__AttributeData*>(attributeData);

    typedAttributeData->~int_array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const SIDREF_array__AttributeData SIDREF_array__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__SIDREF_array( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__SIDREF_array, 0, 0, &validate__sidref_type);
    }
    else
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__SIDREF_array);
    }
#else
    {
return characterData2StringData(text, textLength, &ColladaParserAutoGen15::data__SIDREF_array);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__SIDREF_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__SIDREF_array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

SIDREF_array__AttributeData* attributeData = newData<SIDREF_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIDREF_ARRAY,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= SIDREF_array__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SIDREF_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & SIDREF_array__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIDREF_ARRAY, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__SIDREF_array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__SIDREF_array();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = stringListDataEnd( &ColladaParserAutoGen15::data__SIDREF_array, 0, 0, &validate__sidref_type );
        return returnValue;
    }
    else
    {
return stringListDataEnd( &ColladaParserAutoGen15::data__SIDREF_array );
    }
#else
    {
return stringListDataEnd( &ColladaParserAutoGen15::data__SIDREF_array );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__SIDREF_array( void* attributeData )
{
    SIDREF_array__AttributeData* typedAttributeData = static_cast<SIDREF_array__AttributeData*>(attributeData);

    typedAttributeData->~SIDREF_array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__source_type____technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__source_type____technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__source_type____technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__source_type____technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__source_type____technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__source_type____technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const accessor__AttributeData accessor__AttributeData::DEFAULT = {0, 0, 0, 0, 1};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__accessor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__accessor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__accessor( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

accessor__AttributeData* attributeData = newData<accessor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ACCESSOR,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= accessor__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ACCESSOR,
        HASH_ATTRIBUTE_OFFSET,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {
bool failed;
attributeData->source = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ACCESSOR,
        HASH_ATTRIBUTE_SOURCE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= accessor__AttributeData::ATTRIBUTE_SOURCE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STRIDE:
    {
bool failed;
attributeData->stride = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ACCESSOR,
        HASH_ATTRIBUTE_STRIDE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ACCESSOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & accessor__AttributeData::ATTRIBUTE_SOURCE_PRESENT) == 0)
{
    attributeData->source = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & accessor__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ACCESSOR, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & accessor__AttributeData::ATTRIBUTE_SOURCE_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ACCESSOR, HASH_ATTRIBUTE_SOURCE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__accessor()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__accessor();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__accessor( void* attributeData )
{
    accessor__AttributeData* typedAttributeData = static_cast<accessor__AttributeData*>(attributeData);

    typedAttributeData->~accessor__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const param____param_type__AttributeData param____param_type__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__param____param_type( const ParserChar* text, size_t textLength )
{

return mImpl->data__param____param_type(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__param____param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__param____param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

param____param_type__AttributeData* attributeData = newData<param____param_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKEN(attributeData->semantic, strlen(attributeData->semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARAM,
            HASH_ATTRIBUTE_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKEN(attributeData->type, strlen(attributeData->type));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARAM,
            HASH_ATTRIBUTE_TYPE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->type )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PARAM, HASH_ATTRIBUTE_TYPE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__param____param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__param____param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__param____param_type( void* attributeData )
{
    param____param_type__AttributeData* typedAttributeData = static_cast<param____param_type__AttributeData*>(attributeData);

    typedAttributeData->~param____param_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const sampler__AttributeData sampler__AttributeData::DEFAULT = {0, ENUM__sampler_behavior_enum__NOT_PRESENT, ENUM__sampler_behavior_enum__NOT_PRESENT};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sampler( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sampler( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sampler( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sampler__AttributeData* attributeData = newData<sampler__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PRE_BEHAVIOR:
    {
bool failed;
attributeData->pre_behavior = Utils::toEnum<ENUM__sampler_behavior_enum, StringHash, ENUM__sampler_behavior_enum__COUNT>(attributeValue, failed, ENUM__sampler_behavior_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLER,
        HASH_ATTRIBUTE_PRE_BEHAVIOR,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_POST_BEHAVIOR:
    {
bool failed;
attributeData->post_behavior = Utils::toEnum<ENUM__sampler_behavior_enum, StringHash, ENUM__sampler_behavior_enum__COUNT>(attributeValue, failed, ENUM__sampler_behavior_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLER,
        HASH_ATTRIBUTE_POST_BEHAVIOR,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sampler()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sampler();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sampler( void* attributeData )
{
    sampler__AttributeData* typedAttributeData = static_cast<sampler__AttributeData*>(attributeData);

    typedAttributeData->~sampler__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__sampler_behavior_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__sampler_behavior_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__sampler_behavior_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__sampler_behavior_enum, StringHash, ENUM__sampler_behavior_enum__COUNT, &toEnum_ENUM__sampler_behavior_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__sampler_behavior_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__sampler_behavior_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__sampler_behavior_enum, StringHash, ENUM__sampler_behavior_enum__COUNT>(text, textLength, dataFunction, ENUM__sampler_behavior_enumMap, baseConversionFunc, &toEnum_ENUM__sampler_behavior_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__sampler_behavior_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__sampler_behavior_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__sampler_behavior_enum*, size_t ),
    const std::pair<StringHash, ENUM__sampler_behavior_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__sampler_behavior_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__sampler_behavior_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__sampler_behavior_enum, StringHash, ENUM__sampler_behavior_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const input____input_local_type__AttributeData input____input_local_type__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__input____input_local_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__input____input_local_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__input____input_local_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

input____input_local_type__AttributeData* attributeData = newData<input____input_local_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKEN(attributeData->semantic, strlen(attributeData->semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INPUT,
            HASH_ATTRIBUTE_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__urifragment_type(attributeData->source, strlen(attributeData->source));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INPUT,
            HASH_ATTRIBUTE_SOURCE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INPUT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->semantic )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INPUT, HASH_ATTRIBUTE_SEMANTIC, 0 ) )
        return false;
}
if ( !attributeData->source )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INPUT, HASH_ATTRIBUTE_SOURCE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__input____input_local_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__input____input_local_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__input____input_local_type( void* attributeData )
{
    input____input_local_type__AttributeData* typedAttributeData = static_cast<input____input_local_type__AttributeData*>(attributeData);

    typedAttributeData->~input____input_local_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const channel__AttributeData channel__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__channel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__channel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__channel( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

channel__AttributeData* attributeData = newData<channel__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__urifragment_type(attributeData->source, strlen(attributeData->source));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CHANNEL,
            HASH_ATTRIBUTE_SOURCE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CHANNEL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->source )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_CHANNEL, HASH_ATTRIBUTE_SOURCE, 0 ) )
        return false;
}
if ( !attributeData->target )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_CHANNEL, HASH_ATTRIBUTE_TARGET, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__channel()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__channel();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__channel( void* attributeData )
{
    channel__AttributeData* typedAttributeData = static_cast<channel__AttributeData*>(attributeData);

    typedAttributeData->~channel__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_animation_clips__AttributeData library_animation_clips__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_animation_clips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_animation_clips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_animation_clips( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_animation_clips__AttributeData* attributeData = newData<library_animation_clips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_ANIMATION_CLIPS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_animation_clips()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_animation_clips();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_animation_clips( void* attributeData )
{
    library_animation_clips__AttributeData* typedAttributeData = static_cast<library_animation_clips__AttributeData*>(attributeData);

    typedAttributeData->~library_animation_clips__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const animation_clip__AttributeData animation_clip__AttributeData::DEFAULT = {0, 0, 0, 0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__animation_clip( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__animation_clip( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__animation_clip( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

animation_clip__AttributeData* attributeData = newData<animation_clip__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_START:
    {
bool failed;
attributeData->start = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ANIMATION_CLIP,
        HASH_ATTRIBUTE_START,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_END:
    {
bool failed;
attributeData->end = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ANIMATION_CLIP,
        HASH_ATTRIBUTE_END,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= animation_clip__AttributeData::ATTRIBUTE_END_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANIMATION_CLIP, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__animation_clip()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__animation_clip();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__animation_clip( void* attributeData )
{
    animation_clip__AttributeData* typedAttributeData = static_cast<animation_clip__AttributeData*>(attributeData);

    typedAttributeData->~animation_clip__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_animation__AttributeData instance_animation__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_animation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_animation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_animation__AttributeData* attributeData = newData<instance_animation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_ANIMATION,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_animation__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_ANIMATION,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_ANIMATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_animation__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_animation__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_ANIMATION, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_animation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_animation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_animation( void* attributeData )
{
    instance_animation__AttributeData* typedAttributeData = static_cast<instance_animation__AttributeData*>(attributeData);

    typedAttributeData->~instance_animation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_formula__AttributeData instance_formula__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_formula( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_formula( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_formula( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_formula__AttributeData* attributeData = newData<instance_formula__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_FORMULA,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_FORMULA,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_formula__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_FORMULA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_formula__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_formula()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_formula();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_formula( void* attributeData )
{
    instance_formula__AttributeData* typedAttributeData = static_cast<instance_formula__AttributeData*>(attributeData);

    typedAttributeData->~instance_formula__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const setparam____formula_setparam_type__AttributeData setparam____formula_setparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__setparam____formula_setparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__setparam____formula_setparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__setparam____formula_setparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

setparam____formula_setparam_type__AttributeData* attributeData = newData<setparam____formula_setparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SETPARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__setparam____formula_setparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__setparam____formula_setparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__setparam____formula_setparam_type( void* attributeData )
{
    setparam____formula_setparam_type__AttributeData* typedAttributeData = static_cast<setparam____formula_setparam_type__AttributeData*>(attributeData);

    typedAttributeData->~setparam____formula_setparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float____float_type( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float____float_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float____float_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float____float_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float____float_type();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__float____float_type(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FLOAT, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float____float_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int____int_type( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int____int_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int____int_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int____int_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int____int_type();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
sint64 parameter = GeneratedSaxParser::Utils::toSint64((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__int____int_type(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_INT, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int____int_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__SIDREF( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__SIDREF( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__SIDREF( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__SIDREF()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__SIDREF();
        if ( !validationResult ) return false;

    } // validation
#endif

bool returnValue = true;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
ParserError::ErrorType simpleTypeValidationResult = validate__sidref_type(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
{
    ParserChar msg[21];
    Utils::fillErrorMsg(msg, mLastIncompleteFragmentInCharacterData, 20);
    if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        simpleTypeValidationResult,
        0,
        msg) )
    {
        returnValue =  false;
    }
}
if (!returnValue)
{
    mStackMemoryManager.deleteObject();
    mLastIncompleteFragmentInCharacterData = 0;
    mEndOfDataInCurrentObjectOnStack = 0;
    return returnValue;
}
    } // validation
#endif
returnValue = mImpl->data__SIDREF(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__SIDREF( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__bool(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_BOOL, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const connect_param__AttributeData connect_param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__connect_param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__connect_param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__connect_param( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

connect_param__AttributeData* attributeData = newData<connect_param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONNECT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_CONNECT_PARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__connect_param()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__connect_param();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__connect_param( void* attributeData )
{
    connect_param__AttributeData* typedAttributeData = static_cast<connect_param__AttributeData*>(attributeData);

    typedAttributeData->~connect_param__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_cameras__AttributeData library_cameras__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_cameras( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_cameras( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_cameras( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_cameras__AttributeData* attributeData = newData<library_cameras__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_CAMERAS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_cameras()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_cameras();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_cameras( void* attributeData )
{
    library_cameras__AttributeData* typedAttributeData = static_cast<library_cameras__AttributeData*>(attributeData);

    typedAttributeData->~library_cameras__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const camera__AttributeData camera__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__camera( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__camera( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__camera( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

camera__AttributeData* attributeData = newData<camera__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CAMERA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__camera()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__camera();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__camera( void* attributeData )
{
    camera__AttributeData* typedAttributeData = static_cast<camera__AttributeData*>(attributeData);

    typedAttributeData->~camera__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__optics( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__optics( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__optics( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__optics()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__optics();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__optics( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__optics__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__optics__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__optics__technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__optics__technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__optics__technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__optics__technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__orthographic( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__orthographic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__orthographic( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__orthographic()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__orthographic();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__orthographic( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const xmag__AttributeData xmag__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__xmag( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__xmag( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__xmag( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

xmag__AttributeData* attributeData = newData<xmag__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_XMAG,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_XMAG, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__xmag()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__xmag();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__xmag(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_XMAG, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__xmag( void* attributeData )
{
    xmag__AttributeData* typedAttributeData = static_cast<xmag__AttributeData*>(attributeData);

    typedAttributeData->~xmag__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const ymag__AttributeData ymag__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ymag( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ymag( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ymag( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

ymag__AttributeData* attributeData = newData<ymag__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_YMAG,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_YMAG, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ymag()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ymag();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__ymag(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_YMAG, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ymag( void* attributeData )
{
    ymag__AttributeData* typedAttributeData = static_cast<ymag__AttributeData*>(attributeData);

    typedAttributeData->~ymag__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const aspect_ratio__AttributeData aspect_ratio__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__aspect_ratio( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__aspect_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__aspect_ratio( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

aspect_ratio__AttributeData* attributeData = newData<aspect_ratio__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ASPECT_RATIO,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ASPECT_RATIO, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__aspect_ratio()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__aspect_ratio();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__aspect_ratio(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ASPECT_RATIO, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__aspect_ratio( void* attributeData )
{
    aspect_ratio__AttributeData* typedAttributeData = static_cast<aspect_ratio__AttributeData*>(attributeData);

    typedAttributeData->~aspect_ratio__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const znear__AttributeData znear__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__znear( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__znear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__znear( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

znear__AttributeData* attributeData = newData<znear__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ZNEAR,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZNEAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__znear()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__znear();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__znear(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ZNEAR, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__znear( void* attributeData )
{
    znear__AttributeData* typedAttributeData = static_cast<znear__AttributeData*>(attributeData);

    typedAttributeData->~znear__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const zfar__AttributeData zfar__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__zfar( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__zfar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__zfar( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

zfar__AttributeData* attributeData = newData<zfar__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ZFAR,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZFAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__zfar()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__zfar();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__zfar(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ZFAR, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__zfar( void* attributeData )
{
    zfar__AttributeData* typedAttributeData = static_cast<zfar__AttributeData*>(attributeData);

    typedAttributeData->~zfar__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__perspective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__perspective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__perspective( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__perspective()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__perspective();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__perspective( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const xfov__AttributeData xfov__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__xfov( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__xfov( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__xfov( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

xfov__AttributeData* attributeData = newData<xfov__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_XFOV,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_XFOV, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__xfov()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__xfov();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__xfov(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_XFOV, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__xfov( void* attributeData )
{
    xfov__AttributeData* typedAttributeData = static_cast<xfov__AttributeData*>(attributeData);

    typedAttributeData->~xfov__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const yfov__AttributeData yfov__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__yfov( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__yfov( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__yfov( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

yfov__AttributeData* attributeData = newData<yfov__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_YFOV,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_YFOV, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__yfov()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__yfov();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__yfov(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_YFOV, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__yfov( void* attributeData )
{
    yfov__AttributeData* typedAttributeData = static_cast<yfov__AttributeData*>(attributeData);

    typedAttributeData->~yfov__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__imager( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__imager( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__imager( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__imager()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__imager();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__imager( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const library_controllers__AttributeData library_controllers__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_controllers( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_controllers( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_controllers( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_controllers__AttributeData* attributeData = newData<library_controllers__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_CONTROLLERS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_controllers()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_controllers();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_controllers( void* attributeData )
{
    library_controllers__AttributeData* typedAttributeData = static_cast<library_controllers__AttributeData*>(attributeData);

    typedAttributeData->~library_controllers__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const controller__AttributeData controller__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__controller( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__controller( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__controller( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

controller__AttributeData* attributeData = newData<controller__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONTROLLER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__controller()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__controller();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__controller( void* attributeData )
{
    controller__AttributeData* typedAttributeData = static_cast<controller__AttributeData*>(attributeData);

    typedAttributeData->~controller__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const skin__AttributeData skin__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__skin( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__skin( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__skin( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

skin__AttributeData* attributeData = newData<skin__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {
bool failed;
attributeData->source = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SKIN,
        HASH_ATTRIBUTE_SOURCE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= skin__AttributeData::ATTRIBUTE_SOURCE_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SKIN, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & skin__AttributeData::ATTRIBUTE_SOURCE_PRESENT) == 0)
{
    attributeData->source = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & skin__AttributeData::ATTRIBUTE_SOURCE_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SKIN, HASH_ATTRIBUTE_SOURCE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__skin()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__skin();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__skin( void* attributeData )
{
    skin__AttributeData* typedAttributeData = static_cast<skin__AttributeData*>(attributeData);

    typedAttributeData->~skin__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bind_shape_matrix( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__bind_shape_matrix, &validate__float4x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__bind_shape_matrix);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__bind_shape_matrix);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bind_shape_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bind_shape_matrix( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bind_shape_matrix()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bind_shape_matrix();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__bind_shape_matrix, &validate__float4x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BIND_SHAPE_MATRIX,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__bind_shape_matrix );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__bind_shape_matrix );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bind_shape_matrix( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__joints( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__joints( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__joints( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__joints()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__joints();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__joints( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const vertex_weights__AttributeData vertex_weights__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__vertex_weights( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__vertex_weights( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__vertex_weights( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

vertex_weights__AttributeData* attributeData = newData<vertex_weights__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VERTEX_WEIGHTS,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= vertex_weights__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VERTEX_WEIGHTS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & vertex_weights__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_VERTEX_WEIGHTS, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__vertex_weights()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__vertex_weights();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__vertex_weights( void* attributeData )
{
    vertex_weights__AttributeData* typedAttributeData = static_cast<vertex_weights__AttributeData*>(attributeData);

    typedAttributeData->~vertex_weights__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const input____input_local_offset_type__AttributeData input____input_local_offset_type__AttributeData::DEFAULT = {0, 0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__input____input_local_offset_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__input____input_local_offset_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__input____input_local_offset_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

input____input_local_offset_type__AttributeData* attributeData = newData<input____input_local_offset_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {
bool failed;
attributeData->offset = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INPUT,
        HASH_ATTRIBUTE_OFFSET,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= input____input_local_offset_type__AttributeData::ATTRIBUTE_OFFSET_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKEN(attributeData->semantic, strlen(attributeData->semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INPUT,
            HASH_ATTRIBUTE_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__urifragment_type(attributeData->source, strlen(attributeData->source));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INPUT,
            HASH_ATTRIBUTE_SOURCE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_SET:
    {
bool failed;
attributeData->set = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INPUT,
        HASH_ATTRIBUTE_SET,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= input____input_local_offset_type__AttributeData::ATTRIBUTE_SET_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INPUT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & input____input_local_offset_type__AttributeData::ATTRIBUTE_OFFSET_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INPUT, HASH_ATTRIBUTE_OFFSET, 0 ) )
        return false;
}
if ( !attributeData->semantic )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INPUT, HASH_ATTRIBUTE_SEMANTIC, 0 ) )
        return false;
}
if ( !attributeData->source )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INPUT, HASH_ATTRIBUTE_SOURCE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__input____input_local_offset_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__input____input_local_offset_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__input____input_local_offset_type( void* attributeData )
{
    input____input_local_offset_type__AttributeData* typedAttributeData = static_cast<input____input_local_offset_type__AttributeData*>(attributeData);

    typedAttributeData->~input____input_local_offset_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__vcount( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__vcount, 0, 0, 0);
    }
    else
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__vcount);
    }
#else
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__vcount);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__vcount( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__vcount( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__vcount()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__vcount();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = uint64DataEnd( &ColladaParserAutoGen15::data__vcount, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return uint64DataEnd( &ColladaParserAutoGen15::data__vcount );
    }
#else
    {
return uint64DataEnd( &ColladaParserAutoGen15::data__vcount );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__vcount( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__v( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__v, 0, 0, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__v);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__v);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__v( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__v( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__v()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__v();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__v, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__v );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__v );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__v( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const morph__AttributeData morph__AttributeData::DEFAULT = {0, ENUM__morph_method_enum__NORMALIZED, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__morph( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__morph( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__morph( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

morph__AttributeData* attributeData = newData<morph__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_METHOD:
    {
bool failed;
attributeData->method = Utils::toEnum<ENUM__morph_method_enum, StringHash, ENUM__morph_method_enum__COUNT>(attributeValue, failed, ENUM__morph_method_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MORPH,
        HASH_ATTRIBUTE_METHOD,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {
bool failed;
attributeData->source = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MORPH,
        HASH_ATTRIBUTE_SOURCE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= morph__AttributeData::ATTRIBUTE_SOURCE_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MORPH, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & morph__AttributeData::ATTRIBUTE_SOURCE_PRESENT) == 0)
{
    attributeData->source = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & morph__AttributeData::ATTRIBUTE_SOURCE_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_MORPH, HASH_ATTRIBUTE_SOURCE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__morph()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__morph();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__morph( void* attributeData )
{
    morph__AttributeData* typedAttributeData = static_cast<morph__AttributeData*>(attributeData);

    typedAttributeData->~morph__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__morph_method_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__morph_method_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__morph_method_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__morph_method_enum, StringHash, ENUM__morph_method_enum__COUNT, &toEnum_ENUM__morph_method_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__morph_method_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__morph_method_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__morph_method_enum, StringHash, ENUM__morph_method_enum__COUNT>(text, textLength, dataFunction, ENUM__morph_method_enumMap, baseConversionFunc, &toEnum_ENUM__morph_method_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__morph_method_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__morph_method_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__morph_method_enum*, size_t ),
    const std::pair<StringHash, ENUM__morph_method_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__morph_method_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__morph_method_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__morph_method_enum, StringHash, ENUM__morph_method_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__targets( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__targets( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__targets( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__targets()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__targets();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__targets( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const library_geometries__AttributeData library_geometries__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_geometries( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_geometries( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_geometries( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_geometries__AttributeData* attributeData = newData<library_geometries__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_GEOMETRIES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_geometries()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_geometries();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_geometries( void* attributeData )
{
    library_geometries__AttributeData* typedAttributeData = static_cast<library_geometries__AttributeData*>(attributeData);

    typedAttributeData->~library_geometries__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const geometry__AttributeData geometry__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__geometry( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

geometry__AttributeData* attributeData = newData<geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GEOMETRY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__geometry()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__geometry();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__geometry( void* attributeData )
{
    geometry__AttributeData* typedAttributeData = static_cast<geometry__AttributeData*>(attributeData);

    typedAttributeData->~geometry__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const convex_mesh__AttributeData convex_mesh__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__convex_mesh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__convex_mesh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__convex_mesh( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

convex_mesh__AttributeData* attributeData = newData<convex_mesh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CONVEX_HULL_OF:
    {
bool failed;
attributeData->convex_hull_of = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CONVEX_MESH,
        HASH_ATTRIBUTE_CONVEX_HULL_OF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= convex_mesh__AttributeData::ATTRIBUTE_CONVEX_HULL_OF_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONVEX_MESH, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & convex_mesh__AttributeData::ATTRIBUTE_CONVEX_HULL_OF_PRESENT) == 0)
{
    attributeData->convex_hull_of = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__convex_mesh()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__convex_mesh();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__convex_mesh( void* attributeData )
{
    convex_mesh__AttributeData* typedAttributeData = static_cast<convex_mesh__AttributeData*>(attributeData);

    typedAttributeData->~convex_mesh__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const vertices__AttributeData vertices__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__vertices( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

vertices__AttributeData* attributeData = newData<vertices__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VERTICES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_VERTICES, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__vertices()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__vertices();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__vertices( void* attributeData )
{
    vertices__AttributeData* typedAttributeData = static_cast<vertices__AttributeData*>(attributeData);

    typedAttributeData->~vertices__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const lines__AttributeData lines__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__lines( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__lines( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

lines__AttributeData* attributeData = newData<lines__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINES,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= lines__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->material, strlen(attributeData->material));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINES,
            HASH_ATTRIBUTE_MATERIAL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & lines__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LINES, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__lines()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__lines();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__lines( void* attributeData )
{
    lines__AttributeData* typedAttributeData = static_cast<lines__AttributeData*>(attributeData);

    typedAttributeData->~lines__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__p( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__p, 0, 0, 0);
    }
    else
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__p);
    }
#else
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__p);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__p( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__p()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__p();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = uint64DataEnd( &ColladaParserAutoGen15::data__p, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return uint64DataEnd( &ColladaParserAutoGen15::data__p );
    }
#else
    {
return uint64DataEnd( &ColladaParserAutoGen15::data__p );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const linestrips__AttributeData linestrips__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__linestrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__linestrips( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

linestrips__AttributeData* attributeData = newData<linestrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINESTRIPS,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= linestrips__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->material, strlen(attributeData->material));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINESTRIPS,
            HASH_ATTRIBUTE_MATERIAL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINESTRIPS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & linestrips__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LINESTRIPS, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__linestrips()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__linestrips();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__linestrips( void* attributeData )
{
    linestrips__AttributeData* typedAttributeData = static_cast<linestrips__AttributeData*>(attributeData);

    typedAttributeData->~linestrips__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const polygons__AttributeData polygons__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polygons( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polygons( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

polygons__AttributeData* attributeData = newData<polygons__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGONS,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= polygons__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->material, strlen(attributeData->material));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGONS,
            HASH_ATTRIBUTE_MATERIAL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGONS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & polygons__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_POLYGONS, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polygons()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polygons();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polygons( void* attributeData )
{
    polygons__AttributeData* typedAttributeData = static_cast<polygons__AttributeData*>(attributeData);

    typedAttributeData->~polygons__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ph( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ph( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ph( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ph()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ph();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ph( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__h( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__h, 0, 0, 0);
    }
    else
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__h);
    }
#else
    {
return characterData2Uint64Data(text, textLength, &ColladaParserAutoGen15::data__h);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__h( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__h( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__h()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__h();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = uint64DataEnd( &ColladaParserAutoGen15::data__h, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return uint64DataEnd( &ColladaParserAutoGen15::data__h );
    }
#else
    {
return uint64DataEnd( &ColladaParserAutoGen15::data__h );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__h( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const polylist__AttributeData polylist__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polylist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polylist( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

polylist__AttributeData* attributeData = newData<polylist__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYLIST,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= polylist__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->material, strlen(attributeData->material));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYLIST,
            HASH_ATTRIBUTE_MATERIAL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYLIST, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & polylist__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_POLYLIST, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polylist()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polylist();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polylist( void* attributeData )
{
    polylist__AttributeData* typedAttributeData = static_cast<polylist__AttributeData*>(attributeData);

    typedAttributeData->~polylist__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const triangles__AttributeData triangles__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__triangles( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__triangles( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

triangles__AttributeData* attributeData = newData<triangles__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRIANGLES,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= triangles__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->material, strlen(attributeData->material));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TRIANGLES,
            HASH_ATTRIBUTE_MATERIAL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRIANGLES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & triangles__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TRIANGLES, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__triangles()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__triangles();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__triangles( void* attributeData )
{
    triangles__AttributeData* typedAttributeData = static_cast<triangles__AttributeData*>(attributeData);

    typedAttributeData->~triangles__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const trifans__AttributeData trifans__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__trifans( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__trifans( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

trifans__AttributeData* attributeData = newData<trifans__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRIFANS,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= trifans__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->material, strlen(attributeData->material));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TRIFANS,
            HASH_ATTRIBUTE_MATERIAL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRIFANS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & trifans__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TRIFANS, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__trifans()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__trifans();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__trifans( void* attributeData )
{
    trifans__AttributeData* typedAttributeData = static_cast<trifans__AttributeData*>(attributeData);

    typedAttributeData->~trifans__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const tristrips__AttributeData tristrips__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__tristrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__tristrips( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

tristrips__AttributeData* attributeData = newData<tristrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRISTRIPS,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= tristrips__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->material, strlen(attributeData->material));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TRISTRIPS,
            HASH_ATTRIBUTE_MATERIAL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRISTRIPS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & tristrips__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TRISTRIPS, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__tristrips()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__tristrips();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__tristrips( void* attributeData )
{
    tristrips__AttributeData* typedAttributeData = static_cast<tristrips__AttributeData*>(attributeData);

    typedAttributeData->~tristrips__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mesh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mesh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mesh( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mesh()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mesh();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mesh( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const spline__AttributeData spline__AttributeData::DEFAULT = {false};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__spline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__spline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__spline( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

spline__AttributeData* attributeData = newData<spline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLOSED:
    {
bool failed;
attributeData->closed = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SPLINE,
        HASH_ATTRIBUTE_CLOSED,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SPLINE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__spline()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__spline();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__spline( void* attributeData )
{
    spline__AttributeData* typedAttributeData = static_cast<spline__AttributeData*>(attributeData);

    typedAttributeData->~spline__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__spline_type____control_vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__spline_type____control_vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__spline_type____control_vertices( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__spline_type____control_vertices()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__spline_type____control_vertices();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__spline_type____control_vertices( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__brep( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__brep( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__brep( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__brep()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__brep();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__brep( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__curves( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__curves( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__curves( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__curves()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__curves();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__curves( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const curve__AttributeData curve__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__curve( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__curve( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__curve( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

curve__AttributeData* attributeData = newData<curve__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CURVE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CURVE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__curve()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__curve();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__curve( void* attributeData )
{
    curve__AttributeData* typedAttributeData = static_cast<curve__AttributeData*>(attributeData);

    typedAttributeData->~curve__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__line( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__line( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__line( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__line()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__line();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__line( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__origin____float3_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__origin____float3_type, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__origin____float3_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__origin____float3_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__origin____float3_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__origin____float3_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__origin____float3_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__origin____float3_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__origin____float3_type, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_ORIGIN,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__origin____float3_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__origin____float3_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__origin____float3_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__direction( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__direction, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__direction);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__direction);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__direction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__direction( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__direction()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__direction();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__direction, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_DIRECTION,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__direction );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__direction );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__direction( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__circle( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__circle( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__circle( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__circle()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__circle();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__circle( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__radius____float_type( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__radius____float_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__radius____float_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__radius____float_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__radius____float_type();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__radius____float_type(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_RADIUS, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__radius____float_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ellipse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ellipse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ellipse( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ellipse()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ellipse();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ellipse( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__radius____float2_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__radius____float2_type, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__radius____float2_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__radius____float2_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__radius____float2_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__radius____float2_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__radius____float2_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__radius____float2_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__radius____float2_type, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_RADIUS,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__radius____float2_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__radius____float2_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__radius____float2_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__parabola( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__parabola( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__parabola( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__parabola()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__parabola();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__parabola( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__focal( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__focal( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__focal( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__focal()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__focal();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__focal(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FOCAL, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__focal( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__hyperbola( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__hyperbola( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__hyperbola( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__hyperbola()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__hyperbola();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__hyperbola( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const nurbs__AttributeData nurbs__AttributeData::DEFAULT = {0, 0, false};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__nurbs( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__nurbs( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__nurbs( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

nurbs__AttributeData* attributeData = newData<nurbs__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_DEGREE:
    {
bool failed;
attributeData->degree = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NURBS,
        HASH_ATTRIBUTE_DEGREE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= nurbs__AttributeData::ATTRIBUTE_DEGREE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLOSED:
    {
bool failed;
attributeData->closed = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NURBS,
        HASH_ATTRIBUTE_CLOSED,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NURBS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & nurbs__AttributeData::ATTRIBUTE_DEGREE_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NURBS, HASH_ATTRIBUTE_DEGREE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__nurbs()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__nurbs();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__nurbs( void* attributeData )
{
    nurbs__AttributeData* typedAttributeData = static_cast<nurbs__AttributeData*>(attributeData);

    typedAttributeData->~nurbs__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__nurbs_type____control_vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__nurbs_type____control_vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__nurbs_type____control_vertices( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__nurbs_type____control_vertices()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__nurbs_type____control_vertices();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__nurbs_type____control_vertices( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__orient( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__orient, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__orient);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__orient);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__orient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__orient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__orient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__orient();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__orient, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_ORIENT,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__orient );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__orient );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__orient( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__origin____origin_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__origin____origin_type, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__origin____origin_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__origin____origin_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__origin____origin_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__origin____origin_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__origin____origin_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__origin____origin_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__origin____origin_type, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_ORIGIN,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__origin____origin_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__origin____origin_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__origin____origin_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__surface_curves( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__surface_curves( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__surface_curves( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__surface_curves()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__surface_curves();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__surface_curves( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__surfaces( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__surfaces( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__surfaces( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__surfaces()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__surfaces();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__surfaces( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const surface__AttributeData surface__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__surface( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

surface__AttributeData* attributeData = newData<surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SURFACE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SURFACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__surface()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__surface();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__surface( void* attributeData )
{
    surface__AttributeData* typedAttributeData = static_cast<surface__AttributeData*>(attributeData);

    typedAttributeData->~surface__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__plane( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__plane( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__plane()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__plane();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__plane( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__equation( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__equation, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__equation);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__equation);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__equation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__equation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__equation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__equation();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__equation, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_EQUATION,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__equation );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__equation );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__equation( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sphere( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sphere( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sphere( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sphere()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sphere();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sphere( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__torus( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__torus( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__torus( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__torus()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__torus();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__torus( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__swept_surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__swept_surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__swept_surface( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__swept_surface()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__swept_surface();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__swept_surface( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__axis____float3_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__axis____float3_type, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__axis____float3_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__axis____float3_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__axis____float3_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__axis____float3_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__axis____float3_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__axis____float3_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__axis____float3_type, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_AXIS,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__axis____float3_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__axis____float3_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__axis____float3_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const nurbs_surface__AttributeData nurbs_surface__AttributeData::DEFAULT = {0, 0, false, 0, false};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__nurbs_surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__nurbs_surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__nurbs_surface( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

nurbs_surface__AttributeData* attributeData = newData<nurbs_surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_DEGREE_U:
    {
bool failed;
attributeData->degree_u = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NURBS_SURFACE,
        HASH_ATTRIBUTE_DEGREE_U,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= nurbs_surface__AttributeData::ATTRIBUTE_DEGREE_U_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLOSED_U:
    {
bool failed;
attributeData->closed_u = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NURBS_SURFACE,
        HASH_ATTRIBUTE_CLOSED_U,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_DEGREE_V:
    {
bool failed;
attributeData->degree_v = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NURBS_SURFACE,
        HASH_ATTRIBUTE_DEGREE_V,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= nurbs_surface__AttributeData::ATTRIBUTE_DEGREE_V_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLOSED_V:
    {
bool failed;
attributeData->closed_v = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NURBS_SURFACE,
        HASH_ATTRIBUTE_CLOSED_V,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NURBS_SURFACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & nurbs_surface__AttributeData::ATTRIBUTE_DEGREE_U_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NURBS_SURFACE, HASH_ATTRIBUTE_DEGREE_U, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & nurbs_surface__AttributeData::ATTRIBUTE_DEGREE_V_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NURBS_SURFACE, HASH_ATTRIBUTE_DEGREE_V, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__nurbs_surface()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__nurbs_surface();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__nurbs_surface( void* attributeData )
{
    nurbs_surface__AttributeData* typedAttributeData = static_cast<nurbs_surface__AttributeData*>(attributeData);

    typedAttributeData->~nurbs_surface__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__nurbs_surface_type____control_vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__nurbs_surface_type____control_vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__nurbs_surface_type____control_vertices( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__nurbs_surface_type____control_vertices()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__nurbs_surface_type____control_vertices();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__nurbs_surface_type____control_vertices( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cone( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cone( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cone( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cone()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cone();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cone( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__angle( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__angle( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__angle( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__angle()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__angle();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__angle(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ANGLE, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__angle( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__surface_type____cylinder( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__surface_type____cylinder( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__surface_type____cylinder( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__surface_type____cylinder()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__surface_type____cylinder();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__surface_type____cylinder( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const edges__AttributeData edges__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__edges( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__edges( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__edges( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

edges__AttributeData* attributeData = newData<edges__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toSint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EDGES,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= edges__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EDGES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_EDGES, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & edges__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_EDGES, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__edges()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__edges();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__edges( void* attributeData )
{
    edges__AttributeData* typedAttributeData = static_cast<edges__AttributeData*>(attributeData);

    typedAttributeData->~edges__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const wires__AttributeData wires__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__wires( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__wires( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__wires( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

wires__AttributeData* attributeData = newData<wires__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_WIRES,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= wires__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_WIRES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_WIRES, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & wires__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_WIRES, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__wires()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__wires();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__wires( void* attributeData )
{
    wires__AttributeData* typedAttributeData = static_cast<wires__AttributeData*>(attributeData);

    typedAttributeData->~wires__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const faces__AttributeData faces__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__faces( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__faces( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__faces( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

faces__AttributeData* attributeData = newData<faces__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACES,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= faces__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FACES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_FACES, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & faces__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_FACES, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__faces()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__faces();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__faces( void* attributeData )
{
    faces__AttributeData* typedAttributeData = static_cast<faces__AttributeData*>(attributeData);

    typedAttributeData->~faces__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const pcurves__AttributeData pcurves__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__pcurves( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__pcurves( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__pcurves( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

pcurves__AttributeData* attributeData = newData<pcurves__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PCURVES,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= pcurves__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PCURVES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PCURVES, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & pcurves__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PCURVES, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__pcurves()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__pcurves();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__pcurves( void* attributeData )
{
    pcurves__AttributeData* typedAttributeData = static_cast<pcurves__AttributeData*>(attributeData);

    typedAttributeData->~pcurves__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const shells__AttributeData shells__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__shells( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__shells( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__shells( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

shells__AttributeData* attributeData = newData<shells__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SHELLS,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= shells__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHELLS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SHELLS, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & shells__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SHELLS, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__shells()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__shells();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__shells( void* attributeData )
{
    shells__AttributeData* typedAttributeData = static_cast<shells__AttributeData*>(attributeData);

    typedAttributeData->~shells__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const solids__AttributeData solids__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__solids( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__solids( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__solids( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

solids__AttributeData* attributeData = newData<solids__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {
bool failed;
attributeData->count = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SOLIDS,
        HASH_ATTRIBUTE_COUNT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= solids__AttributeData::ATTRIBUTE_COUNT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SOLIDS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SOLIDS, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & solids__AttributeData::ATTRIBUTE_COUNT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SOLIDS, HASH_ATTRIBUTE_COUNT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__solids()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__solids();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__solids( void* attributeData )
{
    solids__AttributeData* typedAttributeData = static_cast<solids__AttributeData*>(attributeData);

    typedAttributeData->~solids__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_effects__AttributeData library_effects__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_effects( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_effects( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_effects( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_effects__AttributeData* attributeData = newData<library_effects__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_EFFECTS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_effects()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_effects();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_effects( void* attributeData )
{
    library_effects__AttributeData* typedAttributeData = static_cast<library_effects__AttributeData*>(attributeData);

    typedAttributeData->~library_effects__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const effect__AttributeData effect__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__effect( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

effect__AttributeData* attributeData = newData<effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EFFECT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->id )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_EFFECT, HASH_ATTRIBUTE_ID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__effect()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__effect();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__effect( void* attributeData )
{
    effect__AttributeData* typedAttributeData = static_cast<effect__AttributeData*>(attributeData);

    typedAttributeData->~effect__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const annotate__AttributeData annotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__annotate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

annotate__AttributeData* attributeData = newData<annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ANNOTATE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->name )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ANNOTATE, HASH_ATTRIBUTE_NAME, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__annotate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__annotate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__annotate( void* attributeData )
{
    annotate__AttributeData* typedAttributeData = static_cast<annotate__AttributeData*>(attributeData);

    typedAttributeData->~annotate__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2__ValidationData* validationData = (bool2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2, &validate__bool2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2__ValidationData* validationData = (bool2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool2, &validate__bool2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3__ValidationData* validationData = (bool3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3, &validate__bool3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3__ValidationData* validationData = (bool3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool3, &validate__bool3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4__ValidationData* validationData = (bool4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4, &validate__bool4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4__ValidationData* validationData = (bool4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool4, &validate__bool4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2__ValidationData* validationData = (int2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2, &validate__int2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2__ValidationData* validationData = (int2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int2, &validate__int2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3__ValidationData* validationData = (int3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3, &validate__int3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3__ValidationData* validationData = (int3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int3, &validate__int3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4__ValidationData* validationData = (int4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4, &validate__int4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4__ValidationData* validationData = (int4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int4, &validate__int4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float2, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float3, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float4, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float2x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x2__ValidationData* validationData = (float2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x2, &validate__float2x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float2x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float2x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float2x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x2__ValidationData* validationData = (float2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float2x2, &validate__float2x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT2X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float3x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x3, &validate__float3x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float3x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float3x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float3x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float3x3, &validate__float3x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT3X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float4x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x4, &validate__float4x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float4x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float4x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float4x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float4x4, &validate__float4x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT4X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__string( const ParserChar* text, size_t textLength )
{

return mImpl->data__string(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__string( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__string()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__string();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__string( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const newparam____fx_newparam_type__AttributeData newparam____fx_newparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__newparam____fx_newparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__newparam____fx_newparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__newparam____fx_newparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

newparam____fx_newparam_type__AttributeData* attributeData = newData<newparam____fx_newparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEWPARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NEWPARAM, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__newparam____fx_newparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__newparam____fx_newparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__newparam____fx_newparam_type( void* attributeData )
{
    newparam____fx_newparam_type__AttributeData* typedAttributeData = static_cast<newparam____fx_newparam_type__AttributeData*>(attributeData);

    typedAttributeData->~newparam____fx_newparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__semantic____NCName( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__semantic____NCName( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__semantic____NCName( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__semantic____NCName()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__semantic____NCName();
        if ( !validationResult ) return false;

    } // validation
#endif

bool returnValue = true;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
ParserError::ErrorType simpleTypeValidationResult = validate__NCName(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
{
    ParserChar msg[21];
    Utils::fillErrorMsg(msg, mLastIncompleteFragmentInCharacterData, 20);
    if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        simpleTypeValidationResult,
        0,
        msg) )
    {
        returnValue =  false;
    }
}
if (!returnValue)
{
    mStackMemoryManager.deleteObject();
    mLastIncompleteFragmentInCharacterData = 0;
    mEndOfDataInCurrentObjectOnStack = 0;
    return returnValue;
}
    } // validation
#endif
returnValue = mImpl->data__semantic____NCName(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__semantic____NCName( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__modifier( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__modifier( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__modifier( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__modifier()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__modifier();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__fx_modifier_enum parameter = Utils::toEnum<ENUM__fx_modifier_enum, StringHash, ENUM__fx_modifier_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__fx_modifier_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__modifier(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MODIFIER, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__modifier( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
ENUM__fx_modifier_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_modifier_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__fx_modifier_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__fx_modifier_enum, StringHash, ENUM__fx_modifier_enum__COUNT, &toEnum_ENUM__fx_modifier_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__fx_modifier_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_modifier_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__fx_modifier_enum, StringHash, ENUM__fx_modifier_enum__COUNT>(text, textLength, dataFunction, ENUM__fx_modifier_enumMap, baseConversionFunc, &toEnum_ENUM__fx_modifier_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_modifier_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__fx_modifier_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_modifier_enum*, size_t ),
    const std::pair<StringHash, ENUM__fx_modifier_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__fx_modifier_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__fx_modifier_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__fx_modifier_enum, StringHash, ENUM__fx_modifier_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float2x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x1, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float2x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float2x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float2x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float2x1, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT2X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float2x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x3__ValidationData* validationData = (float2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x3, &validate__float2x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float2x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float2x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float2x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x3__ValidationData* validationData = (float2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float2x3, &validate__float2x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT2X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float2x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x4__ValidationData* validationData = (float2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x4, &validate__float2x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float2x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float2x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float2x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float2x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x4__ValidationData* validationData = (float2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float2x4, &validate__float2x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT2X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float2x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float3x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x1, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float3x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float3x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float3x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float3x1, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT3X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float3x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x2__ValidationData* validationData = (float3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x2, &validate__float3x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float3x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float3x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float3x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x2__ValidationData* validationData = (float3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float3x2, &validate__float3x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT3X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float3x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x4__ValidationData* validationData = (float3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x4, &validate__float3x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float3x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float3x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float3x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float3x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x4__ValidationData* validationData = (float3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float3x4, &validate__float3x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT3X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float3x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float4x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x1, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float4x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float4x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float4x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float4x1, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT4X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float4x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x2__ValidationData* validationData = (float4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x2, &validate__float4x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float4x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float4x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float4x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x2__ValidationData* validationData = (float4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float4x2, &validate__float4x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT4X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float4x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x3__ValidationData* validationData = (float4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x3, &validate__float4x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float4x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float4x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float4x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float4x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x3__ValidationData* validationData = (float4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float4x3, &validate__float4x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT4X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float4x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sampler1D( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sampler1D()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sampler1D();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sampler1D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const instance_image__AttributeData instance_image__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_image( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_image__AttributeData* attributeData = newData<instance_image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_IMAGE,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_image__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_IMAGE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_IMAGE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_image__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_image__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_IMAGE, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_image()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_image();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_image( void* attributeData )
{
    instance_image__AttributeData* typedAttributeData = static_cast<instance_image__AttributeData*>(attributeData);

    typedAttributeData->~instance_image__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__wrap_s____fx_sampler_wrap_enum( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__wrap_s____fx_sampler_wrap_enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__wrap_s____fx_sampler_wrap_enum( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__wrap_s____fx_sampler_wrap_enum()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__wrap_s____fx_sampler_wrap_enum();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__fx_sampler_wrap_enum parameter = Utils::toEnum<ENUM__fx_sampler_wrap_enum, StringHash, ENUM__fx_sampler_wrap_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__fx_sampler_wrap_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__wrap_s____fx_sampler_wrap_enum(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_WRAP_S, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__wrap_s____fx_sampler_wrap_enum( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
ENUM__fx_sampler_wrap_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_sampler_wrap_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__fx_sampler_wrap_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__fx_sampler_wrap_enum, StringHash, ENUM__fx_sampler_wrap_enum__COUNT, &toEnum_ENUM__fx_sampler_wrap_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__fx_sampler_wrap_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_sampler_wrap_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__fx_sampler_wrap_enum, StringHash, ENUM__fx_sampler_wrap_enum__COUNT>(text, textLength, dataFunction, ENUM__fx_sampler_wrap_enumMap, baseConversionFunc, &toEnum_ENUM__fx_sampler_wrap_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_sampler_wrap_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__fx_sampler_wrap_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_sampler_wrap_enum*, size_t ),
    const std::pair<StringHash, ENUM__fx_sampler_wrap_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__fx_sampler_wrap_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__fx_sampler_wrap_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__fx_sampler_wrap_enum, StringHash, ENUM__fx_sampler_wrap_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__wrap_t____fx_sampler_wrap_enum( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__wrap_t____fx_sampler_wrap_enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__wrap_t____fx_sampler_wrap_enum( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__wrap_t____fx_sampler_wrap_enum()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__wrap_t____fx_sampler_wrap_enum();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__fx_sampler_wrap_enum parameter = Utils::toEnum<ENUM__fx_sampler_wrap_enum, StringHash, ENUM__fx_sampler_wrap_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__fx_sampler_wrap_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__wrap_t____fx_sampler_wrap_enum(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_WRAP_T, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__wrap_t____fx_sampler_wrap_enum( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__wrap_p( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__wrap_p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__wrap_p( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__wrap_p()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__wrap_p();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__fx_sampler_wrap_enum parameter = Utils::toEnum<ENUM__fx_sampler_wrap_enum, StringHash, ENUM__fx_sampler_wrap_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__fx_sampler_wrap_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__wrap_p(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_WRAP_P, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__wrap_p( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__minfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__minfilter( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__minfilter()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__minfilter();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__fx_sampler_min_filter_enum parameter = Utils::toEnum<ENUM__fx_sampler_min_filter_enum, StringHash, ENUM__fx_sampler_min_filter_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__fx_sampler_min_filter_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__minfilter(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MINFILTER, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__minfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
ENUM__fx_sampler_min_filter_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_sampler_min_filter_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__fx_sampler_min_filter_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__fx_sampler_min_filter_enum, StringHash, ENUM__fx_sampler_min_filter_enum__COUNT, &toEnum_ENUM__fx_sampler_min_filter_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__fx_sampler_min_filter_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_sampler_min_filter_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__fx_sampler_min_filter_enum, StringHash, ENUM__fx_sampler_min_filter_enum__COUNT>(text, textLength, dataFunction, ENUM__fx_sampler_min_filter_enumMap, baseConversionFunc, &toEnum_ENUM__fx_sampler_min_filter_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_sampler_min_filter_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__fx_sampler_min_filter_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_sampler_min_filter_enum*, size_t ),
    const std::pair<StringHash, ENUM__fx_sampler_min_filter_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__fx_sampler_min_filter_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__fx_sampler_min_filter_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__fx_sampler_min_filter_enum, StringHash, ENUM__fx_sampler_min_filter_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__magfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__magfilter( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__magfilter()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__magfilter();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__fx_sampler_mag_filter_enum parameter = Utils::toEnum<ENUM__fx_sampler_mag_filter_enum, StringHash, ENUM__fx_sampler_mag_filter_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__fx_sampler_mag_filter_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__magfilter(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MAGFILTER, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__magfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
ENUM__fx_sampler_mag_filter_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_sampler_mag_filter_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__fx_sampler_mag_filter_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__fx_sampler_mag_filter_enum, StringHash, ENUM__fx_sampler_mag_filter_enum__COUNT, &toEnum_ENUM__fx_sampler_mag_filter_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__fx_sampler_mag_filter_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_sampler_mag_filter_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__fx_sampler_mag_filter_enum, StringHash, ENUM__fx_sampler_mag_filter_enum__COUNT>(text, textLength, dataFunction, ENUM__fx_sampler_mag_filter_enumMap, baseConversionFunc, &toEnum_ENUM__fx_sampler_mag_filter_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_sampler_mag_filter_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__fx_sampler_mag_filter_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_sampler_mag_filter_enum*, size_t ),
    const std::pair<StringHash, ENUM__fx_sampler_mag_filter_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__fx_sampler_mag_filter_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__fx_sampler_mag_filter_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__fx_sampler_mag_filter_enum, StringHash, ENUM__fx_sampler_mag_filter_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mipfilter( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mipfilter( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mipfilter()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mipfilter();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__fx_sampler_mip_filter_enum parameter = Utils::toEnum<ENUM__fx_sampler_mip_filter_enum, StringHash, ENUM__fx_sampler_mip_filter_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__fx_sampler_mip_filter_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__mipfilter(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MIPFILTER, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mipfilter( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
ENUM__fx_sampler_mip_filter_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_sampler_mip_filter_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__fx_sampler_mip_filter_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__fx_sampler_mip_filter_enum, StringHash, ENUM__fx_sampler_mip_filter_enum__COUNT, &toEnum_ENUM__fx_sampler_mip_filter_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__fx_sampler_mip_filter_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_sampler_mip_filter_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__fx_sampler_mip_filter_enum, StringHash, ENUM__fx_sampler_mip_filter_enum__COUNT>(text, textLength, dataFunction, ENUM__fx_sampler_mip_filter_enumMap, baseConversionFunc, &toEnum_ENUM__fx_sampler_mip_filter_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_sampler_mip_filter_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__fx_sampler_mip_filter_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_sampler_mip_filter_enum*, size_t ),
    const std::pair<StringHash, ENUM__fx_sampler_mip_filter_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__fx_sampler_mip_filter_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__fx_sampler_mip_filter_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__fx_sampler_mip_filter_enum, StringHash, ENUM__fx_sampler_mip_filter_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__border_color( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        border_color__ValidationData* validationData = (border_color__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__border_color, &validate__fx_color_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__border_color);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__border_color);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__border_color( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__border_color()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__border_color();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        border_color__ValidationData* validationData = (border_color__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__border_color, &validate__fx_color_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__fx_color_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BORDER_COLOR,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__border_color );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__border_color );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__border_color( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mip_max_level( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mip_max_level( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mip_max_level( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mip_max_level()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mip_max_level();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
uint8 parameter = GeneratedSaxParser::Utils::toUint8((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__mip_max_level(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MIP_MAX_LEVEL, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mip_max_level( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mip_min_level( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mip_min_level( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mip_min_level( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mip_min_level()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mip_min_level();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
uint8 parameter = GeneratedSaxParser::Utils::toUint8((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__mip_min_level(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MIP_MIN_LEVEL, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mip_min_level( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mip_bias( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mip_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mip_bias( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mip_bias()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mip_bias();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__mip_bias(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MIP_BIAS, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mip_bias( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__max_anisotropy( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__max_anisotropy( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__max_anisotropy( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__max_anisotropy()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__max_anisotropy();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
uint32 parameter = GeneratedSaxParser::Utils::toUint32((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__max_anisotropy(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MAX_ANISOTROPY, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__max_anisotropy( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sampler2D____fx_sampler2D_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sampler2D____fx_sampler2D_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sampler2D____fx_sampler2D_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sampler2D____fx_sampler2D_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sampler2D____fx_sampler2D_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sampler2D____fx_sampler2D_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sampler3D( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sampler3D()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sampler3D();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sampler3D( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__samplerCUBE( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__samplerCUBE()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__samplerCUBE();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__samplerCUBE( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__samplerRECT( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__samplerRECT()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__samplerRECT();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__samplerRECT( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__samplerDEPTH( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__samplerDEPTH()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__samplerDEPTH();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__samplerDEPTH( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__enum____string( const ParserChar* text, size_t textLength )
{

return mImpl->data__enum____string(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__enum____string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__enum____string( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__enum____string()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__enum____string();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__enum____string( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_COMMON__AttributeData profile_COMMON__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_COMMON( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_COMMON( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_COMMON( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_COMMON__AttributeData* attributeData = newData<profile_COMMON__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_COMMON, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_COMMON()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_COMMON();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_COMMON( void* attributeData )
{
    profile_COMMON__AttributeData* typedAttributeData = static_cast<profile_COMMON__AttributeData*>(attributeData);

    typedAttributeData->~profile_COMMON__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const newparam____fx_common_newparam_type__AttributeData newparam____fx_common_newparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__newparam____fx_common_newparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__newparam____fx_common_newparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__newparam____fx_common_newparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

newparam____fx_common_newparam_type__AttributeData* attributeData = newData<newparam____fx_common_newparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEWPARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NEWPARAM, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__newparam____fx_common_newparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__newparam____fx_common_newparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__newparam____fx_common_newparam_type( void* attributeData )
{
    newparam____fx_common_newparam_type__AttributeData* typedAttributeData = static_cast<newparam____fx_common_newparam_type__AttributeData*>(attributeData);

    typedAttributeData->~newparam____fx_common_newparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_common_type____technique__AttributeData profile_common_type____technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_common_type____technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_common_type____technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_common_type____technique( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_common_type____technique__AttributeData* attributeData = newData<profile_common_type____technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TECHNIQUE, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_common_type____technique()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_common_type____technique();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_common_type____technique( void* attributeData )
{
    profile_common_type____technique__AttributeData* typedAttributeData = static_cast<profile_common_type____technique__AttributeData*>(attributeData);

    typedAttributeData->~profile_common_type____technique__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_COMMON__technique__constant( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_COMMON__technique__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_COMMON__technique__constant( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_COMMON__technique__constant()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_COMMON__technique__constant();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_COMMON__technique__constant( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__emission( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__emission()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__emission();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__emission( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const fx_common_color_or_texture_type____color__AttributeData fx_common_color_or_texture_type____color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fx_common_color_or_texture_type____color( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        border_color__ValidationData* validationData = (border_color__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fx_common_color_or_texture_type____color, &validate__fx_color_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fx_common_color_or_texture_type____color);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fx_common_color_or_texture_type____color);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fx_common_color_or_texture_type____color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fx_common_color_or_texture_type____color( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

fx_common_color_or_texture_type____color__AttributeData* attributeData = newData<fx_common_color_or_texture_type____color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fx_common_color_or_texture_type____color()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fx_common_color_or_texture_type____color();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        border_color__ValidationData* validationData = (border_color__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fx_common_color_or_texture_type____color, &validate__fx_color_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__fx_color_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_COLOR,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fx_common_color_or_texture_type____color );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fx_common_color_or_texture_type____color );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fx_common_color_or_texture_type____color( void* attributeData )
{
    fx_common_color_or_texture_type____color__AttributeData* typedAttributeData = static_cast<fx_common_color_or_texture_type____color__AttributeData*>(attributeData);

    typedAttributeData->~fx_common_color_or_texture_type____color__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const fx_common_color_or_texture_type____param__AttributeData fx_common_color_or_texture_type____param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fx_common_color_or_texture_type____param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fx_common_color_or_texture_type____param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fx_common_color_or_texture_type____param( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

fx_common_color_or_texture_type____param__AttributeData* attributeData = newData<fx_common_color_or_texture_type____param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->ref, strlen(attributeData->ref));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARAM,
            HASH_ATTRIBUTE_REF,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fx_common_color_or_texture_type____param()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fx_common_color_or_texture_type____param();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fx_common_color_or_texture_type____param( void* attributeData )
{
    fx_common_color_or_texture_type____param__AttributeData* typedAttributeData = static_cast<fx_common_color_or_texture_type____param__AttributeData*>(attributeData);

    typedAttributeData->~fx_common_color_or_texture_type____param__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const texture__AttributeData texture__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture__AttributeData* attributeData = newData<texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->texture, strlen(attributeData->texture));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURE,
            HASH_ATTRIBUTE_TEXTURE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->texcoord, strlen(attributeData->texcoord));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURE,
            HASH_ATTRIBUTE_TEXCOORD,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->texture )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TEXTURE, HASH_ATTRIBUTE_TEXTURE, 0 ) )
        return false;
}
if ( !attributeData->texcoord )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TEXTURE, HASH_ATTRIBUTE_TEXCOORD, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture( void* attributeData )
{
    texture__AttributeData* typedAttributeData = static_cast<texture__AttributeData*>(attributeData);

    typedAttributeData->~texture__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__reflective( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__reflective()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__reflective();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__reflective( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__reflectivity( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__reflectivity()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__reflectivity();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__reflectivity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const fx_common_float_or_param_type____float__AttributeData fx_common_float_or_param_type____float__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fx_common_float_or_param_type____float( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fx_common_float_or_param_type____float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fx_common_float_or_param_type____float( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

fx_common_float_or_param_type____float__AttributeData* attributeData = newData<fx_common_float_or_param_type____float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FLOAT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FLOAT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fx_common_float_or_param_type____float()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fx_common_float_or_param_type____float();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__fx_common_float_or_param_type____float(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FLOAT, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fx_common_float_or_param_type____float( void* attributeData )
{
    fx_common_float_or_param_type____float__AttributeData* typedAttributeData = static_cast<fx_common_float_or_param_type____float__AttributeData*>(attributeData);

    typedAttributeData->~fx_common_float_or_param_type____float__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const fx_common_float_or_param_type____param__AttributeData fx_common_float_or_param_type____param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fx_common_float_or_param_type____param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fx_common_float_or_param_type____param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fx_common_float_or_param_type____param( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

fx_common_float_or_param_type____param__AttributeData* attributeData = newData<fx_common_float_or_param_type____param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->ref, strlen(attributeData->ref));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARAM,
            HASH_ATTRIBUTE_REF,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fx_common_float_or_param_type____param()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fx_common_float_or_param_type____param();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fx_common_float_or_param_type____param( void* attributeData )
{
    fx_common_float_or_param_type____param__AttributeData* typedAttributeData = static_cast<fx_common_float_or_param_type____param__AttributeData*>(attributeData);

    typedAttributeData->~fx_common_float_or_param_type____param__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const transparent__AttributeData transparent__AttributeData::DEFAULT = {ENUM__fx_opaque_enum__A_ONE};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__transparent( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

transparent__AttributeData* attributeData = newData<transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {
bool failed;
attributeData->opaque = Utils::toEnum<ENUM__fx_opaque_enum, StringHash, ENUM__fx_opaque_enum__COUNT>(attributeValue, failed, ENUM__fx_opaque_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRANSPARENT,
        HASH_ATTRIBUTE_OPAQUE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRANSPARENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__transparent()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__transparent();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__transparent( void* attributeData )
{
    transparent__AttributeData* typedAttributeData = static_cast<transparent__AttributeData*>(attributeData);

    typedAttributeData->~transparent__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__fx_opaque_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_opaque_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__fx_opaque_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__fx_opaque_enum, StringHash, ENUM__fx_opaque_enum__COUNT, &toEnum_ENUM__fx_opaque_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__fx_opaque_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_opaque_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__fx_opaque_enum, StringHash, ENUM__fx_opaque_enum__COUNT>(text, textLength, dataFunction, ENUM__fx_opaque_enumMap, baseConversionFunc, &toEnum_ENUM__fx_opaque_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_opaque_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__fx_opaque_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_opaque_enum*, size_t ),
    const std::pair<StringHash, ENUM__fx_opaque_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__fx_opaque_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__fx_opaque_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__fx_opaque_enum, StringHash, ENUM__fx_opaque_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__transparency( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__transparency()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__transparency();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__transparency( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__index_of_refraction( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__index_of_refraction()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__index_of_refraction();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__index_of_refraction( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__lambert( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__lambert( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__lambert( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__lambert()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__lambert();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__lambert( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ambient____fx_common_color_or_texture_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ambient____fx_common_color_or_texture_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ambient____fx_common_color_or_texture_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ambient____fx_common_color_or_texture_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ambient____fx_common_color_or_texture_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ambient____fx_common_color_or_texture_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__diffuse( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__diffuse()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__diffuse();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__diffuse( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__phong( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__phong( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__phong( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__phong()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__phong();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__phong( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__specular( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__specular()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__specular();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__specular( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__shininess( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__shininess()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__shininess();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__shininess( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__blinn( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__blinn( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__blinn( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__blinn()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__blinn();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__blinn( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_BRIDGE__AttributeData profile_BRIDGE__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_BRIDGE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_BRIDGE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_BRIDGE( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_BRIDGE__AttributeData* attributeData = newData<profile_BRIDGE__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->platform, strlen(attributeData->platform));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROFILE_BRIDGE,
            HASH_ATTRIBUTE_PLATFORM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PROFILE_BRIDGE,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_BRIDGE__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_BRIDGE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_BRIDGE__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & profile_BRIDGE__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PROFILE_BRIDGE, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_BRIDGE()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_BRIDGE();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_BRIDGE( void* attributeData )
{
    profile_BRIDGE__AttributeData* typedAttributeData = static_cast<profile_BRIDGE__AttributeData*>(attributeData);

    typedAttributeData->~profile_BRIDGE__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__AttributeData profile_GLES2__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__AttributeData* attributeData = newData<profile_GLES2__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_LANGUAGE:
    {

attributeData->language = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->language, strlen(attributeData->language));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROFILE_GLES2,
            HASH_ATTRIBUTE_LANGUAGE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_PLATFORMS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->platforms, &validate__Name, HASH_ELEMENT_PROFILE_GLES2, HASH_ATTRIBUTE_PLATFORMS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->platforms);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->platforms);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PROFILE_GLES2,
        HASH_ATTRIBUTE_PLATFORMS,
        attributeValue))
{
    return false;
}

if ( !failed )
    attributeData->present_attributes |= profile_GLES2__AttributeData::ATTRIBUTE_PLATFORMS_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLES2, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES2__AttributeData::ATTRIBUTE_PLATFORMS_PRESENT) == 0)
{
    attributeData->platforms = GeneratedSaxParser::XSList<ParserString>();
}
if ( !attributeData->language )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PROFILE_GLES2, HASH_ATTRIBUTE_LANGUAGE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2( void* attributeData )
{
    profile_GLES2__AttributeData* typedAttributeData = static_cast<profile_GLES2__AttributeData*>(attributeData);
    if (typedAttributeData->platforms.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES2__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const include__AttributeData include__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__include( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

include__AttributeData* attributeData = newData<include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INCLUDE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INCLUDE,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= include__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INCLUDE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & include__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INCLUDE, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & include__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INCLUDE, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__include()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__include();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__include( void* attributeData )
{
    include__AttributeData* typedAttributeData = static_cast<include__AttributeData*>(attributeData);

    typedAttributeData->~include__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const code__AttributeData code__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__code( const ParserChar* text, size_t textLength )
{

return mImpl->data__code(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__code( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

code__AttributeData* attributeData = newData<code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CODE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CODE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__code()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__code();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__code( void* attributeData )
{
    code__AttributeData* typedAttributeData = static_cast<code__AttributeData*>(attributeData);

    typedAttributeData->~code__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_gles2_type____newparam__AttributeData profile_gles2_type____newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_gles2_type____newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_gles2_type____newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_gles2_type____newparam( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_gles2_type____newparam__AttributeData* attributeData = newData<profile_gles2_type____newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEWPARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NEWPARAM, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_gles2_type____newparam()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_gles2_type____newparam();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_gles2_type____newparam( void* attributeData )
{
    profile_gles2_type____newparam__AttributeData* typedAttributeData = static_cast<profile_gles2_type____newparam__AttributeData*>(attributeData);

    typedAttributeData->~profile_gles2_type____newparam__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bvec2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2__ValidationData* validationData = (bool2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec2, &validate__bool2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec2);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bvec2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bvec2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bvec2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bvec2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2__ValidationData* validationData = (bool2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bvec2, &validate__bool2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BVEC2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bvec2 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bvec2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bvec2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bvec3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3__ValidationData* validationData = (bool3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec3, &validate__bool3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec3);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bvec3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bvec3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bvec3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bvec3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3__ValidationData* validationData = (bool3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bvec3, &validate__bool3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BVEC3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bvec3 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bvec3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bvec3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bvec4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4__ValidationData* validationData = (bool4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec4, &validate__bool4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec4);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bvec4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bvec4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bvec4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bvec4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bvec4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4__ValidationData* validationData = (bool4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bvec4, &validate__bool4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BVEC4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bvec4 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bvec4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bvec4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__vec2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec2, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__vec2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__vec2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__vec2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__vec2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__vec2, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_VEC2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__vec2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__vec2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__vec2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__vec3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec3, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__vec3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__vec3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__vec3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__vec3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__vec3, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_VEC3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__vec3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__vec3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__vec3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__vec4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec4, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__vec4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__vec4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__vec4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__vec4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__vec4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__vec4, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_VEC4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__vec4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__vec4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__vec4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mat2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x2__ValidationData* validationData = (float2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat2, &validate__float2x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mat2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mat2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mat2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mat2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x2__ValidationData* validationData = (float2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__mat2, &validate__float2x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_MAT2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__mat2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__mat2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mat2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mat3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat3, &validate__float3x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mat3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mat3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mat3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mat3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__mat3, &validate__float3x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_MAT3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__mat3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__mat3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mat3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mat4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat4, &validate__float4x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__mat4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mat4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mat4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mat4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mat4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__mat4, &validate__float4x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_MAT4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__mat4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__mat4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mat4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ivec2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2__ValidationData* validationData = (int2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec2, &validate__int2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec2);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ivec2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ivec2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ivec2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ivec2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2__ValidationData* validationData = (int2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__ivec2, &validate__int2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_IVEC2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__ivec2 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__ivec2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ivec2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ivec3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3__ValidationData* validationData = (int3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec3, &validate__int3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec3);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ivec3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ivec3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ivec3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ivec3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3__ValidationData* validationData = (int3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__ivec3, &validate__int3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_IVEC3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__ivec3 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__ivec3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ivec3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ivec4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4__ValidationData* validationData = (int4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec4, &validate__int4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec4);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__ivec4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ivec4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ivec4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ivec4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ivec4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4__ValidationData* validationData = (int4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__ivec4, &validate__int4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_IVEC4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__ivec4 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__ivec4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ivec4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__enum____gl_enumeration_type( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__enum____gl_enumeration_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__enum____gl_enumeration_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__enum____gl_enumeration_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__enum____gl_enumeration_type();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
UNION__gl_enumeration_type parameter = toUnion_UNION__gl_enumeration_type( mLastIncompleteFragmentInCharacterData, (size_t)(mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData), failed );
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__enum____gl_enumeration_type(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ENUM, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__enum____gl_enumeration_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
ENUM__gl_blend_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_blend_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_blend_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT, &toEnum_ENUM__gl_blend_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_blend_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_blend_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_blend_enumMap, baseConversionFunc, &toEnum_ENUM__gl_blend_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_blend_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_blend_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_blend_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_blend_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_blend_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_blend_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_face_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_face_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_face_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT, &toEnum_ENUM__gl_face_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_face_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_face_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_face_enumMap, baseConversionFunc, &toEnum_ENUM__gl_face_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_face_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_face_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_face_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_face_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_face_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_face_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_blend_equation_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_blend_equation_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_blend_equation_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT, &toEnum_ENUM__gl_blend_equation_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_blend_equation_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_blend_equation_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_blend_equation_enumMap, baseConversionFunc, &toEnum_ENUM__gl_blend_equation_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_blend_equation_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_blend_equation_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_blend_equation_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_blend_equation_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_blend_equation_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_blend_equation_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_func_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_func_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_func_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT, &toEnum_ENUM__gl_func_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_func_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_func_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_func_enumMap, baseConversionFunc, &toEnum_ENUM__gl_func_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_func_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_func_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_func_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_func_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_func_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_func_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_stencil_op_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_stencil_op_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_stencil_op_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT, &toEnum_ENUM__gl_stencil_op_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_stencil_op_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_stencil_op_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_stencil_op_enumMap, baseConversionFunc, &toEnum_ENUM__gl_stencil_op_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_stencil_op_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_stencil_op_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_stencil_op_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_stencil_op_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_stencil_op_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_stencil_op_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_material_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_material_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_material_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_material_enum, StringHash, ENUM__gl_material_enum__COUNT, &toEnum_ENUM__gl_material_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_material_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_material_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_material_enum, StringHash, ENUM__gl_material_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_material_enumMap, baseConversionFunc, &toEnum_ENUM__gl_material_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_material_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_material_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_material_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_material_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_material_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_material_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_material_enum, StringHash, ENUM__gl_material_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_fog_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_fog_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_fog_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_fog_enum, StringHash, ENUM__gl_fog_enum__COUNT, &toEnum_ENUM__gl_fog_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_fog_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_fog_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_fog_enum, StringHash, ENUM__gl_fog_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_fog_enumMap, baseConversionFunc, &toEnum_ENUM__gl_fog_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_fog_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_fog_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_fog_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_fog_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_fog_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_fog_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_fog_enum, StringHash, ENUM__gl_fog_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_fog_coord_src_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_fog_coord_src_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_fog_coord_src_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_fog_coord_src_enum, StringHash, ENUM__gl_fog_coord_src_enum__COUNT, &toEnum_ENUM__gl_fog_coord_src_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_fog_coord_src_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_fog_coord_src_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_fog_coord_src_enum, StringHash, ENUM__gl_fog_coord_src_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_fog_coord_src_enumMap, baseConversionFunc, &toEnum_ENUM__gl_fog_coord_src_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_fog_coord_src_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_fog_coord_src_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_fog_coord_src_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_fog_coord_src_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_fog_coord_src_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_fog_coord_src_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_fog_coord_src_enum, StringHash, ENUM__gl_fog_coord_src_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_front_face_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_front_face_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_front_face_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_front_face_enum, StringHash, ENUM__gl_front_face_enum__COUNT, &toEnum_ENUM__gl_front_face_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_front_face_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_front_face_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_front_face_enum, StringHash, ENUM__gl_front_face_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_front_face_enumMap, baseConversionFunc, &toEnum_ENUM__gl_front_face_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_front_face_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_front_face_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_front_face_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_front_face_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_front_face_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_front_face_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_front_face_enum, StringHash, ENUM__gl_front_face_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_light_model_color_control_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_light_model_color_control_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_light_model_color_control_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_light_model_color_control_enum, StringHash, ENUM__gl_light_model_color_control_enum__COUNT, &toEnum_ENUM__gl_light_model_color_control_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_light_model_color_control_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_light_model_color_control_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_light_model_color_control_enum, StringHash, ENUM__gl_light_model_color_control_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_light_model_color_control_enumMap, baseConversionFunc, &toEnum_ENUM__gl_light_model_color_control_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_light_model_color_control_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_light_model_color_control_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_light_model_color_control_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_light_model_color_control_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_light_model_color_control_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_light_model_color_control_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_light_model_color_control_enum, StringHash, ENUM__gl_light_model_color_control_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_logic_op_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_logic_op_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_logic_op_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_logic_op_enum, StringHash, ENUM__gl_logic_op_enum__COUNT, &toEnum_ENUM__gl_logic_op_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_logic_op_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_logic_op_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_logic_op_enum, StringHash, ENUM__gl_logic_op_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_logic_op_enumMap, baseConversionFunc, &toEnum_ENUM__gl_logic_op_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_logic_op_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_logic_op_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_logic_op_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_logic_op_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_logic_op_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_logic_op_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_logic_op_enum, StringHash, ENUM__gl_logic_op_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_polygon_mode_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_polygon_mode_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_polygon_mode_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_polygon_mode_enum, StringHash, ENUM__gl_polygon_mode_enum__COUNT, &toEnum_ENUM__gl_polygon_mode_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_polygon_mode_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_polygon_mode_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_polygon_mode_enum, StringHash, ENUM__gl_polygon_mode_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_polygon_mode_enumMap, baseConversionFunc, &toEnum_ENUM__gl_polygon_mode_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_polygon_mode_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_polygon_mode_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_polygon_mode_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_polygon_mode_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_polygon_mode_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_polygon_mode_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_polygon_mode_enum, StringHash, ENUM__gl_polygon_mode_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gl_shade_model_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_shade_model_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gl_shade_model_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gl_shade_model_enum, StringHash, ENUM__gl_shade_model_enum__COUNT, &toEnum_ENUM__gl_shade_model_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gl_shade_model_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_shade_model_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gl_shade_model_enum, StringHash, ENUM__gl_shade_model_enum__COUNT>(text, textLength, dataFunction, ENUM__gl_shade_model_enumMap, baseConversionFunc, &toEnum_ENUM__gl_shade_model_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gl_shade_model_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gl_shade_model_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gl_shade_model_enum*, size_t ),
    const std::pair<StringHash, ENUM__gl_shade_model_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gl_shade_model_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gl_shade_model_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gl_shade_model_enum, StringHash, ENUM__gl_shade_model_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
UNION__gl_enumeration_type ColladaParserAutoGen15Private::toUnionPrefix_UNION__gl_enumeration_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed
)
{
    return toDataPrefix<UNION__gl_enumeration_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, toUnion_UNION__gl_enumeration_type);
}

//---------------------------------------------------------------------
const profile_GLES2__newparam__usertype__AttributeData profile_GLES2__newparam__usertype__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__newparam__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__newparam__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__newparam__usertype( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__newparam__usertype__AttributeData* attributeData = newData<profile_GLES2__newparam__usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPENAME:
    {

attributeData->_typename = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_USERTYPE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->_typename )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_USERTYPE, HASH_ATTRIBUTE_TYPENAME, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__newparam__usertype()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__newparam__usertype();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__newparam__usertype( void* attributeData )
{
    profile_GLES2__newparam__usertype__AttributeData* typedAttributeData = static_cast<profile_GLES2__newparam__usertype__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__newparam__usertype__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__newparam__usertype__setparam__AttributeData profile_GLES2__newparam__usertype__setparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__newparam__usertype__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__newparam__usertype__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__newparam__usertype__setparam( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__newparam__usertype__setparam__AttributeData* attributeData = newData<profile_GLES2__newparam__usertype__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SETPARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__newparam__usertype__setparam()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__newparam__usertype__setparam();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__newparam__usertype__setparam( void* attributeData )
{
    profile_GLES2__newparam__usertype__setparam__AttributeData* typedAttributeData = static_cast<profile_GLES2__newparam__usertype__setparam__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__newparam__usertype__setparam__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__newparam__usertype__setparam__array__AttributeData profile_GLES2__newparam__usertype__setparam__array__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__newparam__usertype__setparam__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__newparam__usertype__setparam__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__newparam__usertype__setparam__array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__newparam__usertype__setparam__array__AttributeData* attributeData = newData<profile_GLES2__newparam__usertype__setparam__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARRAY,
        HASH_ATTRIBUTE_LENGTH,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__positiveInteger(attributeData->length);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARRAY,
            HASH_ATTRIBUTE_LENGTH,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES2__newparam__usertype__setparam__array__AttributeData::ATTRIBUTE_LENGTH_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLES2__newparam__usertype__setparam__array__AttributeData::ATTRIBUTE_LENGTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ARRAY, HASH_ATTRIBUTE_LENGTH, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__newparam__usertype__setparam__array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__newparam__usertype__setparam__array();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__newparam__usertype__setparam__array( void* attributeData )
{
    profile_GLES2__newparam__usertype__setparam__array__AttributeData* typedAttributeData = static_cast<profile_GLES2__newparam__usertype__setparam__array__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__newparam__usertype__setparam__array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_gles2_type____technique__AttributeData profile_gles2_type____technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_gles2_type____technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_gles2_type____technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_gles2_type____technique( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_gles2_type____technique__AttributeData* attributeData = newData<profile_gles2_type____technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TECHNIQUE, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_gles2_type____technique()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_gles2_type____technique();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_gles2_type____technique( void* attributeData )
{
    profile_gles2_type____technique__AttributeData* typedAttributeData = static_cast<profile_gles2_type____technique__AttributeData*>(attributeData);

    typedAttributeData->~profile_gles2_type____technique__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const pass____gles2_pass_type__AttributeData pass____gles2_pass_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__pass____gles2_pass_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__pass____gles2_pass_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__pass____gles2_pass_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

pass____gles2_pass_type__AttributeData* attributeData = newData<pass____gles2_pass_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PASS,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__pass____gles2_pass_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__pass____gles2_pass_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__pass____gles2_pass_type( void* attributeData )
{
    pass____gles2_pass_type__AttributeData* typedAttributeData = static_cast<pass____gles2_pass_type__AttributeData*>(attributeData);

    typedAttributeData->~pass____gles2_pass_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__gles2_pass_type____states( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__gles2_pass_type____states( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__gles2_pass_type____states( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__gles2_pass_type____states()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__gles2_pass_type____states();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__gles2_pass_type____states( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_color__AttributeData profile_GLES2__technique__pass__states__blend_color__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_color( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_color__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_BLEND_COLOR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BLEND_COLOR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BLEND_COLOR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__blend_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLEND_COLOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES2__technique__pass__states__blend_color__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__blend_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_color()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_color();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_color( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_color__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_color__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES2__technique__pass__states__blend_color__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_equation__AttributeData profile_GLES2__technique__pass__states__blend_equation__AttributeData::DEFAULT = {ENUM__gl_blend_equation_enum__FUNC_ADD, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_equation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_equation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_equation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_equation__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_equation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_equation_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BLEND_EQUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLEND_EQUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_equation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_equation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_equation( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_equation__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_equation__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_equation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_equation_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_equation_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_equation_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_equation_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_equation_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_equation_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_equation_separate__rgb__AttributeData profile_GLES2__technique__pass__states__blend_equation_separate__rgb__AttributeData::DEFAULT = {ENUM__gl_blend_equation_enum__FUNC_ADD, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_equation_separate__rgb( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_equation_separate__rgb( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_equation_separate__rgb( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_equation_separate__rgb__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_equation_separate__rgb__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_equation_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RGB,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RGB, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_equation_separate__rgb()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_equation_separate__rgb();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_equation_separate__rgb( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_equation_separate__rgb__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_equation_separate__rgb__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_equation_separate__rgb__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_equation_separate__alpha__AttributeData profile_GLES2__technique__pass__states__blend_equation_separate__alpha__AttributeData::DEFAULT = {ENUM__gl_blend_equation_enum__FUNC_ADD, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_equation_separate__alpha( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_equation_separate__alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_equation_separate__alpha( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_equation_separate__alpha__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_equation_separate__alpha__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_equation_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ALPHA,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_equation_separate__alpha()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_equation_separate__alpha();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_equation_separate__alpha( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_equation_separate__alpha__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_equation_separate__alpha__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_equation_separate__alpha__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_func__src__AttributeData profile_GLES2__technique__pass__states__blend_func__src__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ONE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_func__src( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_func__src( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_func__src( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_func__src__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_func__src__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SRC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SRC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_func__src()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_func__src();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_func__src( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_func__src__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_func__src__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_func__src__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_func__dest__AttributeData profile_GLES2__technique__pass__states__blend_func__dest__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ZERO, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_func__dest( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_func__dest( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_func__dest( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_func__dest__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_func__dest__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEST,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEST, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_func__dest()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_func__dest();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_func__dest( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_func__dest__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_func__dest__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_func__dest__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_func_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_func_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_func_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_func_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_func_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_func_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_func_separate__src_rgb__AttributeData profile_GLES2__technique__pass__states__blend_func_separate__src_rgb__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ONE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_func_separate__src_rgb( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_func_separate__src_rgb( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_func_separate__src_rgb( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_func_separate__src_rgb__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_func_separate__src_rgb__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SRC_RGB,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SRC_RGB, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_func_separate__src_rgb()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_func_separate__src_rgb();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_func_separate__src_rgb( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_func_separate__src_rgb__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_func_separate__src_rgb__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_func_separate__src_rgb__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb__AttributeData profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ZERO, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEST_RGB,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEST_RGB, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_func_separate__dest_rgb__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_func_separate__src_alpha__AttributeData profile_GLES2__technique__pass__states__blend_func_separate__src_alpha__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ONE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_func_separate__src_alpha( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_func_separate__src_alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_func_separate__src_alpha( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_func_separate__src_alpha__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_func_separate__src_alpha__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SRC_ALPHA,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SRC_ALPHA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_func_separate__src_alpha()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_func_separate__src_alpha();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_func_separate__src_alpha( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_func_separate__src_alpha__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_func_separate__src_alpha__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_func_separate__src_alpha__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha__AttributeData profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ZERO, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEST_ALPHA,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEST_ALPHA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_func_separate__dest_alpha__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__color_mask__AttributeData profile_GLES2__technique__pass__states__color_mask__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<bool>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__color_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__color_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__color_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__color_mask__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__color_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2BoolList(attributeValue, attributeData->value, 0, HASH_ELEMENT_COLOR_MASK, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2BoolList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2BoolList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__bool4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_MASK,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__color_mask__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES2__technique__pass__states__color_mask__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2BoolList("true true true true", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__color_mask__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__color_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__color_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__color_mask( void* attributeData )
{
    profile_GLES2__technique__pass__states__color_mask__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__color_mask__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES2__technique__pass__states__color_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__cull_face__AttributeData profile_GLES2__technique__pass__states__cull_face__AttributeData::DEFAULT = {ENUM__gl_face_enum__BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__cull_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__cull_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__cull_face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__cull_face__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__cull_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CULL_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CULL_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__cull_face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__cull_face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__cull_face( void* attributeData )
{
    profile_GLES2__technique__pass__states__cull_face__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__cull_face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__cull_face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__depth_func__AttributeData profile_GLES2__technique__pass__states__depth_func__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__depth_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__depth_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__depth_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__depth_func__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__depth_func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_FUNC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_FUNC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__depth_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__depth_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__depth_func( void* attributeData )
{
    profile_GLES2__technique__pass__states__depth_func__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__depth_func__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__depth_func__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__depth_mask__AttributeData profile_GLES2__technique__pass__states__depth_mask__AttributeData::DEFAULT = {true, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__depth_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__depth_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__depth_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__depth_mask__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__depth_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__depth_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__depth_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__depth_mask( void* attributeData )
{
    profile_GLES2__technique__pass__states__depth_mask__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__depth_mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__depth_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__depth_range__AttributeData profile_GLES2__technique__pass__states__depth_range__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__depth_range( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__depth_range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__depth_range( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__depth_range__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__depth_range__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_DEPTH_RANGE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_RANGE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_RANGE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_RANGE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES2__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__depth_range()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__depth_range();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__depth_range( void* attributeData )
{
    profile_GLES2__technique__pass__states__depth_range__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__depth_range__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES2__technique__pass__states__depth_range__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__front_face__AttributeData profile_GLES2__technique__pass__states__front_face__AttributeData::DEFAULT = {ENUM__gl_front_face_enum__CCW, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__front_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__front_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__front_face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__front_face__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__front_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_front_face_enum, StringHash, ENUM__gl_front_face_enum__COUNT>(attributeValue, failed, ENUM__gl_front_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FRONT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRONT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__front_face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__front_face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__front_face( void* attributeData )
{
    profile_GLES2__technique__pass__states__front_face__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__front_face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__front_face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__line_width__AttributeData profile_GLES2__technique__pass__states__line_width__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__line_width( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__line_width( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__line_width( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__line_width__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__line_width__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINE_WIDTH,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_WIDTH, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__line_width()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__line_width();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__line_width( void* attributeData )
{
    profile_GLES2__technique__pass__states__line_width__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__line_width__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__line_width__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__polygon_offset__AttributeData profile_GLES2__technique__pass__states__polygon_offset__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__polygon_offset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__polygon_offset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__polygon_offset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__polygon_offset__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__polygon_offset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_POLYGON_OFFSET, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_OFFSET,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES2__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__polygon_offset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__polygon_offset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__polygon_offset( void* attributeData )
{
    profile_GLES2__technique__pass__states__polygon_offset__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__polygon_offset__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES2__technique__pass__states__polygon_offset__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__point_size__AttributeData profile_GLES2__technique__pass__states__point_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__point_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__point_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__point_size( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__point_size__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__point_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SIZE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__point_size()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__point_size();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__point_size( void* attributeData )
{
    profile_GLES2__technique__pass__states__point_size__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__point_size__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__point_size__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sample_coverage( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sample_coverage( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sample_coverage( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sample_coverage()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sample_coverage();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sample_coverage( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const sample_coverage__value__AttributeData sample_coverage__value__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sample_coverage__value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sample_coverage__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sample_coverage__value( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sample_coverage__value__AttributeData* attributeData = newData<sample_coverage__value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VALUE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sample_coverage__value__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VALUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sample_coverage__value()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sample_coverage__value();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sample_coverage__value( void* attributeData )
{
    sample_coverage__value__AttributeData* typedAttributeData = static_cast<sample_coverage__value__AttributeData*>(attributeData);

    typedAttributeData->~sample_coverage__value__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const invert__AttributeData invert__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__invert( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__invert( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__invert( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

invert__AttributeData* attributeData = newData<invert__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INVERT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= invert__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INVERT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__invert()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__invert();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__invert( void* attributeData )
{
    invert__AttributeData* typedAttributeData = static_cast<invert__AttributeData*>(attributeData);

    typedAttributeData->~invert__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__scissor__AttributeData profile_GLES2__technique__pass__states__scissor__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<sint64>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__scissor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__scissor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__scissor( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__scissor__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__scissor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value, 0, HASH_ELEMENT_SCISSOR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCISSOR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__int4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCISSOR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES2__technique__pass__states__scissor__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCISSOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES2__technique__pass__states__scissor__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    attributeData->value = GeneratedSaxParser::XSList<sint64>();
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__scissor()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__scissor();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__scissor( void* attributeData )
{
    profile_GLES2__technique__pass__states__scissor__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__scissor__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES2__technique__pass__states__scissor__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_func__func__AttributeData profile_GLES2__technique__pass__states__stencil_func__func__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func__func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_func__func__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FUNC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FUNC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func__func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func__func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func__func( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_func__func__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_func__func__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_func__func__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_func__ref__AttributeData profile_GLES2__technique__pass__states__stencil_func__ref__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func__ref( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func__ref( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func__ref( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_func__ref__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_func__ref__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REF,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func__ref()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func__ref();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func__ref( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_func__ref__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_func__ref__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_func__ref__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_func__mask__AttributeData profile_GLES2__technique__pass__states__stencil_func__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func__mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_func__mask__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_func__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func__mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func__mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func__mask( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_func__mask__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_func__mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_func__mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_func_separate__front__AttributeData profile_GLES2__technique__pass__states__stencil_func_separate__front__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func_separate__front( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func_separate__front( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func_separate__front( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_func_separate__front__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_func_separate__front__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FRONT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRONT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func_separate__front()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func_separate__front();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func_separate__front( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_func_separate__front__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_func_separate__front__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_func_separate__front__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_func_separate__back__AttributeData profile_GLES2__technique__pass__states__stencil_func_separate__back__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func_separate__back( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func_separate__back( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func_separate__back( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_func_separate__back__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_func_separate__back__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BACK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BACK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func_separate__back()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func_separate__back();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func_separate__back( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_func_separate__back__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_func_separate__back__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_func_separate__back__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_func_separate__ref__AttributeData profile_GLES2__technique__pass__states__stencil_func_separate__ref__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func_separate__ref( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func_separate__ref( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func_separate__ref( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_func_separate__ref__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_func_separate__ref__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REF,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func_separate__ref()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func_separate__ref();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func_separate__ref( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_func_separate__ref__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_func_separate__ref__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_func_separate__ref__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_func_separate__mask__AttributeData profile_GLES2__technique__pass__states__stencil_func_separate__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_func_separate__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_func_separate__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_func_separate__mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_func_separate__mask__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_func_separate__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_func_separate__mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_func_separate__mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_func_separate__mask( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_func_separate__mask__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_func_separate__mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_func_separate__mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_mask__AttributeData profile_GLES2__technique__pass__states__stencil_mask__AttributeData::DEFAULT = {4294967295ULL, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_mask__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toSint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_mask( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_mask__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_mask_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_mask_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_mask_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_mask_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_mask_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_mask_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_mask_separate__face__AttributeData profile_GLES2__technique__pass__states__stencil_mask_separate__face__AttributeData::DEFAULT = {ENUM__gl_face_enum__FRONT_AND_BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_mask_separate__face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_mask_separate__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_mask_separate__face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_mask_separate__face__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_mask_separate__face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_mask_separate__face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_mask_separate__face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_mask_separate__face( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_mask_separate__face__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_mask_separate__face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_mask_separate__face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_mask_separate__mask__AttributeData profile_GLES2__technique__pass__states__stencil_mask_separate__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_mask_separate__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_mask_separate__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_mask_separate__mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_mask_separate__mask__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_mask_separate__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_mask_separate__mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_mask_separate__mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_mask_separate__mask( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_mask_separate__mask__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_mask_separate__mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_mask_separate__mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_op__fail__AttributeData profile_GLES2__technique__pass__states__stencil_op__fail__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op__fail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op__fail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op__fail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_op__fail__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_op__fail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op__fail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op__fail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op__fail( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_op__fail__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_op__fail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_op__fail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_op__zfail__AttributeData profile_GLES2__technique__pass__states__stencil_op__zfail__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op__zfail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op__zfail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op__zfail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_op__zfail__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_op__zfail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZFAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZFAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op__zfail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op__zfail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op__zfail( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_op__zfail__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_op__zfail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_op__zfail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_op__zpass__AttributeData profile_GLES2__technique__pass__states__stencil_op__zpass__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op__zpass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op__zpass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op__zpass( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_op__zpass__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_op__zpass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZPASS,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZPASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op__zpass()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op__zpass();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op__zpass( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_op__zpass__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_op__zpass__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_op__zpass__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_op_separate__face__AttributeData profile_GLES2__technique__pass__states__stencil_op_separate__face__AttributeData::DEFAULT = {ENUM__gl_face_enum__FRONT_AND_BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op_separate__face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op_separate__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op_separate__face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_op_separate__face__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_op_separate__face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op_separate__face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op_separate__face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op_separate__face( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_op_separate__face__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_op_separate__face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_op_separate__face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_op_separate__fail__AttributeData profile_GLES2__technique__pass__states__stencil_op_separate__fail__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op_separate__fail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op_separate__fail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op_separate__fail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_op_separate__fail__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_op_separate__fail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op_separate__fail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op_separate__fail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op_separate__fail( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_op_separate__fail__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_op_separate__fail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_op_separate__fail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_op_separate__zfail__AttributeData profile_GLES2__technique__pass__states__stencil_op_separate__zfail__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op_separate__zfail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op_separate__zfail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op_separate__zfail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_op_separate__zfail__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_op_separate__zfail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZFAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZFAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op_separate__zfail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op_separate__zfail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op_separate__zfail( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_op_separate__zfail__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_op_separate__zfail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_op_separate__zfail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_op_separate__zpass__AttributeData profile_GLES2__technique__pass__states__stencil_op_separate__zpass__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_op_separate__zpass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_op_separate__zpass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_op_separate__zpass( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_op_separate__zpass__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_op_separate__zpass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZPASS,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZPASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_op_separate__zpass()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_op_separate__zpass();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_op_separate__zpass( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_op_separate__zpass__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_op_separate__zpass__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_op_separate__zpass__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__blend_enable__AttributeData profile_GLES2__technique__pass__states__blend_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__blend_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__blend_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__blend_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__blend_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__blend_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BLEND_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLEND_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__blend_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__blend_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__blend_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__blend_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__blend_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__blend_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__cull_face_enable__AttributeData profile_GLES2__technique__pass__states__cull_face_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__cull_face_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__cull_face_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__cull_face_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__cull_face_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__cull_face_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CULL_FACE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CULL_FACE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__cull_face_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__cull_face_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__cull_face_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__cull_face_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__cull_face_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__cull_face_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__depth_test_enable__AttributeData profile_GLES2__technique__pass__states__depth_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__depth_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__depth_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__depth_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__depth_test_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__depth_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__depth_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__depth_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__depth_test_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__depth_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__depth_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__depth_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__dither_enable__AttributeData profile_GLES2__technique__pass__states__dither_enable__AttributeData::DEFAULT = {true, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__dither_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__dither_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__dither_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__dither_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__dither_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DITHER_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DITHER_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__dither_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__dither_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__dither_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__dither_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__dither_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__dither_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__polygon_offset_fill_enable__AttributeData profile_GLES2__technique__pass__states__polygon_offset_fill_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__polygon_offset_fill_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__polygon_offset_fill_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__polygon_offset_fill_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__polygon_offset_fill_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__polygon_offset_fill_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__polygon_offset_fill_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__polygon_offset_fill_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__polygon_offset_fill_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__polygon_offset_fill_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__polygon_offset_fill_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__polygon_offset_fill_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const point_size_enable__AttributeData point_size_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__point_size_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__point_size_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__point_size_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

point_size_enable__AttributeData* attributeData = newData<point_size_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SIZE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__point_size_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__point_size_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__point_size_enable( void* attributeData )
{
    point_size_enable__AttributeData* typedAttributeData = static_cast<point_size_enable__AttributeData*>(attributeData);

    typedAttributeData->~point_size_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__sample_coverage_enable__AttributeData profile_GLES2__technique__pass__states__sample_coverage_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__sample_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__sample_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__sample_coverage_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__sample_coverage_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__sample_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__sample_coverage_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__sample_coverage_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__sample_coverage_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__sample_coverage_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__sample_coverage_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__sample_coverage_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__scissor_test_enable__AttributeData profile_GLES2__technique__pass__states__scissor_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__scissor_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__scissor_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__scissor_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__scissor_test_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__scissor_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCISSOR_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCISSOR_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__scissor_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__scissor_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__scissor_test_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__scissor_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__scissor_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__scissor_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__states__stencil_test_enable__AttributeData profile_GLES2__technique__pass__states__stencil_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__states__stencil_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__states__stencil_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__states__stencil_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__states__stencil_test_enable__AttributeData* attributeData = newData<profile_GLES2__technique__pass__states__stencil_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__states__stencil_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__states__stencil_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__states__stencil_test_enable( void* attributeData )
{
    profile_GLES2__technique__pass__states__stencil_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__states__stencil_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__states__stencil_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__program____gles2_program_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__program____gles2_program_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__program____gles2_program_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__program____gles2_program_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__program____gles2_program_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__program____gles2_program_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const shader____gles2_shader_type__AttributeData shader____gles2_shader_type__AttributeData::DEFAULT = {ENUM__fx_pipeline_stage_enum__NOT_PRESENT};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__shader____gles2_shader_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__shader____gles2_shader_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__shader____gles2_shader_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

shader____gles2_shader_type__AttributeData* attributeData = newData<shader____gles2_shader_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_STAGE:
    {
bool failed;
attributeData->stage = Utils::toEnum<ENUM__fx_pipeline_stage_enum, StringHash, ENUM__fx_pipeline_stage_enum__COUNT>(attributeValue, failed, ENUM__fx_pipeline_stage_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SHADER,
        HASH_ATTRIBUTE_STAGE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHADER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( attributeData->stage == ENUM__fx_pipeline_stage_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SHADER, HASH_ATTRIBUTE_STAGE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__shader____gles2_shader_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__shader____gles2_shader_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__shader____gles2_shader_type( void* attributeData )
{
    shader____gles2_shader_type__AttributeData* typedAttributeData = static_cast<shader____gles2_shader_type__AttributeData*>(attributeData);

    typedAttributeData->~shader____gles2_shader_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__fx_pipeline_stage_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_pipeline_stage_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__fx_pipeline_stage_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__fx_pipeline_stage_enum, StringHash, ENUM__fx_pipeline_stage_enum__COUNT, &toEnum_ENUM__fx_pipeline_stage_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__fx_pipeline_stage_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_pipeline_stage_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__fx_pipeline_stage_enum, StringHash, ENUM__fx_pipeline_stage_enum__COUNT>(text, textLength, dataFunction, ENUM__fx_pipeline_stage_enumMap, baseConversionFunc, &toEnum_ENUM__fx_pipeline_stage_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__fx_pipeline_stage_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__fx_pipeline_stage_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__fx_pipeline_stage_enum*, size_t ),
    const std::pair<StringHash, ENUM__fx_pipeline_stage_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__fx_pipeline_stage_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__fx_pipeline_stage_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__fx_pipeline_stage_enum, StringHash, ENUM__fx_pipeline_stage_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const gles2_shader_type____sources__AttributeData gles2_shader_type____sources__AttributeData::DEFAULT = {(const ParserChar*)"main"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__gles2_shader_type____sources( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__gles2_shader_type____sources( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__gles2_shader_type____sources( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

gles2_shader_type____sources__AttributeData* attributeData = newData<gles2_shader_type____sources__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENTRY:
    {

attributeData->entry = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SOURCES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__gles2_shader_type____sources()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__gles2_shader_type____sources();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__gles2_shader_type____sources( void* attributeData )
{
    gles2_shader_type____sources__AttributeData* typedAttributeData = static_cast<gles2_shader_type____sources__AttributeData*>(attributeData);

    typedAttributeData->~gles2_shader_type____sources__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__inline( const ParserChar* text, size_t textLength )
{

return mImpl->data__inline(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__inline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__inline( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__inline()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__inline();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__inline( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const import__AttributeData import__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__import( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__import( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__import( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

import__AttributeData* attributeData = newData<import__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_IMPORT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_IMPORT, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__import()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__import();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__import( void* attributeData )
{
    import__AttributeData* typedAttributeData = static_cast<import__AttributeData*>(attributeData);

    typedAttributeData->~import__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const compiler__AttributeData compiler__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__compiler( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__compiler( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__compiler( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

compiler__AttributeData* attributeData = newData<compiler__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_OPTIONS:
    {

attributeData->options = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COMPILER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->platform )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_COMPILER, HASH_ATTRIBUTE_PLATFORM, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__compiler()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__compiler();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__compiler( void* attributeData )
{
    compiler__AttributeData* typedAttributeData = static_cast<compiler__AttributeData*>(attributeData);

    typedAttributeData->~compiler__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__binary( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__binary( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__binary( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__binary()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__binary();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__binary( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ref____anyURI( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ref____anyURI( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ref____anyURI( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ref____anyURI()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ref____anyURI();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
COLLADABU::URI parameter = GeneratedSaxParser::Utils::toURI((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__ref____anyURI(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_REF, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ref____anyURI( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const binary__hex__AttributeData binary__hex__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__binary__hex( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2Uint8Data(text, textLength, &ColladaParserAutoGen15::data__binary__hex, 0, 0, 0);
    }
    else
    {
return characterData2Uint8Data(text, textLength, &ColladaParserAutoGen15::data__binary__hex);
    }
#else
    {
return characterData2Uint8Data(text, textLength, &ColladaParserAutoGen15::data__binary__hex);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__binary__hex( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__binary__hex( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

binary__hex__AttributeData* attributeData = newData<binary__hex__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_HEX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__binary__hex()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__binary__hex();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = uint8DataEnd( &ColladaParserAutoGen15::data__binary__hex, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return uint8DataEnd( &ColladaParserAutoGen15::data__binary__hex );
    }
#else
    {
return uint8DataEnd( &ColladaParserAutoGen15::data__binary__hex );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__binary__hex( void* attributeData )
{
    binary__hex__AttributeData* typedAttributeData = static_cast<binary__hex__AttributeData*>(attributeData);

    typedAttributeData->~binary__hex__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const linker__AttributeData linker__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__linker( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__linker( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__linker( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

linker__AttributeData* attributeData = newData<linker__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_OPTIONS:
    {

attributeData->options = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINKER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->platform )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LINKER, HASH_ATTRIBUTE_PLATFORM, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__linker()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__linker();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__linker( void* attributeData )
{
    linker__AttributeData* typedAttributeData = static_cast<linker__AttributeData*>(attributeData);

    typedAttributeData->~linker__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const gles2_program_type____bind_attribute__AttributeData gles2_program_type____bind_attribute__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__gles2_program_type____bind_attribute( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__gles2_program_type____bind_attribute( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__gles2_program_type____bind_attribute( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

gles2_program_type____bind_attribute__AttributeData* attributeData = newData<gles2_program_type____bind_attribute__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_ATTRIBUTE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->symbol )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND_ATTRIBUTE, HASH_ATTRIBUTE_SYMBOL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__gles2_program_type____bind_attribute()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__gles2_program_type____bind_attribute();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__gles2_program_type____bind_attribute( void* attributeData )
{
    gles2_program_type____bind_attribute__AttributeData* typedAttributeData = static_cast<gles2_program_type____bind_attribute__AttributeData*>(attributeData);

    typedAttributeData->~gles2_program_type____bind_attribute__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__semantic____token( const ParserChar* text, size_t textLength )
{

return mImpl->data__semantic____token(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__semantic____token( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__semantic____token( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__semantic____token()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__semantic____token();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__semantic____token( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const gles2_program_type____bind_uniform__AttributeData gles2_program_type____bind_uniform__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__gles2_program_type____bind_uniform( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__gles2_program_type____bind_uniform( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__gles2_program_type____bind_uniform( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

gles2_program_type____bind_uniform__AttributeData* attributeData = newData<gles2_program_type____bind_uniform__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_UNIFORM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->symbol )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND_UNIFORM, HASH_ATTRIBUTE_SYMBOL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__gles2_program_type____bind_uniform()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__gles2_program_type____bind_uniform();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__gles2_program_type____bind_uniform( void* attributeData )
{
    gles2_program_type____bind_uniform__AttributeData* typedAttributeData = static_cast<gles2_program_type____bind_uniform__AttributeData*>(attributeData);

    typedAttributeData->~gles2_program_type____bind_uniform__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES2__technique__pass__program__bind_uniform__param__AttributeData profile_GLES2__technique__pass__program__bind_uniform__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES2__technique__pass__program__bind_uniform__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES2__technique__pass__program__bind_uniform__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES2__technique__pass__program__bind_uniform__param( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES2__technique__pass__program__bind_uniform__param__AttributeData* attributeData = newData<profile_GLES2__technique__pass__program__bind_uniform__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->ref, strlen(attributeData->ref));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARAM,
            HASH_ATTRIBUTE_REF,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES2__technique__pass__program__bind_uniform__param()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES2__technique__pass__program__bind_uniform__param();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES2__technique__pass__program__bind_uniform__param( void* attributeData )
{
    profile_GLES2__technique__pass__program__bind_uniform__param__AttributeData* typedAttributeData = static_cast<profile_GLES2__technique__pass__program__bind_uniform__param__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES2__technique__pass__program__bind_uniform__param__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__gles2_pass_type____evaluate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__gles2_pass_type____evaluate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__gles2_pass_type____evaluate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__gles2_pass_type____evaluate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__gles2_pass_type____evaluate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__gles2_pass_type____evaluate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const color_target__AttributeData color_target__AttributeData::DEFAULT = {0, 0, ENUM__image_face_enum__POSITIVE_X, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__color_target( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__color_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__color_target( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

color_target__AttributeData* attributeData = newData<color_target__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_TARGET,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_MIP:
    {
bool failed;
attributeData->mip = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_TARGET,
        HASH_ATTRIBUTE_MIP,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_FACE:
    {
bool failed;
attributeData->face = Utils::toEnum<ENUM__image_face_enum, StringHash, ENUM__image_face_enum__COUNT>(attributeValue, failed, ENUM__image_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_TARGET,
        HASH_ATTRIBUTE_FACE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SLICE:
    {
bool failed;
attributeData->slice = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_TARGET,
        HASH_ATTRIBUTE_SLICE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_TARGET, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__color_target()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__color_target();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__color_target( void* attributeData )
{
    color_target__AttributeData* typedAttributeData = static_cast<color_target__AttributeData*>(attributeData);

    typedAttributeData->~color_target__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__image_face_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__image_face_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__image_face_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__image_face_enum, StringHash, ENUM__image_face_enum__COUNT, &toEnum_ENUM__image_face_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__image_face_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__image_face_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__image_face_enum, StringHash, ENUM__image_face_enum__COUNT>(text, textLength, dataFunction, ENUM__image_face_enumMap, baseConversionFunc, &toEnum_ENUM__image_face_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__image_face_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__image_face_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__image_face_enum*, size_t ),
    const std::pair<StringHash, ENUM__image_face_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__image_face_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__image_face_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__image_face_enum, StringHash, ENUM__image_face_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const fx_colortarget_type____param__AttributeData fx_colortarget_type____param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fx_colortarget_type____param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fx_colortarget_type____param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fx_colortarget_type____param( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

fx_colortarget_type____param__AttributeData* attributeData = newData<fx_colortarget_type____param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fx_colortarget_type____param()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fx_colortarget_type____param();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fx_colortarget_type____param( void* attributeData )
{
    fx_colortarget_type____param__AttributeData* typedAttributeData = static_cast<fx_colortarget_type____param__AttributeData*>(attributeData);

    typedAttributeData->~fx_colortarget_type____param__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const depth_target__AttributeData depth_target__AttributeData::DEFAULT = {0, 0, ENUM__image_face_enum__POSITIVE_X, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__depth_target( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__depth_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__depth_target( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

depth_target__AttributeData* attributeData = newData<depth_target__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_TARGET,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_MIP:
    {
bool failed;
attributeData->mip = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_TARGET,
        HASH_ATTRIBUTE_MIP,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_FACE:
    {
bool failed;
attributeData->face = Utils::toEnum<ENUM__image_face_enum, StringHash, ENUM__image_face_enum__COUNT>(attributeValue, failed, ENUM__image_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_TARGET,
        HASH_ATTRIBUTE_FACE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SLICE:
    {
bool failed;
attributeData->slice = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_TARGET,
        HASH_ATTRIBUTE_SLICE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_TARGET, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__depth_target()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__depth_target();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__depth_target( void* attributeData )
{
    depth_target__AttributeData* typedAttributeData = static_cast<depth_target__AttributeData*>(attributeData);

    typedAttributeData->~depth_target__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const stencil_target__AttributeData stencil_target__AttributeData::DEFAULT = {0, 0, ENUM__image_face_enum__POSITIVE_X, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__stencil_target( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__stencil_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__stencil_target( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

stencil_target__AttributeData* attributeData = newData<stencil_target__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_TARGET,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_MIP:
    {
bool failed;
attributeData->mip = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_TARGET,
        HASH_ATTRIBUTE_MIP,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_FACE:
    {
bool failed;
attributeData->face = Utils::toEnum<ENUM__image_face_enum, StringHash, ENUM__image_face_enum__COUNT>(attributeValue, failed, ENUM__image_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_TARGET,
        HASH_ATTRIBUTE_FACE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SLICE:
    {
bool failed;
attributeData->slice = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_TARGET,
        HASH_ATTRIBUTE_SLICE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_TARGET, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__stencil_target()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__stencil_target();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__stencil_target( void* attributeData )
{
    stencil_target__AttributeData* typedAttributeData = static_cast<stencil_target__AttributeData*>(attributeData);

    typedAttributeData->~stencil_target__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const color_clear__AttributeData color_clear__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__color_clear( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        border_color__ValidationData* validationData = (border_color__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__color_clear, &validate__fx_color_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__color_clear);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__color_clear);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__color_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__color_clear( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

color_clear__AttributeData* attributeData = newData<color_clear__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_CLEAR,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_CLEAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__color_clear()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__color_clear();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        border_color__ValidationData* validationData = (border_color__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__color_clear, &validate__fx_color_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__fx_color_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_COLOR_CLEAR,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__color_clear );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__color_clear );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__color_clear( void* attributeData )
{
    color_clear__AttributeData* typedAttributeData = static_cast<color_clear__AttributeData*>(attributeData);

    typedAttributeData->~color_clear__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const stencil_clear__AttributeData stencil_clear__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__stencil_clear( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__stencil_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__stencil_clear( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

stencil_clear__AttributeData* attributeData = newData<stencil_clear__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_CLEAR,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_CLEAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__stencil_clear()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__stencil_clear();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
sint8 parameter = GeneratedSaxParser::Utils::toSint8((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__stencil_clear(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_STENCIL_CLEAR, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__stencil_clear( void* attributeData )
{
    stencil_clear__AttributeData* typedAttributeData = static_cast<stencil_clear__AttributeData*>(attributeData);

    typedAttributeData->~stencil_clear__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const depth_clear__AttributeData depth_clear__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__depth_clear( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__depth_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__depth_clear( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

depth_clear__AttributeData* attributeData = newData<depth_clear__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_CLEAR,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_CLEAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__depth_clear()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__depth_clear();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__depth_clear(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DEPTH_CLEAR, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__depth_clear( void* attributeData )
{
    depth_clear__AttributeData* typedAttributeData = static_cast<depth_clear__AttributeData*>(attributeData);

    typedAttributeData->~depth_clear__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__draw( const ParserChar* text, size_t textLength )
{

return mImpl->data__draw(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__draw( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__draw( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__draw()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__draw();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__draw( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__AttributeData profile_GLSL__AttributeData::DEFAULT = {0, (const ParserChar*)"PC"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__AttributeData* attributeData = newData<profile_GLSL__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->platform, strlen(attributeData->platform));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROFILE_GLSL,
            HASH_ATTRIBUTE_PLATFORM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLSL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL( void* attributeData )
{
    profile_GLSL__AttributeData* typedAttributeData = static_cast<profile_GLSL__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const newparam____glsl_newparam_type__AttributeData newparam____glsl_newparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__newparam____glsl_newparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__newparam____glsl_newparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__newparam____glsl_newparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

newparam____glsl_newparam_type__AttributeData* attributeData = newData<newparam____glsl_newparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEWPARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NEWPARAM, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__newparam____glsl_newparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__newparam____glsl_newparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__newparam____glsl_newparam_type( void* attributeData )
{
    newparam____glsl_newparam_type__AttributeData* typedAttributeData = static_cast<newparam____glsl_newparam_type__AttributeData*>(attributeData);

    typedAttributeData->~newparam____glsl_newparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const array____glsl_array_type__AttributeData array____glsl_array_type__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__array____glsl_array_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__array____glsl_array_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__array____glsl_array_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

array____glsl_array_type__AttributeData* attributeData = newData<array____glsl_array_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARRAY,
        HASH_ATTRIBUTE_LENGTH,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__positiveInteger(attributeData->length);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARRAY,
            HASH_ATTRIBUTE_LENGTH,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= array____glsl_array_type__AttributeData::ATTRIBUTE_LENGTH_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & array____glsl_array_type__AttributeData::ATTRIBUTE_LENGTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ARRAY, HASH_ATTRIBUTE_LENGTH, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__array____glsl_array_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__array____glsl_array_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__array____glsl_array_type( void* attributeData )
{
    array____glsl_array_type__AttributeData* typedAttributeData = static_cast<array____glsl_array_type__AttributeData*>(attributeData);

    typedAttributeData->~array____glsl_array_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_glsl_type____technique__AttributeData profile_glsl_type____technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_glsl_type____technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_glsl_type____technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_glsl_type____technique( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_glsl_type____technique__AttributeData* attributeData = newData<profile_glsl_type____technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TECHNIQUE, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_glsl_type____technique()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_glsl_type____technique();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_glsl_type____technique( void* attributeData )
{
    profile_glsl_type____technique__AttributeData* typedAttributeData = static_cast<profile_glsl_type____technique__AttributeData*>(attributeData);

    typedAttributeData->~profile_glsl_type____technique__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__AttributeData profile_GLSL__technique__pass__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__AttributeData* attributeData = newData<profile_GLSL__technique__pass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PASS,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass( void* attributeData )
{
    profile_GLSL__technique__pass__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__alpha_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__alpha_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__alpha_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__alpha_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__alpha_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__alpha_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__alpha_func__func__AttributeData profile_GLSL__technique__pass__states__alpha_func__func__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__alpha_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__alpha_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__alpha_func__func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__alpha_func__func__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__alpha_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FUNC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FUNC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FUNC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__alpha_func__func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__alpha_func__func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__alpha_func__func( void* attributeData )
{
    profile_GLSL__technique__pass__states__alpha_func__func__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__alpha_func__func__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__alpha_func__func__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__alpha_func__value__AttributeData profile_GLSL__technique__pass__states__alpha_func__value__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__alpha_func__value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__alpha_func__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__alpha_func__value( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__alpha_func__value__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__alpha_func__value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VALUE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gl_alpha_value_type(attributeData->value);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_VALUE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_VALUE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VALUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__alpha_func__value()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__alpha_func__value();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__alpha_func__value( void* attributeData )
{
    profile_GLSL__technique__pass__states__alpha_func__value__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__alpha_func__value__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__alpha_func__value__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_func__src__AttributeData profile_GLSL__technique__pass__states__blend_func__src__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ONE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_func__src( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_func__src( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_func__src( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_func__src__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_func__src__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SRC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SRC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SRC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_func__src()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_func__src();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_func__src( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_func__src__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_func__src__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_func__src__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_func__dest__AttributeData profile_GLSL__technique__pass__states__blend_func__dest__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ZERO, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_func__dest( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_func__dest( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_func__dest( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_func__dest__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_func__dest__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEST,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEST,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEST, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_func__dest()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_func__dest();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_func__dest( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_func__dest__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_func__dest__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_func__dest__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_func_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_func_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_func_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_func_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_func_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_func_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_func_separate__src_rgb__AttributeData profile_GLSL__technique__pass__states__blend_func_separate__src_rgb__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ONE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_func_separate__src_rgb( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_func_separate__src_rgb( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_func_separate__src_rgb( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_func_separate__src_rgb__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_func_separate__src_rgb__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SRC_RGB,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SRC_RGB,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SRC_RGB, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_func_separate__src_rgb()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_func_separate__src_rgb();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_func_separate__src_rgb( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_func_separate__src_rgb__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_func_separate__src_rgb__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_func_separate__src_rgb__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb__AttributeData profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ZERO, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEST_RGB,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEST_RGB,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEST_RGB, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_func_separate__dest_rgb__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_func_separate__src_alpha__AttributeData profile_GLSL__technique__pass__states__blend_func_separate__src_alpha__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ONE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_func_separate__src_alpha( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_func_separate__src_alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_func_separate__src_alpha( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_func_separate__src_alpha__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_func_separate__src_alpha__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SRC_ALPHA,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SRC_ALPHA,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SRC_ALPHA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_func_separate__src_alpha()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_func_separate__src_alpha();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_func_separate__src_alpha( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_func_separate__src_alpha__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_func_separate__src_alpha__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_func_separate__src_alpha__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha__AttributeData profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ZERO, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEST_ALPHA,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEST_ALPHA,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEST_ALPHA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_func_separate__dest_alpha__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_equation__AttributeData profile_GLSL__technique__pass__states__blend_equation__AttributeData::DEFAULT = {ENUM__gl_blend_equation_enum__FUNC_ADD, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_equation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_equation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_equation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_equation__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_equation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_equation_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BLEND_EQUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BLEND_EQUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLEND_EQUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_equation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_equation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_equation( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_equation__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_equation__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_equation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_equation_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_equation_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_equation_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_equation_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_equation_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_equation_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_equation_separate__rgb__AttributeData profile_GLSL__technique__pass__states__blend_equation_separate__rgb__AttributeData::DEFAULT = {ENUM__gl_blend_equation_enum__FUNC_ADD, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_equation_separate__rgb( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_equation_separate__rgb( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_equation_separate__rgb( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_equation_separate__rgb__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_equation_separate__rgb__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_equation_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RGB,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_RGB,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RGB, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_equation_separate__rgb()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_equation_separate__rgb();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_equation_separate__rgb( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_equation_separate__rgb__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_equation_separate__rgb__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_equation_separate__rgb__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_equation_separate__alpha__AttributeData profile_GLSL__technique__pass__states__blend_equation_separate__alpha__AttributeData::DEFAULT = {ENUM__gl_blend_equation_enum__FUNC_ADD, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_equation_separate__alpha( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_equation_separate__alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_equation_separate__alpha( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_equation_separate__alpha__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_equation_separate__alpha__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_equation_enum, StringHash, ENUM__gl_blend_equation_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_equation_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ALPHA,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ALPHA,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_equation_separate__alpha()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_equation_separate__alpha();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_equation_separate__alpha( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_equation_separate__alpha__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_equation_separate__alpha__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_equation_separate__alpha__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__color_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__color_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__color_material( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__color_material()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__color_material();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__color_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const color_material__face__AttributeData color_material__face__AttributeData::DEFAULT = {ENUM__gl_face_enum__FRONT_AND_BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__color_material__face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__color_material__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__color_material__face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

color_material__face__AttributeData* attributeData = newData<color_material__face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FACE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__color_material__face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__color_material__face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__color_material__face( void* attributeData )
{
    color_material__face__AttributeData* typedAttributeData = static_cast<color_material__face__AttributeData*>(attributeData);

    typedAttributeData->~color_material__face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const color_material__mode__AttributeData color_material__mode__AttributeData::DEFAULT = {ENUM__gl_material_enum__AMBIENT_AND_DIFFUSE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__color_material__mode( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__color_material__mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__color_material__mode( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

color_material__mode__AttributeData* attributeData = newData<color_material__mode__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_material_enum, StringHash, ENUM__gl_material_enum__COUNT>(attributeValue, failed, ENUM__gl_material_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MODE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MODE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MODE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__color_material__mode()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__color_material__mode();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__color_material__mode( void* attributeData )
{
    color_material__mode__AttributeData* typedAttributeData = static_cast<color_material__mode__AttributeData*>(attributeData);

    typedAttributeData->~color_material__mode__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__cull_face__AttributeData profile_GLSL__technique__pass__states__cull_face__AttributeData::DEFAULT = {ENUM__gl_face_enum__BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__cull_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__cull_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__cull_face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__cull_face__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__cull_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CULL_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CULL_FACE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CULL_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__cull_face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__cull_face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__cull_face( void* attributeData )
{
    profile_GLSL__technique__pass__states__cull_face__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__cull_face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__cull_face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__depth_func__AttributeData profile_GLSL__technique__pass__states__depth_func__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__depth_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__depth_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__depth_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__depth_func__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__depth_func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_FUNC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_FUNC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_FUNC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__depth_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__depth_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__depth_func( void* attributeData )
{
    profile_GLSL__technique__pass__states__depth_func__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__depth_func__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__depth_func__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__fog_mode__AttributeData profile_GLSL__technique__pass__states__fog_mode__AttributeData::DEFAULT = {ENUM__gl_fog_enum__EXP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__fog_mode( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__fog_mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__fog_mode( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__fog_mode__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__fog_mode__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_fog_enum, StringHash, ENUM__gl_fog_enum__COUNT>(attributeValue, failed, ENUM__gl_fog_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_MODE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_MODE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_MODE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__fog_mode()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__fog_mode();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__fog_mode( void* attributeData )
{
    profile_GLSL__technique__pass__states__fog_mode__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__fog_mode__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__fog_mode__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const fog_coord_src__AttributeData fog_coord_src__AttributeData::DEFAULT = {ENUM__gl_fog_coord_src_enum__FOG_COORDINATE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fog_coord_src( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fog_coord_src( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fog_coord_src( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

fog_coord_src__AttributeData* attributeData = newData<fog_coord_src__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_fog_coord_src_enum, StringHash, ENUM__gl_fog_coord_src_enum__COUNT>(attributeValue, failed, ENUM__gl_fog_coord_src_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_COORD_SRC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_COORD_SRC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_COORD_SRC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fog_coord_src()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fog_coord_src();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fog_coord_src( void* attributeData )
{
    fog_coord_src__AttributeData* typedAttributeData = static_cast<fog_coord_src__AttributeData*>(attributeData);

    typedAttributeData->~fog_coord_src__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__front_face__AttributeData profile_GLSL__technique__pass__states__front_face__AttributeData::DEFAULT = {ENUM__gl_front_face_enum__CCW, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__front_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__front_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__front_face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__front_face__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__front_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_front_face_enum, StringHash, ENUM__gl_front_face_enum__COUNT>(attributeValue, failed, ENUM__gl_front_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FRONT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FRONT_FACE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRONT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__front_face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__front_face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__front_face( void* attributeData )
{
    profile_GLSL__technique__pass__states__front_face__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__front_face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__front_face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const light_model_color_control__AttributeData light_model_color_control__AttributeData::DEFAULT = {ENUM__gl_light_model_color_control_enum__SINGLE_COLOR, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__light_model_color_control( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__light_model_color_control( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__light_model_color_control( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

light_model_color_control__AttributeData* attributeData = newData<light_model_color_control__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_light_model_color_control_enum, StringHash, ENUM__gl_light_model_color_control_enum__COUNT>(attributeValue, failed, ENUM__gl_light_model_color_control_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_MODEL_COLOR_CONTROL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_MODEL_COLOR_CONTROL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_MODEL_COLOR_CONTROL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__light_model_color_control()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__light_model_color_control();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__light_model_color_control( void* attributeData )
{
    light_model_color_control__AttributeData* typedAttributeData = static_cast<light_model_color_control__AttributeData*>(attributeData);

    typedAttributeData->~light_model_color_control__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__logic_op__AttributeData profile_GLSL__technique__pass__states__logic_op__AttributeData::DEFAULT = {ENUM__gl_logic_op_enum__COPY, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__logic_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__logic_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__logic_op( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__logic_op__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__logic_op__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_logic_op_enum, StringHash, ENUM__gl_logic_op_enum__COUNT>(attributeValue, failed, ENUM__gl_logic_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOGIC_OP,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LOGIC_OP,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LOGIC_OP, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__logic_op()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__logic_op();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__logic_op( void* attributeData )
{
    profile_GLSL__technique__pass__states__logic_op__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__logic_op__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__logic_op__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polygon_mode( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polygon_mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polygon_mode( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polygon_mode()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polygon_mode();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polygon_mode( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const polygon_mode__face__AttributeData polygon_mode__face__AttributeData::DEFAULT = {ENUM__gl_face_enum__FRONT_AND_BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polygon_mode__face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polygon_mode__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polygon_mode__face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

polygon_mode__face__AttributeData* attributeData = newData<polygon_mode__face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FACE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polygon_mode__face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polygon_mode__face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polygon_mode__face( void* attributeData )
{
    polygon_mode__face__AttributeData* typedAttributeData = static_cast<polygon_mode__face__AttributeData*>(attributeData);

    typedAttributeData->~polygon_mode__face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const polygon_mode__mode__AttributeData polygon_mode__mode__AttributeData::DEFAULT = {ENUM__gl_polygon_mode_enum__FILL, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polygon_mode__mode( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polygon_mode__mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polygon_mode__mode( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

polygon_mode__mode__AttributeData* attributeData = newData<polygon_mode__mode__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_polygon_mode_enum, StringHash, ENUM__gl_polygon_mode_enum__COUNT>(attributeValue, failed, ENUM__gl_polygon_mode_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MODE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MODE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MODE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polygon_mode__mode()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polygon_mode__mode();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polygon_mode__mode( void* attributeData )
{
    polygon_mode__mode__AttributeData* typedAttributeData = static_cast<polygon_mode__mode__AttributeData*>(attributeData);

    typedAttributeData->~polygon_mode__mode__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__shade_model__AttributeData profile_GLSL__technique__pass__states__shade_model__AttributeData::DEFAULT = {ENUM__gl_shade_model_enum__SMOOTH, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__shade_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__shade_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__shade_model( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__shade_model__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__shade_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_shade_model_enum, StringHash, ENUM__gl_shade_model_enum__COUNT>(attributeValue, failed, ENUM__gl_shade_model_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SHADE_MODEL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SHADE_MODEL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHADE_MODEL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__shade_model()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__shade_model();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__shade_model( void* attributeData )
{
    profile_GLSL__technique__pass__states__shade_model__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__shade_model__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__shade_model__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_func__func__AttributeData profile_GLSL__technique__pass__states__stencil_func__func__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func__func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_func__func__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FUNC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FUNC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FUNC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func__func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func__func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func__func( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_func__func__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_func__func__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_func__func__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_func__ref__AttributeData profile_GLSL__technique__pass__states__stencil_func__ref__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func__ref( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func__ref( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func__ref( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_func__ref__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_func__ref__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REF,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_REF,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func__ref()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func__ref();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func__ref( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_func__ref__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_func__ref__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_func__ref__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_func__mask__AttributeData profile_GLSL__technique__pass__states__stencil_func__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func__mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_func__mask__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_func__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func__mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func__mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func__mask( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_func__mask__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_func__mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_func__mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_op__fail__AttributeData profile_GLSL__technique__pass__states__stencil_op__fail__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op__fail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op__fail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op__fail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_op__fail__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_op__fail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FAIL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op__fail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op__fail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op__fail( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_op__fail__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_op__fail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_op__fail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_op__zfail__AttributeData profile_GLSL__technique__pass__states__stencil_op__zfail__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op__zfail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op__zfail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op__zfail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_op__zfail__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_op__zfail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZFAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ZFAIL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZFAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op__zfail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op__zfail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op__zfail( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_op__zfail__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_op__zfail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_op__zfail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_op__zpass__AttributeData profile_GLSL__technique__pass__states__stencil_op__zpass__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op__zpass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op__zpass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op__zpass( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_op__zpass__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_op__zpass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZPASS,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ZPASS,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZPASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op__zpass()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op__zpass();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op__zpass( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_op__zpass__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_op__zpass__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_op__zpass__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_func_separate__front__AttributeData profile_GLSL__technique__pass__states__stencil_func_separate__front__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func_separate__front( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func_separate__front( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func_separate__front( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_func_separate__front__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_func_separate__front__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FRONT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FRONT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRONT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func_separate__front()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func_separate__front();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func_separate__front( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_func_separate__front__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_func_separate__front__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_func_separate__front__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_func_separate__back__AttributeData profile_GLSL__technique__pass__states__stencil_func_separate__back__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func_separate__back( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func_separate__back( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func_separate__back( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_func_separate__back__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_func_separate__back__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BACK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BACK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BACK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func_separate__back()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func_separate__back();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func_separate__back( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_func_separate__back__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_func_separate__back__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_func_separate__back__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_func_separate__ref__AttributeData profile_GLSL__technique__pass__states__stencil_func_separate__ref__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func_separate__ref( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func_separate__ref( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func_separate__ref( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_func_separate__ref__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_func_separate__ref__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REF,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_REF,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func_separate__ref()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func_separate__ref();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func_separate__ref( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_func_separate__ref__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_func_separate__ref__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_func_separate__ref__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_func_separate__mask__AttributeData profile_GLSL__technique__pass__states__stencil_func_separate__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_func_separate__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_func_separate__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_func_separate__mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_func_separate__mask__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_func_separate__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_func_separate__mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_func_separate__mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_func_separate__mask( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_func_separate__mask__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_func_separate__mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_func_separate__mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_op_separate__face__AttributeData profile_GLSL__technique__pass__states__stencil_op_separate__face__AttributeData::DEFAULT = {ENUM__gl_face_enum__FRONT_AND_BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op_separate__face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op_separate__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op_separate__face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_op_separate__face__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_op_separate__face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FACE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op_separate__face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op_separate__face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op_separate__face( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_op_separate__face__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_op_separate__face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_op_separate__face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_op_separate__fail__AttributeData profile_GLSL__technique__pass__states__stencil_op_separate__fail__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op_separate__fail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op_separate__fail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op_separate__fail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_op_separate__fail__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_op_separate__fail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FAIL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op_separate__fail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op_separate__fail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op_separate__fail( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_op_separate__fail__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_op_separate__fail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_op_separate__fail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_op_separate__zfail__AttributeData profile_GLSL__technique__pass__states__stencil_op_separate__zfail__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op_separate__zfail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op_separate__zfail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op_separate__zfail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_op_separate__zfail__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_op_separate__zfail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZFAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ZFAIL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZFAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op_separate__zfail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op_separate__zfail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op_separate__zfail( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_op_separate__zfail__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_op_separate__zfail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_op_separate__zfail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_op_separate__zpass__AttributeData profile_GLSL__technique__pass__states__stencil_op_separate__zpass__AttributeData::DEFAULT = {ENUM__gl_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_op_separate__zpass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_op_separate__zpass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_op_separate__zpass( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_op_separate__zpass__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_op_separate__zpass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_stencil_op_enum, StringHash, ENUM__gl_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gl_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZPASS,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ZPASS,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZPASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_op_separate__zpass()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_op_separate__zpass();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_op_separate__zpass( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_op_separate__zpass__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_op_separate__zpass__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_op_separate__zpass__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_mask_separate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_mask_separate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_mask_separate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_mask_separate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_mask_separate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_mask_separate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_mask_separate__face__AttributeData profile_GLSL__technique__pass__states__stencil_mask_separate__face__AttributeData::DEFAULT = {ENUM__gl_face_enum__FRONT_AND_BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_mask_separate__face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_mask_separate__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_mask_separate__face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_mask_separate__face__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_mask_separate__face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FACE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_mask_separate__face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_mask_separate__face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_mask_separate__face( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_mask_separate__face__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_mask_separate__face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_mask_separate__face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_mask_separate__mask__AttributeData profile_GLSL__technique__pass__states__stencil_mask_separate__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_mask_separate__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_mask_separate__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_mask_separate__mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_mask_separate__mask__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_mask_separate__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_mask_separate__mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_mask_separate__mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_mask_separate__mask( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_mask_separate__mask__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_mask_separate__mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_mask_separate__mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_enable__AttributeData profile_GLSL__technique__pass__states__light_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_ENABLE, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__light_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_ambient__AttributeData profile_GLSL__technique__pass__states__light_ambient__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_ambient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_ambient__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_AMBIENT, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_AMBIENT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_AMBIENT,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_AMBIENT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_AMBIENT,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_AMBIENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_AMBIENT, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_ambient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_ambient();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_ambient( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_ambient__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__light_ambient__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_diffuse__AttributeData profile_GLSL__technique__pass__states__light_diffuse__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_diffuse( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_diffuse__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_diffuse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_DIFFUSE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_DIFFUSE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_DIFFUSE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_DIFFUSE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_DIFFUSE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_DIFFUSE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_DIFFUSE, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_diffuse()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_diffuse();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_diffuse( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_diffuse__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_diffuse__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__light_diffuse__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_specular__AttributeData profile_GLSL__technique__pass__states__light_specular__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_specular( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_specular__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_specular__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_SPECULAR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPECULAR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPECULAR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPECULAR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPECULAR,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPECULAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_SPECULAR, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_specular()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_specular();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_specular( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_specular__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_specular__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__light_specular__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_position__AttributeData profile_GLSL__technique__pass__states__light_position__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_position( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_position( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_position( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_position__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_position__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_POSITION, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_POSITION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_POSITION,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_position__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_POSITION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_POSITION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_position__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_POSITION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__light_position__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 1.0E0 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_position__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_position__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_POSITION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_position()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_position();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_position( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_position__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_position__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__light_position__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData::DEFAULT = {0, 1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_constant_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_constant_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_constant_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_constant_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_constant_attenuation( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__light_constant_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData::DEFAULT = {0, 0.0E1, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_linear_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_linear_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_linear_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_linear_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_linear_attenuation( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__light_linear_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData::DEFAULT = {0, 0.0E1, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_quadratic_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_quadratic_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_quadratic_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_quadratic_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_quadratic_attenuation( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__light_quadratic_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData::DEFAULT = {0, 1.8E2, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_spot_cutoff( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_spot_cutoff( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_spot_cutoff( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_CUTOFF,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_CUTOFF,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_CUTOFF,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_CUTOFF, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_SPOT_CUTOFF, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_spot_cutoff()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_spot_cutoff();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_spot_cutoff( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__light_spot_cutoff__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_spot_direction__AttributeData profile_GLSL__technique__pass__states__light_spot_direction__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_spot_direction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_spot_direction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_spot_direction( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_spot_direction__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_spot_direction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_SPOT_DIRECTION, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_DIRECTION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 -1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_SPOT_DIRECTION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_spot_direction()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_spot_direction();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_spot_direction( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_spot_direction__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_spot_direction__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__light_spot_direction__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData::DEFAULT = {0, 0.0E1, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_spot_exponent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_spot_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_spot_exponent( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_EXPONENT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_EXPONENT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_EXPONENT,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_EXPONENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_SPOT_EXPONENT, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_spot_exponent()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_spot_exponent();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_spot_exponent( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__light_spot_exponent__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const texture1D__AttributeData texture1D__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture1D( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture1D__AttributeData* attributeData = newData<texture1D__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE1D,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= texture1D__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE1D, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & texture1D__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TEXTURE1D, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture1D()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture1D();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture1D( void* attributeData )
{
    texture1D__AttributeData* typedAttributeData = static_cast<texture1D__AttributeData*>(attributeData);

    typedAttributeData->~texture1D__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__value____fx_sampler1D_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__value____fx_sampler1D_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__value____fx_sampler1D_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__value____fx_sampler1D_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__value____fx_sampler1D_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__value____fx_sampler1D_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__param____NCName( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__param____NCName( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__param____NCName( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__param____NCName()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__param____NCName();
        if ( !validationResult ) return false;

    } // validation
#endif

bool returnValue = true;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
ParserError::ErrorType simpleTypeValidationResult = validate__NCName(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
{
    ParserChar msg[21];
    Utils::fillErrorMsg(msg, mLastIncompleteFragmentInCharacterData, 20);
    if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        simpleTypeValidationResult,
        0,
        msg) )
    {
        returnValue =  false;
    }
}
if (!returnValue)
{
    mStackMemoryManager.deleteObject();
    mLastIncompleteFragmentInCharacterData = 0;
    mEndOfDataInCurrentObjectOnStack = 0;
    return returnValue;
}
    } // validation
#endif
returnValue = mImpl->data__param____NCName(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__param____NCName( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const texture2D__AttributeData texture2D__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture2D( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture2D__AttributeData* attributeData = newData<texture2D__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE2D,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= texture2D__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE2D, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & texture2D__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TEXTURE2D, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture2D()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture2D();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture2D( void* attributeData )
{
    texture2D__AttributeData* typedAttributeData = static_cast<texture2D__AttributeData*>(attributeData);

    typedAttributeData->~texture2D__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__value____fx_sampler2D_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__value____fx_sampler2D_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__value____fx_sampler2D_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__value____fx_sampler2D_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__value____fx_sampler2D_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__value____fx_sampler2D_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const texture3D__AttributeData texture3D__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture3D( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture3D__AttributeData* attributeData = newData<texture3D__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE3D,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= texture3D__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE3D, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & texture3D__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TEXTURE3D, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture3D()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture3D();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture3D( void* attributeData )
{
    texture3D__AttributeData* typedAttributeData = static_cast<texture3D__AttributeData*>(attributeData);

    typedAttributeData->~texture3D__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__value____fx_sampler3D_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__value____fx_sampler3D_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__value____fx_sampler3D_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__value____fx_sampler3D_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__value____fx_sampler3D_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__value____fx_sampler3D_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const textureCUBE__AttributeData textureCUBE__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__textureCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__textureCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__textureCUBE( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

textureCUBE__AttributeData* attributeData = newData<textureCUBE__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURECUBE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= textureCUBE__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURECUBE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & textureCUBE__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TEXTURECUBE, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__textureCUBE()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__textureCUBE();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__textureCUBE( void* attributeData )
{
    textureCUBE__AttributeData* typedAttributeData = static_cast<textureCUBE__AttributeData*>(attributeData);

    typedAttributeData->~textureCUBE__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__value____fx_samplerCUBE_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__value____fx_samplerCUBE_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__value____fx_samplerCUBE_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__value____fx_samplerCUBE_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__value____fx_samplerCUBE_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__value____fx_samplerCUBE_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const textureRECT__AttributeData textureRECT__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__textureRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__textureRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__textureRECT( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

textureRECT__AttributeData* attributeData = newData<textureRECT__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURERECT,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= textureRECT__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURERECT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & textureRECT__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TEXTURERECT, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__textureRECT()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__textureRECT();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__textureRECT( void* attributeData )
{
    textureRECT__AttributeData* typedAttributeData = static_cast<textureRECT__AttributeData*>(attributeData);

    typedAttributeData->~textureRECT__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__value____fx_samplerRECT_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__value____fx_samplerRECT_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__value____fx_samplerRECT_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__value____fx_samplerRECT_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__value____fx_samplerRECT_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__value____fx_samplerRECT_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const textureDEPTH__AttributeData textureDEPTH__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__textureDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__textureDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__textureDEPTH( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

textureDEPTH__AttributeData* attributeData = newData<textureDEPTH__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTUREDEPTH,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= textureDEPTH__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTUREDEPTH, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & textureDEPTH__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TEXTUREDEPTH, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__textureDEPTH()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__textureDEPTH();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__textureDEPTH( void* attributeData )
{
    textureDEPTH__AttributeData* typedAttributeData = static_cast<textureDEPTH__AttributeData*>(attributeData);

    typedAttributeData->~textureDEPTH__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__value____fx_samplerDEPTH_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__value____fx_samplerDEPTH_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__value____fx_samplerDEPTH_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__value____fx_samplerDEPTH_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__value____fx_samplerDEPTH_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__value____fx_samplerDEPTH_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const texture1D_enable__AttributeData texture1D_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture1D_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture1D_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture1D_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture1D_enable__AttributeData* attributeData = newData<texture1D_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE1D_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURE1D_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE1D_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= texture1D_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE1D_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture1D_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture1D_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture1D_enable( void* attributeData )
{
    texture1D_enable__AttributeData* typedAttributeData = static_cast<texture1D_enable__AttributeData*>(attributeData);

    typedAttributeData->~texture1D_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const texture2D_enable__AttributeData texture2D_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture2D_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture2D_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture2D_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture2D_enable__AttributeData* attributeData = newData<texture2D_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE2D_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURE2D_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE2D_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= texture2D_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE2D_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture2D_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture2D_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture2D_enable( void* attributeData )
{
    texture2D_enable__AttributeData* typedAttributeData = static_cast<texture2D_enable__AttributeData*>(attributeData);

    typedAttributeData->~texture2D_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const texture3D_enable__AttributeData texture3D_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture3D_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture3D_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture3D_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture3D_enable__AttributeData* attributeData = newData<texture3D_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE3D_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURE3D_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE3D_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= texture3D_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE3D_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture3D_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture3D_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture3D_enable( void* attributeData )
{
    texture3D_enable__AttributeData* typedAttributeData = static_cast<texture3D_enable__AttributeData*>(attributeData);

    typedAttributeData->~texture3D_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const textureCUBE_enable__AttributeData textureCUBE_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__textureCUBE_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__textureCUBE_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__textureCUBE_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

textureCUBE_enable__AttributeData* attributeData = newData<textureCUBE_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURECUBE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURECUBE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURECUBE_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= textureCUBE_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURECUBE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__textureCUBE_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__textureCUBE_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__textureCUBE_enable( void* attributeData )
{
    textureCUBE_enable__AttributeData* typedAttributeData = static_cast<textureCUBE_enable__AttributeData*>(attributeData);

    typedAttributeData->~textureCUBE_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const textureRECT_enable__AttributeData textureRECT_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__textureRECT_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__textureRECT_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__textureRECT_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

textureRECT_enable__AttributeData* attributeData = newData<textureRECT_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURERECT_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURERECT_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURERECT_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= textureRECT_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURERECT_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__textureRECT_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__textureRECT_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__textureRECT_enable( void* attributeData )
{
    textureRECT_enable__AttributeData* typedAttributeData = static_cast<textureRECT_enable__AttributeData*>(attributeData);

    typedAttributeData->~textureRECT_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const textureDEPTH_enable__AttributeData textureDEPTH_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__textureDEPTH_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__textureDEPTH_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__textureDEPTH_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

textureDEPTH_enable__AttributeData* attributeData = newData<textureDEPTH_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTUREDEPTH_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTUREDEPTH_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTUREDEPTH_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= textureDEPTH_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTUREDEPTH_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__textureDEPTH_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__textureDEPTH_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__textureDEPTH_enable( void* attributeData )
{
    textureDEPTH_enable__AttributeData* typedAttributeData = static_cast<textureDEPTH_enable__AttributeData*>(attributeData);

    typedAttributeData->~textureDEPTH_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const texture_env_color__AttributeData texture_env_color__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture_env_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture_env_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture_env_color( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture_env_color__AttributeData* attributeData = newData<texture_env_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_TEXTURE_ENV_COLOR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE_ENV_COLOR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURE_ENV_COLOR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= texture_env_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURE_ENV_COLOR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE_ENV_COLOR,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= texture_env_color__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE_ENV_COLOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & texture_env_color__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    attributeData->value = GeneratedSaxParser::XSList<float>();
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture_env_color()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture_env_color();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture_env_color( void* attributeData )
{
    texture_env_color__AttributeData* typedAttributeData = static_cast<texture_env_color__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~texture_env_color__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const texture_env_mode__AttributeData texture_env_mode__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture_env_mode( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture_env_mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture_env_mode( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texture_env_mode__AttributeData* attributeData = newData<texture_env_mode__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {

attributeData->value = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXTURE_ENV_MODE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXTURE_ENV_MODE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= texture_env_mode__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXTURE_ENV_MODE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture_env_mode()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture_env_mode();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture_env_mode( void* attributeData )
{
    texture_env_mode__AttributeData* typedAttributeData = static_cast<texture_env_mode__AttributeData*>(attributeData);

    typedAttributeData->~texture_env_mode__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__clip_plane__AttributeData profile_GLSL__technique__pass__states__clip_plane__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__clip_plane( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__clip_plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__clip_plane( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__clip_plane__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__clip_plane__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_CLIP_PLANE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CLIP_PLANE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CLIP_PLANE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__clip_plane__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CLIP_PLANE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CLIP_PLANE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__clip_plane__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLIP_PLANE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__clip_plane__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__clip_plane__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__clip_plane()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__clip_plane();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__clip_plane( void* attributeData )
{
    profile_GLSL__technique__pass__states__clip_plane__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__clip_plane__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__clip_plane__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__clip_plane_enable__AttributeData profile_GLSL__technique__pass__states__clip_plane_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__clip_plane_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__clip_plane_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__clip_plane_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__clip_plane_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__clip_plane_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CLIP_PLANE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CLIP_PLANE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CLIP_PLANE_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__clip_plane_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLIP_PLANE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__clip_plane_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__clip_plane_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__clip_plane_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__clip_plane_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__clip_plane_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__clip_plane_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_color__AttributeData profile_GLSL__technique__pass__states__blend_color__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_color( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_color__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_BLEND_COLOR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BLEND_COLOR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BLEND_COLOR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__blend_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BLEND_COLOR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLEND_COLOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__blend_color__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__blend_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_color()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_color();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_color( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_color__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_color__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__blend_color__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__color_mask__AttributeData profile_GLSL__technique__pass__states__color_mask__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<bool>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__color_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__color_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__color_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__color_mask__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__color_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2BoolList(attributeValue, attributeData->value, 0, HASH_ELEMENT_COLOR_MASK, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2BoolList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2BoolList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__bool4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_MASK,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__color_mask__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__color_mask__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2BoolList("true true true true", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__color_mask__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__color_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__color_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__color_mask( void* attributeData )
{
    profile_GLSL__technique__pass__states__color_mask__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__color_mask__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__color_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const depth_bounds__AttributeData depth_bounds__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__depth_bounds( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__depth_bounds( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__depth_bounds( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

depth_bounds__AttributeData* attributeData = newData<depth_bounds__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_DEPTH_BOUNDS, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_BOUNDS,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_BOUNDS,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= depth_bounds__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_BOUNDS,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_BOUNDS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & depth_bounds__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    attributeData->value = GeneratedSaxParser::XSList<float>();
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__depth_bounds()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__depth_bounds();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__depth_bounds( void* attributeData )
{
    depth_bounds__AttributeData* typedAttributeData = static_cast<depth_bounds__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~depth_bounds__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__depth_mask__AttributeData profile_GLSL__technique__pass__states__depth_mask__AttributeData::DEFAULT = {true, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__depth_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__depth_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__depth_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__depth_mask__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__depth_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__depth_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__depth_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__depth_mask( void* attributeData )
{
    profile_GLSL__technique__pass__states__depth_mask__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__depth_mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__depth_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__depth_range__AttributeData profile_GLSL__technique__pass__states__depth_range__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__depth_range( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__depth_range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__depth_range( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__depth_range__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__depth_range__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_DEPTH_RANGE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_RANGE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_RANGE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_RANGE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_RANGE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__depth_range()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__depth_range();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__depth_range( void* attributeData )
{
    profile_GLSL__technique__pass__states__depth_range__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__depth_range__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__depth_range__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__fog_density__AttributeData profile_GLSL__technique__pass__states__fog_density__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__fog_density( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__fog_density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__fog_density( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__fog_density__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__fog_density__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_DENSITY,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_DENSITY,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_DENSITY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__fog_density()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__fog_density();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__fog_density( void* attributeData )
{
    profile_GLSL__technique__pass__states__fog_density__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__fog_density__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__fog_density__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__fog_start__AttributeData profile_GLSL__technique__pass__states__fog_start__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__fog_start( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__fog_start( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__fog_start( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__fog_start__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__fog_start__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_START,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_START,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_START, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__fog_start()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__fog_start();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__fog_start( void* attributeData )
{
    profile_GLSL__technique__pass__states__fog_start__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__fog_start__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__fog_start__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__fog_end__AttributeData profile_GLSL__technique__pass__states__fog_end__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__fog_end( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__fog_end( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__fog_end( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__fog_end__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__fog_end__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_END,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_END,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_END, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__fog_end()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__fog_end();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__fog_end( void* attributeData )
{
    profile_GLSL__technique__pass__states__fog_end__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__fog_end__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__fog_end__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__fog_color__AttributeData profile_GLSL__technique__pass__states__fog_color__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__fog_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__fog_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__fog_color( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__fog_color__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__fog_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_FOG_COLOR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_COLOR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_COLOR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__fog_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_COLOR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_COLOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__fog_color__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__fog_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__fog_color()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__fog_color();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__fog_color( void* attributeData )
{
    profile_GLSL__technique__pass__states__fog_color__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__fog_color__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__fog_color__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_model_ambient__AttributeData profile_GLSL__technique__pass__states__light_model_ambient__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_model_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_model_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_model_ambient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_model_ambient__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_model_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_MODEL_AMBIENT, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_MODEL_AMBIENT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_MODEL_AMBIENT,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_model_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_MODEL_AMBIENT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_MODEL_AMBIENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__light_model_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("2.0E-1 2.0E-1 2.0E-1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__light_model_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_model_ambient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_model_ambient();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_model_ambient( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_model_ambient__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_model_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__light_model_ambient__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__lighting_enable__AttributeData profile_GLSL__technique__pass__states__lighting_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__lighting_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__lighting_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__lighting_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__lighting_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__lighting_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHTING_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHTING_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHTING_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__lighting_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__lighting_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__lighting_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__lighting_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__lighting_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__lighting_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const line_stipple__AttributeData line_stipple__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<sint64>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__line_stipple( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__line_stipple( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__line_stipple( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

line_stipple__AttributeData* attributeData = newData<line_stipple__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value, 0, HASH_ELEMENT_LINE_STIPPLE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINE_STIPPLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__int2_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINE_STIPPLE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= line_stipple__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINE_STIPPLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_STIPPLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & line_stipple__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2Sint64List("1 65536", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= line_stipple__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__line_stipple()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__line_stipple();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__line_stipple( void* attributeData )
{
    line_stipple__AttributeData* typedAttributeData = static_cast<line_stipple__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~line_stipple__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__line_width__AttributeData profile_GLSL__technique__pass__states__line_width__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__line_width( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__line_width( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__line_width( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__line_width__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__line_width__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINE_WIDTH,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINE_WIDTH,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_WIDTH, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__line_width()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__line_width();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__line_width( void* attributeData )
{
    profile_GLSL__technique__pass__states__line_width__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__line_width__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__line_width__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__material_ambient__AttributeData profile_GLSL__technique__pass__states__material_ambient__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__material_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__material_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__material_ambient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__material_ambient__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__material_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MATERIAL_AMBIENT, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_AMBIENT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_AMBIENT,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__material_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_AMBIENT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_AMBIENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__material_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("2.0E-1 2.0E-1 2.0E-1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__material_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__material_ambient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__material_ambient();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__material_ambient( void* attributeData )
{
    profile_GLSL__technique__pass__states__material_ambient__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__material_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__material_ambient__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__material_diffuse__AttributeData profile_GLSL__technique__pass__states__material_diffuse__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__material_diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__material_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__material_diffuse( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__material_diffuse__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__material_diffuse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MATERIAL_DIFFUSE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_DIFFUSE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_DIFFUSE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__material_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_DIFFUSE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_DIFFUSE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__material_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("8.0E-1 8.0E-1 8.0E-1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__material_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__material_diffuse()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__material_diffuse();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__material_diffuse( void* attributeData )
{
    profile_GLSL__technique__pass__states__material_diffuse__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__material_diffuse__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__material_diffuse__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__material_emission__AttributeData profile_GLSL__technique__pass__states__material_emission__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__material_emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__material_emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__material_emission( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__material_emission__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__material_emission__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MATERIAL_EMISSION, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_EMISSION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_EMISSION,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__material_emission__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_EMISSION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_EMISSION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__material_emission__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__material_emission__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__material_emission()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__material_emission();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__material_emission( void* attributeData )
{
    profile_GLSL__technique__pass__states__material_emission__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__material_emission__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__material_emission__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__material_shininess__AttributeData profile_GLSL__technique__pass__states__material_shininess__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__material_shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__material_shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__material_shininess( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__material_shininess__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__material_shininess__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_SHININESS,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_SHININESS,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_SHININESS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__material_shininess()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__material_shininess();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__material_shininess( void* attributeData )
{
    profile_GLSL__technique__pass__states__material_shininess__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__material_shininess__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__material_shininess__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__material_specular__AttributeData profile_GLSL__technique__pass__states__material_specular__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__material_specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__material_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__material_specular( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__material_specular__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__material_specular__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MATERIAL_SPECULAR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_SPECULAR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_SPECULAR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__material_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_SPECULAR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_SPECULAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__material_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__material_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__material_specular()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__material_specular();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__material_specular( void* attributeData )
{
    profile_GLSL__technique__pass__states__material_specular__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__material_specular__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__material_specular__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__model_view_matrix__AttributeData profile_GLSL__technique__pass__states__model_view_matrix__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__model_view_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__model_view_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__model_view_matrix( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__model_view_matrix__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__model_view_matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MODEL_VIEW_MATRIX, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MODEL_VIEW_MATRIX,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MODEL_VIEW_MATRIX,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__model_view_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MODEL_VIEW_MATRIX,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MODEL_VIEW_MATRIX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__model_view_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__model_view_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__model_view_matrix()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__model_view_matrix();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__model_view_matrix( void* attributeData )
{
    profile_GLSL__technique__pass__states__model_view_matrix__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__model_view_matrix__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__model_view_matrix__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__point_distance_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__point_distance_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__point_distance_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_POINT_DISTANCE_ATTENUATION, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_DISTANCE_ATTENUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_DISTANCE_ATTENUATION,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_DISTANCE_ATTENUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_DISTANCE_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("1.0E0 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__point_distance_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__point_distance_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__point_distance_attenuation( void* attributeData )
{
    profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__point_distance_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__point_fade_threshold_size__AttributeData profile_GLSL__technique__pass__states__point_fade_threshold_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__point_fade_threshold_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__point_fade_threshold_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__point_fade_threshold_size( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__point_fade_threshold_size__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__point_fade_threshold_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__point_fade_threshold_size()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__point_fade_threshold_size();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__point_fade_threshold_size( void* attributeData )
{
    profile_GLSL__technique__pass__states__point_fade_threshold_size__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__point_fade_threshold_size__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__point_fade_threshold_size__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__point_size__AttributeData profile_GLSL__technique__pass__states__point_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__point_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__point_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__point_size( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__point_size__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__point_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SIZE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_SIZE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__point_size()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__point_size();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__point_size( void* attributeData )
{
    profile_GLSL__technique__pass__states__point_size__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__point_size__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__point_size__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__point_size_min__AttributeData profile_GLSL__technique__pass__states__point_size_min__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__point_size_min( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__point_size_min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__point_size_min( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__point_size_min__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__point_size_min__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SIZE_MIN,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_SIZE_MIN,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE_MIN, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__point_size_min()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__point_size_min();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__point_size_min( void* attributeData )
{
    profile_GLSL__technique__pass__states__point_size_min__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__point_size_min__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__point_size_min__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__point_size_max__AttributeData profile_GLSL__technique__pass__states__point_size_max__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__point_size_max( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__point_size_max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__point_size_max( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__point_size_max__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__point_size_max__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SIZE_MAX,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_SIZE_MAX,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE_MAX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__point_size_max()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__point_size_max();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__point_size_max( void* attributeData )
{
    profile_GLSL__technique__pass__states__point_size_max__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__point_size_max__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__point_size_max__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__polygon_offset__AttributeData profile_GLSL__technique__pass__states__polygon_offset__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__polygon_offset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__polygon_offset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__polygon_offset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__polygon_offset__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__polygon_offset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_POLYGON_OFFSET, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_OFFSET,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__polygon_offset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__polygon_offset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__polygon_offset( void* attributeData )
{
    profile_GLSL__technique__pass__states__polygon_offset__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__polygon_offset__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__polygon_offset__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__projection_matrix__AttributeData profile_GLSL__technique__pass__states__projection_matrix__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__projection_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__projection_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__projection_matrix( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__projection_matrix__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__projection_matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_PROJECTION_MATRIX, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PROJECTION_MATRIX,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROJECTION_MATRIX,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__projection_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROJECTION_MATRIX,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROJECTION_MATRIX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__projection_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__projection_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__projection_matrix()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__projection_matrix();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__projection_matrix( void* attributeData )
{
    profile_GLSL__technique__pass__states__projection_matrix__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__projection_matrix__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__projection_matrix__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__scissor__AttributeData profile_GLSL__technique__pass__states__scissor__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<sint64>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__scissor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__scissor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__scissor( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__scissor__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__scissor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value, 0, HASH_ELEMENT_SCISSOR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCISSOR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__int4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCISSOR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLSL__technique__pass__states__scissor__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCISSOR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCISSOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLSL__technique__pass__states__scissor__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    attributeData->value = GeneratedSaxParser::XSList<sint64>();
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__scissor()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__scissor();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__scissor( void* attributeData )
{
    profile_GLSL__technique__pass__states__scissor__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__scissor__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLSL__technique__pass__states__scissor__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_mask__AttributeData profile_GLSL__technique__pass__states__stencil_mask__AttributeData::DEFAULT = {4294967295ULL, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_mask__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toSint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_STENCIL_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_mask( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_mask__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__alpha_test_enable__AttributeData profile_GLSL__technique__pass__states__alpha_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__alpha_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__alpha_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__alpha_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__alpha_test_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__alpha_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ALPHA_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ALPHA_TEST_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__alpha_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__alpha_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__alpha_test_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__alpha_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__alpha_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__alpha_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__blend_enable__AttributeData profile_GLSL__technique__pass__states__blend_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__blend_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__blend_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__blend_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__blend_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__blend_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BLEND_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BLEND_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLEND_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__blend_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__blend_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__blend_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__blend_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__blend_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__blend_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__color_logic_op_enable__AttributeData profile_GLSL__technique__pass__states__color_logic_op_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__color_logic_op_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__color_logic_op_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__color_logic_op_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__color_logic_op_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__color_logic_op_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__color_logic_op_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__color_logic_op_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__color_logic_op_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__color_logic_op_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__color_logic_op_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__color_logic_op_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__color_material_enable__AttributeData profile_GLSL__technique__pass__states__color_material_enable__AttributeData::DEFAULT = {true, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__color_material_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__color_material_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__color_material_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__color_material_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__color_material_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_MATERIAL_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_MATERIAL_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_MATERIAL_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__color_material_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__color_material_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__color_material_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__color_material_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__color_material_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__color_material_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__cull_face_enable__AttributeData profile_GLSL__technique__pass__states__cull_face_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__cull_face_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__cull_face_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__cull_face_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__cull_face_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__cull_face_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CULL_FACE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CULL_FACE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CULL_FACE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__cull_face_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__cull_face_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__cull_face_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__cull_face_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__cull_face_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__cull_face_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const depth_bounds_enable__AttributeData depth_bounds_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__depth_bounds_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__depth_bounds_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__depth_bounds_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

depth_bounds_enable__AttributeData* attributeData = newData<depth_bounds_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_BOUNDS_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_BOUNDS_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_BOUNDS_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__depth_bounds_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__depth_bounds_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__depth_bounds_enable( void* attributeData )
{
    depth_bounds_enable__AttributeData* typedAttributeData = static_cast<depth_bounds_enable__AttributeData*>(attributeData);

    typedAttributeData->~depth_bounds_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const depth_clamp_enable__AttributeData depth_clamp_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__depth_clamp_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__depth_clamp_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__depth_clamp_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

depth_clamp_enable__AttributeData* attributeData = newData<depth_clamp_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_CLAMP_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_CLAMP_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_CLAMP_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__depth_clamp_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__depth_clamp_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__depth_clamp_enable( void* attributeData )
{
    depth_clamp_enable__AttributeData* typedAttributeData = static_cast<depth_clamp_enable__AttributeData*>(attributeData);

    typedAttributeData->~depth_clamp_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__depth_test_enable__AttributeData profile_GLSL__technique__pass__states__depth_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__depth_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__depth_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__depth_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__depth_test_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__depth_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_TEST_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__depth_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__depth_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__depth_test_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__depth_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__depth_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__depth_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__dither_enable__AttributeData profile_GLSL__technique__pass__states__dither_enable__AttributeData::DEFAULT = {true, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__dither_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__dither_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__dither_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__dither_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__dither_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DITHER_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DITHER_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DITHER_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__dither_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__dither_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__dither_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__dither_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__dither_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__dither_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__fog_enable__AttributeData profile_GLSL__technique__pass__states__fog_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__fog_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__fog_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__fog_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__fog_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__fog_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__fog_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__fog_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__fog_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__fog_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__fog_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__fog_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const light_model_local_viewer_enable__AttributeData light_model_local_viewer_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__light_model_local_viewer_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__light_model_local_viewer_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__light_model_local_viewer_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

light_model_local_viewer_enable__AttributeData* attributeData = newData<light_model_local_viewer_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_MODEL_LOCAL_VIEWER_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_MODEL_LOCAL_VIEWER_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_MODEL_LOCAL_VIEWER_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__light_model_local_viewer_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__light_model_local_viewer_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__light_model_local_viewer_enable( void* attributeData )
{
    light_model_local_viewer_enable__AttributeData* typedAttributeData = static_cast<light_model_local_viewer_enable__AttributeData*>(attributeData);

    typedAttributeData->~light_model_local_viewer_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__light_model_two_side_enable__AttributeData profile_GLSL__technique__pass__states__light_model_two_side_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__light_model_two_side_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__light_model_two_side_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__light_model_two_side_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__light_model_two_side_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__light_model_two_side_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__light_model_two_side_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__light_model_two_side_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__light_model_two_side_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__light_model_two_side_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__light_model_two_side_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__light_model_two_side_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__line_smooth_enable__AttributeData profile_GLSL__technique__pass__states__line_smooth_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__line_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__line_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__line_smooth_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__line_smooth_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__line_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINE_SMOOTH_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINE_SMOOTH_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_SMOOTH_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__line_smooth_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__line_smooth_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__line_smooth_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__line_smooth_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__line_smooth_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__line_smooth_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const line_stipple_enable__AttributeData line_stipple_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__line_stipple_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__line_stipple_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__line_stipple_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

line_stipple_enable__AttributeData* attributeData = newData<line_stipple_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINE_STIPPLE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINE_STIPPLE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_STIPPLE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__line_stipple_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__line_stipple_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__line_stipple_enable( void* attributeData )
{
    line_stipple_enable__AttributeData* typedAttributeData = static_cast<line_stipple_enable__AttributeData*>(attributeData);

    typedAttributeData->~line_stipple_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const logic_op_enable__AttributeData logic_op_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__logic_op_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__logic_op_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__logic_op_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

logic_op_enable__AttributeData* attributeData = newData<logic_op_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOGIC_OP_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LOGIC_OP_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LOGIC_OP_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__logic_op_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__logic_op_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__logic_op_enable( void* attributeData )
{
    logic_op_enable__AttributeData* typedAttributeData = static_cast<logic_op_enable__AttributeData*>(attributeData);

    typedAttributeData->~logic_op_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__multisample_enable__AttributeData profile_GLSL__technique__pass__states__multisample_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__multisample_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__multisample_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__multisample_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__multisample_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__multisample_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MULTISAMPLE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MULTISAMPLE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MULTISAMPLE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__multisample_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__multisample_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__multisample_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__multisample_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__multisample_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__multisample_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__normalize_enable__AttributeData profile_GLSL__technique__pass__states__normalize_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__normalize_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__normalize_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__normalize_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__normalize_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__normalize_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NORMALIZE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NORMALIZE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NORMALIZE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__normalize_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__normalize_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__normalize_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__normalize_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__normalize_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__normalize_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__point_smooth_enable__AttributeData profile_GLSL__technique__pass__states__point_smooth_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__point_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__point_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__point_smooth_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__point_smooth_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__point_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SMOOTH_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_SMOOTH_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SMOOTH_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__point_smooth_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__point_smooth_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__point_smooth_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__point_smooth_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__point_smooth_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__point_smooth_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__polygon_offset_fill_enable__AttributeData profile_GLSL__technique__pass__states__polygon_offset_fill_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__polygon_offset_fill_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__polygon_offset_fill_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__polygon_offset_fill_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__polygon_offset_fill_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__polygon_offset_fill_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__polygon_offset_fill_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__polygon_offset_fill_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__polygon_offset_fill_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__polygon_offset_fill_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__polygon_offset_fill_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__polygon_offset_fill_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const polygon_offset_line_enable__AttributeData polygon_offset_line_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polygon_offset_line_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polygon_offset_line_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polygon_offset_line_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

polygon_offset_line_enable__AttributeData* attributeData = newData<polygon_offset_line_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_OFFSET_LINE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET_LINE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET_LINE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polygon_offset_line_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polygon_offset_line_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polygon_offset_line_enable( void* attributeData )
{
    polygon_offset_line_enable__AttributeData* typedAttributeData = static_cast<polygon_offset_line_enable__AttributeData*>(attributeData);

    typedAttributeData->~polygon_offset_line_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const polygon_offset_point_enable__AttributeData polygon_offset_point_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polygon_offset_point_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polygon_offset_point_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polygon_offset_point_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

polygon_offset_point_enable__AttributeData* attributeData = newData<polygon_offset_point_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_OFFSET_POINT_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET_POINT_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET_POINT_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polygon_offset_point_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polygon_offset_point_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polygon_offset_point_enable( void* attributeData )
{
    polygon_offset_point_enable__AttributeData* typedAttributeData = static_cast<polygon_offset_point_enable__AttributeData*>(attributeData);

    typedAttributeData->~polygon_offset_point_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const polygon_smooth_enable__AttributeData polygon_smooth_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polygon_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polygon_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polygon_smooth_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

polygon_smooth_enable__AttributeData* attributeData = newData<polygon_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_SMOOTH_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_SMOOTH_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_SMOOTH_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polygon_smooth_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polygon_smooth_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polygon_smooth_enable( void* attributeData )
{
    polygon_smooth_enable__AttributeData* typedAttributeData = static_cast<polygon_smooth_enable__AttributeData*>(attributeData);

    typedAttributeData->~polygon_smooth_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const polygon_stipple_enable__AttributeData polygon_stipple_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__polygon_stipple_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__polygon_stipple_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__polygon_stipple_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

polygon_stipple_enable__AttributeData* attributeData = newData<polygon_stipple_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_STIPPLE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_STIPPLE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_STIPPLE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__polygon_stipple_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__polygon_stipple_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__polygon_stipple_enable( void* attributeData )
{
    polygon_stipple_enable__AttributeData* typedAttributeData = static_cast<polygon_stipple_enable__AttributeData*>(attributeData);

    typedAttributeData->~polygon_stipple_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__rescale_normal_enable__AttributeData profile_GLSL__technique__pass__states__rescale_normal_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__rescale_normal_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__rescale_normal_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__rescale_normal_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__rescale_normal_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__rescale_normal_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RESCALE_NORMAL_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_RESCALE_NORMAL_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RESCALE_NORMAL_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__rescale_normal_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__rescale_normal_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__rescale_normal_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__rescale_normal_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__rescale_normal_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__rescale_normal_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__sample_alpha_to_one_enable__AttributeData profile_GLSL__technique__pass__states__sample_alpha_to_one_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__sample_alpha_to_one_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__sample_alpha_to_one_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__sample_alpha_to_one_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__sample_alpha_to_one_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__sample_alpha_to_one_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__sample_alpha_to_one_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__sample_alpha_to_one_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__sample_alpha_to_one_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__sample_alpha_to_one_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__sample_alpha_to_one_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__sample_alpha_to_one_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__sample_coverage_enable__AttributeData profile_GLSL__technique__pass__states__sample_coverage_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__sample_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__sample_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__sample_coverage_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__sample_coverage_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__sample_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__sample_coverage_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__sample_coverage_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__sample_coverage_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__sample_coverage_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__sample_coverage_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__sample_coverage_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__scissor_test_enable__AttributeData profile_GLSL__technique__pass__states__scissor_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__scissor_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__scissor_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__scissor_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__scissor_test_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__scissor_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCISSOR_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCISSOR_TEST_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCISSOR_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__scissor_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__scissor_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__scissor_test_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__scissor_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__scissor_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__scissor_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__states__stencil_test_enable__AttributeData profile_GLSL__technique__pass__states__stencil_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__states__stencil_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__states__stencil_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__states__stencil_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__states__stencil_test_enable__AttributeData* attributeData = newData<profile_GLSL__technique__pass__states__stencil_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_STENCIL_TEST_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__states__stencil_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__states__stencil_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__states__stencil_test_enable( void* attributeData )
{
    profile_GLSL__technique__pass__states__stencil_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__states__stencil_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__states__stencil_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__program____glsl_program_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__program____glsl_program_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__program____glsl_program_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__program____glsl_program_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__program____glsl_program_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__program____glsl_program_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const shader____glsl_shader_type__AttributeData shader____glsl_shader_type__AttributeData::DEFAULT = {ENUM__fx_pipeline_stage_enum__NOT_PRESENT};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__shader____glsl_shader_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__shader____glsl_shader_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__shader____glsl_shader_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

shader____glsl_shader_type__AttributeData* attributeData = newData<shader____glsl_shader_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_STAGE:
    {
bool failed;
attributeData->stage = Utils::toEnum<ENUM__fx_pipeline_stage_enum, StringHash, ENUM__fx_pipeline_stage_enum__COUNT>(attributeValue, failed, ENUM__fx_pipeline_stage_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SHADER,
        HASH_ATTRIBUTE_STAGE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHADER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( attributeData->stage == ENUM__fx_pipeline_stage_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SHADER, HASH_ATTRIBUTE_STAGE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__shader____glsl_shader_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__shader____glsl_shader_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__shader____glsl_shader_type( void* attributeData )
{
    shader____glsl_shader_type__AttributeData* typedAttributeData = static_cast<shader____glsl_shader_type__AttributeData*>(attributeData);

    typedAttributeData->~shader____glsl_shader_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sources____fx_sources_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sources____fx_sources_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sources____fx_sources_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sources____fx_sources_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sources____fx_sources_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sources____fx_sources_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const glsl_program_type____bind_attribute__AttributeData glsl_program_type____bind_attribute__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__glsl_program_type____bind_attribute( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__glsl_program_type____bind_attribute( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__glsl_program_type____bind_attribute( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

glsl_program_type____bind_attribute__AttributeData* attributeData = newData<glsl_program_type____bind_attribute__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_ATTRIBUTE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->symbol )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND_ATTRIBUTE, HASH_ATTRIBUTE_SYMBOL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__glsl_program_type____bind_attribute()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__glsl_program_type____bind_attribute();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__glsl_program_type____bind_attribute( void* attributeData )
{
    glsl_program_type____bind_attribute__AttributeData* typedAttributeData = static_cast<glsl_program_type____bind_attribute__AttributeData*>(attributeData);

    typedAttributeData->~glsl_program_type____bind_attribute__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const glsl_program_type____bind_uniform__AttributeData glsl_program_type____bind_uniform__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__glsl_program_type____bind_uniform( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__glsl_program_type____bind_uniform( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__glsl_program_type____bind_uniform( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

glsl_program_type____bind_uniform__AttributeData* attributeData = newData<glsl_program_type____bind_uniform__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_UNIFORM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->symbol )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND_UNIFORM, HASH_ATTRIBUTE_SYMBOL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__glsl_program_type____bind_uniform()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__glsl_program_type____bind_uniform();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__glsl_program_type____bind_uniform( void* attributeData )
{
    glsl_program_type____bind_uniform__AttributeData* typedAttributeData = static_cast<glsl_program_type____bind_uniform__AttributeData*>(attributeData);

    typedAttributeData->~glsl_program_type____bind_uniform__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLSL__technique__pass__program__bind_uniform__param__AttributeData profile_GLSL__technique__pass__program__bind_uniform__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__program__bind_uniform__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__program__bind_uniform__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__program__bind_uniform__param( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLSL__technique__pass__program__bind_uniform__param__AttributeData* attributeData = newData<profile_GLSL__technique__pass__program__bind_uniform__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->ref, strlen(attributeData->ref));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARAM,
            HASH_ATTRIBUTE_REF,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__program__bind_uniform__param()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__program__bind_uniform__param();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__program__bind_uniform__param( void* attributeData )
{
    profile_GLSL__technique__pass__program__bind_uniform__param__AttributeData* typedAttributeData = static_cast<profile_GLSL__technique__pass__program__bind_uniform__param__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLSL__technique__pass__program__bind_uniform__param__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLSL__technique__pass__evaluate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLSL__technique__pass__evaluate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLSL__technique__pass__evaluate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLSL__technique__pass__evaluate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLSL__technique__pass__evaluate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLSL__technique__pass__evaluate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_CG__AttributeData profile_CG__AttributeData::DEFAULT = {0, (const ParserChar*)"PC"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_CG( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_CG( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_CG( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_CG__AttributeData* attributeData = newData<profile_CG__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->platform, strlen(attributeData->platform));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROFILE_CG,
            HASH_ATTRIBUTE_PLATFORM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_CG, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_CG()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_CG();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_CG( void* attributeData )
{
    profile_CG__AttributeData* typedAttributeData = static_cast<profile_CG__AttributeData*>(attributeData);

    typedAttributeData->~profile_CG__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const newparam____cg_newparam_type__AttributeData newparam____cg_newparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__newparam____cg_newparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__newparam____cg_newparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__newparam____cg_newparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

newparam____cg_newparam_type__AttributeData* attributeData = newData<newparam____cg_newparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEWPARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NEWPARAM, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__newparam____cg_newparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__newparam____cg_newparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__newparam____cg_newparam_type( void* attributeData )
{
    newparam____cg_newparam_type__AttributeData* typedAttributeData = static_cast<newparam____cg_newparam_type__AttributeData*>(attributeData);

    typedAttributeData->~newparam____cg_newparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool2x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2__ValidationData* validationData = (bool2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x1, &validate__bool2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x1);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool2x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool2x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool2x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2__ValidationData* validationData = (bool2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool2x1, &validate__bool2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL2X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2x1 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool2x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2x2__ValidationData* validationData = (bool2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x2, &validate__bool2x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x2);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool2x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool2x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool2x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2x2__ValidationData* validationData = (bool2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool2x2, &validate__bool2x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool2x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL2X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2x2 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool2x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2x3__ValidationData* validationData = (bool2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x3, &validate__bool2x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x3);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool2x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool2x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool2x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2x3__ValidationData* validationData = (bool2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool2x3, &validate__bool2x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool2x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL2X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2x3 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool2x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2x4__ValidationData* validationData = (bool2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x4, &validate__bool2x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x4);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool2x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool2x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool2x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool2x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool2x4__ValidationData* validationData = (bool2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool2x4, &validate__bool2x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool2x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL2X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2x4 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool2x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool3x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3__ValidationData* validationData = (bool3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x1, &validate__bool3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x1);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool3x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool3x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool3x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3__ValidationData* validationData = (bool3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool3x1, &validate__bool3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL3X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3x1 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool3x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3x2__ValidationData* validationData = (bool3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x2, &validate__bool3x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x2);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool3x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool3x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool3x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3x2__ValidationData* validationData = (bool3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool3x2, &validate__bool3x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool3x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL3X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3x2 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool3x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3x3__ValidationData* validationData = (bool3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x3, &validate__bool3x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x3);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool3x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool3x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool3x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3x3__ValidationData* validationData = (bool3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool3x3, &validate__bool3x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool3x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL3X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3x3 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool3x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3x4__ValidationData* validationData = (bool3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x4, &validate__bool3x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x4);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool3x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool3x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool3x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool3x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool3x4__ValidationData* validationData = (bool3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool3x4, &validate__bool3x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool3x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL3X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3x4 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool3x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool4x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4__ValidationData* validationData = (bool4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x1, &validate__bool4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x1);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool4x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool4x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool4x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4__ValidationData* validationData = (bool4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool4x1, &validate__bool4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL4X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4x1 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool4x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4x2__ValidationData* validationData = (bool4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x2, &validate__bool4x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x2);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool4x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool4x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool4x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4x2__ValidationData* validationData = (bool4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool4x2, &validate__bool4x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool4x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL4X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4x2 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool4x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4x3__ValidationData* validationData = (bool4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x3, &validate__bool4x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x3);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool4x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool4x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool4x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4x3__ValidationData* validationData = (bool4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool4x3, &validate__bool4x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool4x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL4X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4x3 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bool4x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4x4__ValidationData* validationData = (bool4x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x4, &validate__bool4x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x4);
    }
#else
    {
return characterData2BoolData(text, textLength, &ColladaParserAutoGen15::data__bool4x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bool4x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bool4x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bool4x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bool4x4__ValidationData* validationData = (bool4x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = boolDataEnd( &ColladaParserAutoGen15::data__bool4x4, &validate__bool4x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__bool4x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_BOOL4X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4x4 );
    }
#else
    {
return boolDataEnd( &ColladaParserAutoGen15::data__bool4x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bool4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int2x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2__ValidationData* validationData = (int2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x1, &validate__int2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x1);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int2x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int2x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int2x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2__ValidationData* validationData = (int2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int2x1, &validate__int2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT2X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2x1 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int2x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2x2__ValidationData* validationData = (int2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x2, &validate__int2x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x2);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int2x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int2x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int2x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2x2__ValidationData* validationData = (int2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int2x2, &validate__int2x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int2x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT2X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2x2 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int2x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2x3__ValidationData* validationData = (int2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x3, &validate__int2x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x3);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int2x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int2x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int2x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2x3__ValidationData* validationData = (int2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int2x3, &validate__int2x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int2x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT2X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2x3 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int2x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2x4__ValidationData* validationData = (int2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x4, &validate__int2x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x4);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int2x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int2x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int2x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int2x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int2x4__ValidationData* validationData = (int2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int2x4, &validate__int2x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int2x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT2X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2x4 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int2x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int3x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3__ValidationData* validationData = (int3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x1, &validate__int3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x1);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int3x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int3x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int3x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3__ValidationData* validationData = (int3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int3x1, &validate__int3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT3X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3x1 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int3x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3x2__ValidationData* validationData = (int3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x2, &validate__int3x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x2);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int3x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int3x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int3x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3x2__ValidationData* validationData = (int3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int3x2, &validate__int3x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int3x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT3X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3x2 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int3x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3x3__ValidationData* validationData = (int3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x3, &validate__int3x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x3);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int3x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int3x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int3x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3x3__ValidationData* validationData = (int3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int3x3, &validate__int3x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int3x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT3X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3x3 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int3x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3x4__ValidationData* validationData = (int3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x4, &validate__int3x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x4);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int3x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int3x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int3x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int3x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int3x4__ValidationData* validationData = (int3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int3x4, &validate__int3x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int3x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT3X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3x4 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int3x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int4x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4__ValidationData* validationData = (int4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x1, &validate__int4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x1);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int4x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int4x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int4x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4__ValidationData* validationData = (int4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int4x1, &validate__int4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT4X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4x1 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int4x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4x2__ValidationData* validationData = (int4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x2, &validate__int4x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x2);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int4x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int4x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int4x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4x2__ValidationData* validationData = (int4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int4x2, &validate__int4x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int4x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT4X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4x2 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int4x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4x3__ValidationData* validationData = (int4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x3, &validate__int4x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x3);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int4x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int4x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int4x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4x3__ValidationData* validationData = (int4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int4x3, &validate__int4x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int4x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT4X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4x3 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int4x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4x4__ValidationData* validationData = (int4x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x4, &validate__int4x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x4);
    }
#else
    {
return characterData2Sint64Data(text, textLength, &ColladaParserAutoGen15::data__int4x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int4x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int4x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int4x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        int4x4__ValidationData* validationData = (int4x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = sint64DataEnd( &ColladaParserAutoGen15::data__int4x4, &validate__int4x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__int4x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INT4X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4x4 );
    }
#else
    {
return sint64DataEnd( &ColladaParserAutoGen15::data__int4x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__half(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_HALF, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half2, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half3, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half4, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half2x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x1, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half2x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half2x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half2x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half2x1, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF2X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half2x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x2__ValidationData* validationData = (float2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x2, &validate__float2x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half2x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half2x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half2x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x2__ValidationData* validationData = (float2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half2x2, &validate__float2x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF2X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half2x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x3__ValidationData* validationData = (float2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x3, &validate__float2x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half2x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half2x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half2x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x3__ValidationData* validationData = (float2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half2x3, &validate__float2x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF2X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half2x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x4__ValidationData* validationData = (float2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x4, &validate__float2x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half2x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half2x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half2x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half2x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x4__ValidationData* validationData = (float2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half2x4, &validate__float2x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF2X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half2x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half3x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x1, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half3x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half3x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half3x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half3x1, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF3X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half3x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x2__ValidationData* validationData = (float3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x2, &validate__float3x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half3x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half3x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half3x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x2__ValidationData* validationData = (float3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half3x2, &validate__float3x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF3X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half3x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x3, &validate__float3x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half3x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half3x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half3x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half3x3, &validate__float3x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF3X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half3x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x4__ValidationData* validationData = (float3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x4, &validate__float3x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half3x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half3x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half3x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half3x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x4__ValidationData* validationData = (float3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half3x4, &validate__float3x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF3X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half3x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half4x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x1, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half4x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half4x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half4x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half4x1, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF4X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half4x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x2__ValidationData* validationData = (float4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x2, &validate__float4x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half4x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half4x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half4x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x2__ValidationData* validationData = (float4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half4x2, &validate__float4x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF4X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half4x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x3__ValidationData* validationData = (float4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x3, &validate__float4x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half4x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half4x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half4x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x3__ValidationData* validationData = (float4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half4x3, &validate__float4x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF4X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half4x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x4, &validate__float4x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half4x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half4x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half4x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half4x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half4x4, &validate__float4x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF4X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half4x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__fixed(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FIXED, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed2, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed3, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed4, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed2x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x1, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed2x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed2x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed2x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed2x1, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED2X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed2x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed2x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x2__ValidationData* validationData = (float2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x2, &validate__float2x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed2x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed2x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed2x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x2__ValidationData* validationData = (float2x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed2x2, &validate__float2x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED2X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed2x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed2x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x3__ValidationData* validationData = (float2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x3, &validate__float2x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed2x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed2x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed2x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x3__ValidationData* validationData = (float2x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed2x3, &validate__float2x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED2X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed2x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed2x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x4__ValidationData* validationData = (float2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x4, &validate__float2x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed2x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed2x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed2x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed2x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float2x4__ValidationData* validationData = (float2x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed2x4, &validate__float2x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED2X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed2x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed2x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed3x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x1, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed3x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed3x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed3x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed3x1, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED3X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed3x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed3x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x2__ValidationData* validationData = (float3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x2, &validate__float3x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed3x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed3x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed3x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x2__ValidationData* validationData = (float3x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed3x2, &validate__float3x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED3X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed3x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed3x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x3, &validate__float3x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed3x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed3x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed3x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed3x3, &validate__float3x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED3X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed3x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed3x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x4__ValidationData* validationData = (float3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x4, &validate__float3x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed3x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed3x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed3x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed3x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x4__ValidationData* validationData = (float3x4__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed3x4, &validate__float3x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED3X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed3x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed3x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed4x1( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x1, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x1);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x1);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed4x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed4x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed4x1();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed4x1, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED4X1,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4x1 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4x1 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed4x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed4x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x2__ValidationData* validationData = (float4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x2, &validate__float4x2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed4x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed4x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed4x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x2__ValidationData* validationData = (float4x2__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed4x2, &validate__float4x2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED4X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed4x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed4x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x3__ValidationData* validationData = (float4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x3, &validate__float4x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed4x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed4x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed4x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float4x3__ValidationData* validationData = (float4x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed4x3, &validate__float4x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED4X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed4x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__fixed4x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x4, &validate__float4x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__fixed4x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__fixed4x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__fixed4x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__fixed4x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__fixed4x4, &validate__float4x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FIXED4X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__fixed4x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__fixed4x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const array____cg_array_type__AttributeData array____cg_array_type__AttributeData::DEFAULT = {0, 0, false};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__array____cg_array_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__array____cg_array_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__array____cg_array_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

array____cg_array_type__AttributeData* attributeData = newData<array____cg_array_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARRAY,
        HASH_ATTRIBUTE_LENGTH,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__positiveInteger(attributeData->length);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARRAY,
            HASH_ATTRIBUTE_LENGTH,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= array____cg_array_type__AttributeData::ATTRIBUTE_LENGTH_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_RESIZABLE:
    {
bool failed;
attributeData->resizable = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARRAY,
        HASH_ATTRIBUTE_RESIZABLE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & array____cg_array_type__AttributeData::ATTRIBUTE_LENGTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ARRAY, HASH_ATTRIBUTE_LENGTH, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__array____cg_array_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__array____cg_array_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__array____cg_array_type( void* attributeData )
{
    array____cg_array_type__AttributeData* typedAttributeData = static_cast<array____cg_array_type__AttributeData*>(attributeData);

    typedAttributeData->~array____cg_array_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const usertype____cg_user_type__AttributeData usertype____cg_user_type__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__usertype____cg_user_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__usertype____cg_user_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__usertype____cg_user_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

usertype____cg_user_type__AttributeData* attributeData = newData<usertype____cg_user_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPENAME:
    {

attributeData->_typename = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->source, strlen(attributeData->source));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_USERTYPE,
            HASH_ATTRIBUTE_SOURCE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_USERTYPE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->_typename )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_USERTYPE, HASH_ATTRIBUTE_TYPENAME, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__usertype____cg_user_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__usertype____cg_user_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__usertype____cg_user_type( void* attributeData )
{
    usertype____cg_user_type__AttributeData* typedAttributeData = static_cast<usertype____cg_user_type__AttributeData*>(attributeData);

    typedAttributeData->~usertype____cg_user_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const setparam____cg_setparam_type__AttributeData setparam____cg_setparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__setparam____cg_setparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__setparam____cg_setparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__setparam____cg_setparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

setparam____cg_setparam_type__AttributeData* attributeData = newData<setparam____cg_setparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SETPARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__setparam____cg_setparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__setparam____cg_setparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__setparam____cg_setparam_type( void* attributeData )
{
    setparam____cg_setparam_type__AttributeData* typedAttributeData = static_cast<setparam____cg_setparam_type__AttributeData*>(attributeData);

    typedAttributeData->~setparam____cg_setparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_cg_type____technique__AttributeData profile_cg_type____technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_cg_type____technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_cg_type____technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_cg_type____technique( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_cg_type____technique__AttributeData* attributeData = newData<profile_cg_type____technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TECHNIQUE, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_cg_type____technique()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_cg_type____technique();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_cg_type____technique( void* attributeData )
{
    profile_cg_type____technique__AttributeData* typedAttributeData = static_cast<profile_cg_type____technique__AttributeData*>(attributeData);

    typedAttributeData->~profile_cg_type____technique__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const pass____cg_pass_type__AttributeData pass____cg_pass_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__pass____cg_pass_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__pass____cg_pass_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__pass____cg_pass_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

pass____cg_pass_type__AttributeData* attributeData = newData<pass____cg_pass_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PASS,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__pass____cg_pass_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__pass____cg_pass_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__pass____cg_pass_type( void* attributeData )
{
    pass____cg_pass_type__AttributeData* typedAttributeData = static_cast<pass____cg_pass_type__AttributeData*>(attributeData);

    typedAttributeData->~pass____cg_pass_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cg_pass_type____states( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cg_pass_type____states( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cg_pass_type____states( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cg_pass_type____states()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cg_pass_type____states();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cg_pass_type____states( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cg_pass_type____program( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cg_pass_type____program( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cg_pass_type____program( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cg_pass_type____program()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cg_pass_type____program();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cg_pass_type____program( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_CG__technique__pass__program__shader__AttributeData profile_CG__technique__pass__program__shader__AttributeData::DEFAULT = {ENUM__fx_pipeline_stage_enum__NOT_PRESENT};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_CG__technique__pass__program__shader( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_CG__technique__pass__program__shader( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_CG__technique__pass__program__shader( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_CG__technique__pass__program__shader__AttributeData* attributeData = newData<profile_CG__technique__pass__program__shader__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_STAGE:
    {
bool failed;
attributeData->stage = Utils::toEnum<ENUM__fx_pipeline_stage_enum, StringHash, ENUM__fx_pipeline_stage_enum__COUNT>(attributeValue, failed, ENUM__fx_pipeline_stage_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SHADER,
        HASH_ATTRIBUTE_STAGE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHADER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( attributeData->stage == ENUM__fx_pipeline_stage_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SHADER, HASH_ATTRIBUTE_STAGE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_CG__technique__pass__program__shader()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_CG__technique__pass__program__shader();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_CG__technique__pass__program__shader( void* attributeData )
{
    profile_CG__technique__pass__program__shader__AttributeData* typedAttributeData = static_cast<profile_CG__technique__pass__program__shader__AttributeData*>(attributeData);

    typedAttributeData->~profile_CG__technique__pass__program__shader__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_CG__technique__pass__program__shader__sources__AttributeData profile_CG__technique__pass__program__shader__sources__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_CG__technique__pass__program__shader__sources( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_CG__technique__pass__program__shader__sources( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_CG__technique__pass__program__shader__sources( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_CG__technique__pass__program__shader__sources__AttributeData* attributeData = newData<profile_CG__technique__pass__program__shader__sources__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENTRY:
    {

attributeData->entry = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SOURCES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->entry )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SOURCES, HASH_ATTRIBUTE_ENTRY, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_CG__technique__pass__program__shader__sources()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_CG__technique__pass__program__shader__sources();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_CG__technique__pass__program__shader__sources( void* attributeData )
{
    profile_CG__technique__pass__program__shader__sources__AttributeData* typedAttributeData = static_cast<profile_CG__technique__pass__program__shader__sources__AttributeData*>(attributeData);

    typedAttributeData->~profile_CG__technique__pass__program__shader__sources__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_CG__technique__pass__program__shader__bind_uniform__AttributeData profile_CG__technique__pass__program__shader__bind_uniform__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_CG__technique__pass__program__shader__bind_uniform( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_CG__technique__pass__program__shader__bind_uniform( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_CG__technique__pass__program__shader__bind_uniform( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_CG__technique__pass__program__shader__bind_uniform__AttributeData* attributeData = newData<profile_CG__technique__pass__program__shader__bind_uniform__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->symbol, strlen(attributeData->symbol));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BIND_UNIFORM,
            HASH_ATTRIBUTE_SYMBOL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_UNIFORM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->symbol )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND_UNIFORM, HASH_ATTRIBUTE_SYMBOL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_CG__technique__pass__program__shader__bind_uniform()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_CG__technique__pass__program__shader__bind_uniform();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_CG__technique__pass__program__shader__bind_uniform( void* attributeData )
{
    profile_CG__technique__pass__program__shader__bind_uniform__AttributeData* typedAttributeData = static_cast<profile_CG__technique__pass__program__shader__bind_uniform__AttributeData*>(attributeData);

    typedAttributeData->~profile_CG__technique__pass__program__shader__bind_uniform__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_CG__technique__pass__program__shader__bind_uniform__param__AttributeData profile_CG__technique__pass__program__shader__bind_uniform__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_CG__technique__pass__program__shader__bind_uniform__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_CG__technique__pass__program__shader__bind_uniform__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_CG__technique__pass__program__shader__bind_uniform__param( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_CG__technique__pass__program__shader__bind_uniform__param__AttributeData* attributeData = newData<profile_CG__technique__pass__program__shader__bind_uniform__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->ref, strlen(attributeData->ref));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARAM,
            HASH_ATTRIBUTE_REF,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_CG__technique__pass__program__shader__bind_uniform__param()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_CG__technique__pass__program__shader__bind_uniform__param();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_CG__technique__pass__program__shader__bind_uniform__param( void* attributeData )
{
    profile_CG__technique__pass__program__shader__bind_uniform__param__AttributeData* typedAttributeData = static_cast<profile_CG__technique__pass__program__shader__bind_uniform__param__AttributeData*>(attributeData);

    typedAttributeData->~profile_CG__technique__pass__program__shader__bind_uniform__param__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cg_pass_type____evaluate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cg_pass_type____evaluate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cg_pass_type____evaluate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cg_pass_type____evaluate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cg_pass_type____evaluate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cg_pass_type____evaluate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES__AttributeData profile_GLES__AttributeData::DEFAULT = {0, (const ParserChar*)"PC"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__AttributeData* attributeData = newData<profile_GLES__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->platform, strlen(attributeData->platform));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROFILE_GLES,
            HASH_ATTRIBUTE_PLATFORM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROFILE_GLES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES( void* attributeData )
{
    profile_GLES__AttributeData* typedAttributeData = static_cast<profile_GLES__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const newparam____gles_newparam_type__AttributeData newparam____gles_newparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__newparam____gles_newparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__newparam____gles_newparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__newparam____gles_newparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

newparam____gles_newparam_type__AttributeData* attributeData = newData<newparam____gles_newparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEWPARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_NEWPARAM, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__newparam____gles_newparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__newparam____gles_newparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__newparam____gles_newparam_type( void* attributeData )
{
    newparam____gles_newparam_type__AttributeData* typedAttributeData = static_cast<newparam____gles_newparam_type__AttributeData*>(attributeData);

    typedAttributeData->~newparam____gles_newparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float1x1( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float1x1( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float1x1()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float1x1();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__float1x1(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FLOAT1X1, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float1x1( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float1x2( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x2, &validate__float2_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x2);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x2);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float1x2( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float1x2()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float1x2();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        radius____float2_type__ValidationData* validationData = (radius____float2_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float1x2, &validate__float2_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT1X2,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float1x2 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float1x2 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float1x2( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float1x3( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x3, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x3);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x3);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float1x3( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float1x3()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float1x3();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float1x3, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT1X3,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float1x3 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float1x3 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float1x3( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__float1x4( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x4, &validate__float4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x4);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__float1x4);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__float1x4( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__float1x4()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__float1x4();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        orient__ValidationData* validationData = (orient__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__float1x4, &validate__float4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_FLOAT1X4,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float1x4 );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__float1x4 );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__float1x4( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sampler2D____gles_sampler_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sampler2D____gles_sampler_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sampler2D____gles_sampler_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sampler2D____gles_sampler_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sampler2D____gles_sampler_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sampler2D____gles_sampler_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const texcoord__AttributeData texcoord__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texcoord( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texcoord( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texcoord( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texcoord__AttributeData* attributeData = newData<texcoord__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->semantic, strlen(attributeData->semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXCOORD,
            HASH_ATTRIBUTE_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXCOORD, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texcoord()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texcoord();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texcoord( void* attributeData )
{
    texcoord__AttributeData* typedAttributeData = static_cast<texcoord__AttributeData*>(attributeData);

    typedAttributeData->~texcoord__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__wrap_s____gles_sampler_wrap_enum( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__wrap_s____gles_sampler_wrap_enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__wrap_s____gles_sampler_wrap_enum( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__wrap_s____gles_sampler_wrap_enum()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__wrap_s____gles_sampler_wrap_enum();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__gles_sampler_wrap_enum parameter = Utils::toEnum<ENUM__gles_sampler_wrap_enum, StringHash, ENUM__gles_sampler_wrap_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__gles_sampler_wrap_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__wrap_s____gles_sampler_wrap_enum(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_WRAP_S, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__wrap_s____gles_sampler_wrap_enum( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
ENUM__gles_sampler_wrap_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_sampler_wrap_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gles_sampler_wrap_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gles_sampler_wrap_enum, StringHash, ENUM__gles_sampler_wrap_enum__COUNT, &toEnum_ENUM__gles_sampler_wrap_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gles_sampler_wrap_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_sampler_wrap_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gles_sampler_wrap_enum, StringHash, ENUM__gles_sampler_wrap_enum__COUNT>(text, textLength, dataFunction, ENUM__gles_sampler_wrap_enumMap, baseConversionFunc, &toEnum_ENUM__gles_sampler_wrap_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_sampler_wrap_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gles_sampler_wrap_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_sampler_wrap_enum*, size_t ),
    const std::pair<StringHash, ENUM__gles_sampler_wrap_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gles_sampler_wrap_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gles_sampler_wrap_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gles_sampler_wrap_enum, StringHash, ENUM__gles_sampler_wrap_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__wrap_t____gles_sampler_wrap_enum( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__wrap_t____gles_sampler_wrap_enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__wrap_t____gles_sampler_wrap_enum( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__wrap_t____gles_sampler_wrap_enum()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__wrap_t____gles_sampler_wrap_enum();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
ENUM__gles_sampler_wrap_enum parameter = Utils::toEnum<ENUM__gles_sampler_wrap_enum, StringHash, ENUM__gles_sampler_wrap_enum__COUNT>((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed, ENUM__gles_sampler_wrap_enumMap, Utils::calculateStringHash);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__wrap_t____gles_sampler_wrap_enum(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_WRAP_T, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__wrap_t____gles_sampler_wrap_enum( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__enum____gles_enumeration_type( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__enum____gles_enumeration_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__enum____gles_enumeration_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__enum____gles_enumeration_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__enum____gles_enumeration_type();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
UNION__gles_enumeration_type parameter = toUnion_UNION__gles_enumeration_type( mLastIncompleteFragmentInCharacterData, (size_t)(mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData), failed );
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__enum____gles_enumeration_type(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ENUM, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__enum____gles_enumeration_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
UNION__gles_enumeration_type ColladaParserAutoGen15Private::toUnionPrefix_UNION__gles_enumeration_type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed
)
{
    return toDataPrefix<UNION__gles_enumeration_type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, toUnion_UNION__gles_enumeration_type);
}

//---------------------------------------------------------------------
const profile_gles_type____technique__AttributeData profile_gles_type____technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_gles_type____technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_gles_type____technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_gles_type____technique( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_gles_type____technique__AttributeData* attributeData = newData<profile_gles_type____technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TECHNIQUE, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_gles_type____technique()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_gles_type____technique();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_gles_type____technique( void* attributeData )
{
    profile_gles_type____technique__AttributeData* typedAttributeData = static_cast<profile_gles_type____technique__AttributeData*>(attributeData);

    typedAttributeData->~profile_gles_type____technique__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__AttributeData profile_GLES__technique__pass__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__AttributeData* attributeData = newData<profile_GLES__technique__pass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PASS,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass( void* attributeData )
{
    profile_GLES__technique__pass__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__alpha_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__alpha_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__alpha_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__alpha_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__alpha_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__alpha_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__alpha_func__func__AttributeData profile_GLES__technique__pass__states__alpha_func__func__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__alpha_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__alpha_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__alpha_func__func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__alpha_func__func__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__alpha_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FUNC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FUNC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FUNC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__alpha_func__func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__alpha_func__func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__alpha_func__func( void* attributeData )
{
    profile_GLES__technique__pass__states__alpha_func__func__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__alpha_func__func__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__alpha_func__func__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__alpha_func__value__AttributeData profile_GLES__technique__pass__states__alpha_func__value__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__alpha_func__value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__alpha_func__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__alpha_func__value( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__alpha_func__value__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__alpha_func__value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VALUE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gl_alpha_value_type(attributeData->value);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_VALUE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_VALUE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VALUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__alpha_func__value()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__alpha_func__value();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__alpha_func__value( void* attributeData )
{
    profile_GLES__technique__pass__states__alpha_func__value__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__alpha_func__value__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__alpha_func__value__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__blend_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__blend_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__blend_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__blend_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__blend_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__blend_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__blend_func__src__AttributeData profile_GLES__technique__pass__states__blend_func__src__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ONE, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__blend_func__src( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__blend_func__src( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__blend_func__src( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__blend_func__src__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__blend_func__src__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SRC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SRC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SRC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__blend_func__src()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__blend_func__src();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__blend_func__src( void* attributeData )
{
    profile_GLES__technique__pass__states__blend_func__src__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__blend_func__src__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__blend_func__src__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__blend_func__dest__AttributeData profile_GLES__technique__pass__states__blend_func__dest__AttributeData::DEFAULT = {ENUM__gl_blend_enum__ZERO, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__blend_func__dest( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__blend_func__dest( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__blend_func__dest( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__blend_func__dest__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__blend_func__dest__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_blend_enum, StringHash, ENUM__gl_blend_enum__COUNT>(attributeValue, failed, ENUM__gl_blend_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEST,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEST,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEST, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__blend_func__dest()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__blend_func__dest();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__blend_func__dest( void* attributeData )
{
    profile_GLES__technique__pass__states__blend_func__dest__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__blend_func__dest__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__blend_func__dest__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__clip_plane__AttributeData profile_GLES__technique__pass__states__clip_plane__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<bool>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__clip_plane( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__clip_plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__clip_plane( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__clip_plane__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__clip_plane__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2BoolList(attributeValue, attributeData->value, 0, HASH_ELEMENT_CLIP_PLANE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2BoolList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2BoolList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CLIP_PLANE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__bool4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CLIP_PLANE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__clip_plane__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CLIP_PLANE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CLIP_PLANE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_clip_planes_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CLIP_PLANE,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__clip_plane__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLIP_PLANE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__clip_plane__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    attributeData->value = GeneratedSaxParser::XSList<bool>();
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__clip_plane__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_CLIP_PLANE, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__clip_plane()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__clip_plane();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__clip_plane( void* attributeData )
{
    profile_GLES__technique__pass__states__clip_plane__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__clip_plane__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__clip_plane__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__color_mask__AttributeData profile_GLES__technique__pass__states__color_mask__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<bool>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__color_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__color_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__color_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__color_mask__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__color_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2BoolList(attributeValue, attributeData->value, 0, HASH_ELEMENT_COLOR_MASK, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2BoolList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2BoolList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__bool4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_MASK,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__color_mask__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__color_mask__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    attributeData->value = GeneratedSaxParser::XSList<bool>();
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__color_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__color_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__color_mask( void* attributeData )
{
    profile_GLES__technique__pass__states__color_mask__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__color_mask__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__color_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__cull_face__AttributeData profile_GLES__technique__pass__states__cull_face__AttributeData::DEFAULT = {ENUM__gl_face_enum__BACK, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__cull_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__cull_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__cull_face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__cull_face__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__cull_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_face_enum, StringHash, ENUM__gl_face_enum__COUNT>(attributeValue, failed, ENUM__gl_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CULL_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CULL_FACE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CULL_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__cull_face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__cull_face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__cull_face( void* attributeData )
{
    profile_GLES__technique__pass__states__cull_face__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__cull_face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__cull_face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__depth_func__AttributeData profile_GLES__technique__pass__states__depth_func__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__depth_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__depth_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__depth_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__depth_func__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__depth_func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_FUNC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_FUNC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_FUNC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__depth_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__depth_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__depth_func( void* attributeData )
{
    profile_GLES__technique__pass__states__depth_func__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__depth_func__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__depth_func__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__depth_mask__AttributeData profile_GLES__technique__pass__states__depth_mask__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__depth_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__depth_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__depth_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__depth_mask__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__depth_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__depth_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__depth_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__depth_mask( void* attributeData )
{
    profile_GLES__technique__pass__states__depth_mask__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__depth_mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__depth_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__depth_range__AttributeData profile_GLES__technique__pass__states__depth_range__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__depth_range( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__depth_range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__depth_range( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__depth_range__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__depth_range__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_DEPTH_RANGE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_RANGE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_RANGE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_RANGE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_RANGE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__depth_range__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__depth_range()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__depth_range();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__depth_range( void* attributeData )
{
    profile_GLES__technique__pass__states__depth_range__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__depth_range__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__depth_range__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__fog_color__AttributeData profile_GLES__technique__pass__states__fog_color__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__fog_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__fog_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__fog_color( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__fog_color__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__fog_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_FOG_COLOR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_COLOR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_COLOR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__fog_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_COLOR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_COLOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__fog_color__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__fog_color__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__fog_color()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__fog_color();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__fog_color( void* attributeData )
{
    profile_GLES__technique__pass__states__fog_color__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__fog_color__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__fog_color__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__fog_density__AttributeData profile_GLES__technique__pass__states__fog_density__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__fog_density( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__fog_density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__fog_density( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__fog_density__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__fog_density__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_DENSITY,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_DENSITY,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_DENSITY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__fog_density()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__fog_density();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__fog_density( void* attributeData )
{
    profile_GLES__technique__pass__states__fog_density__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__fog_density__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__fog_density__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__fog_mode__AttributeData profile_GLES__technique__pass__states__fog_mode__AttributeData::DEFAULT = {ENUM__gl_fog_enum__EXP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__fog_mode( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__fog_mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__fog_mode( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__fog_mode__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__fog_mode__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_fog_enum, StringHash, ENUM__gl_fog_enum__COUNT>(attributeValue, failed, ENUM__gl_fog_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_MODE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_MODE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_MODE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__fog_mode()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__fog_mode();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__fog_mode( void* attributeData )
{
    profile_GLES__technique__pass__states__fog_mode__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__fog_mode__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__fog_mode__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__fog_start__AttributeData profile_GLES__technique__pass__states__fog_start__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__fog_start( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__fog_start( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__fog_start( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__fog_start__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__fog_start__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_START,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_START,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_START, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__fog_start()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__fog_start();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__fog_start( void* attributeData )
{
    profile_GLES__technique__pass__states__fog_start__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__fog_start__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__fog_start__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__fog_end__AttributeData profile_GLES__technique__pass__states__fog_end__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__fog_end( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__fog_end( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__fog_end( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__fog_end__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__fog_end__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_END,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_END,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_END, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__fog_end()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__fog_end();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__fog_end( void* attributeData )
{
    profile_GLES__technique__pass__states__fog_end__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__fog_end__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__fog_end__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__front_face__AttributeData profile_GLES__technique__pass__states__front_face__AttributeData::DEFAULT = {ENUM__gl_front_face_enum__CCW, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__front_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__front_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__front_face( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__front_face__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__front_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_front_face_enum, StringHash, ENUM__gl_front_face_enum__COUNT>(attributeValue, failed, ENUM__gl_front_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FRONT_FACE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FRONT_FACE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRONT_FACE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__front_face()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__front_face();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__front_face( void* attributeData )
{
    profile_GLES__technique__pass__states__front_face__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__front_face__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__front_face__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__logic_op__AttributeData profile_GLES__technique__pass__states__logic_op__AttributeData::DEFAULT = {ENUM__gl_logic_op_enum__COPY, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__logic_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__logic_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__logic_op( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__logic_op__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__logic_op__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_logic_op_enum, StringHash, ENUM__gl_logic_op_enum__COUNT>(attributeValue, failed, ENUM__gl_logic_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOGIC_OP,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LOGIC_OP,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LOGIC_OP, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__logic_op()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__logic_op();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__logic_op( void* attributeData )
{
    profile_GLES__technique__pass__states__logic_op__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__logic_op__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__logic_op__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_ambient__AttributeData profile_GLES__technique__pass__states__light_ambient__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_ambient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_ambient__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_AMBIENT, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_AMBIENT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_AMBIENT,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_AMBIENT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_AMBIENT,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_AMBIENT,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_AMBIENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_ambient__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_AMBIENT, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_ambient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_ambient();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_ambient( void* attributeData )
{
    profile_GLES__technique__pass__states__light_ambient__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__light_ambient__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_diffuse__AttributeData profile_GLES__technique__pass__states__light_diffuse__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_diffuse( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_diffuse__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_diffuse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_DIFFUSE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_DIFFUSE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_DIFFUSE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_DIFFUSE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_DIFFUSE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_DIFFUSE,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_DIFFUSE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_diffuse__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_DIFFUSE, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_diffuse()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_diffuse();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_diffuse( void* attributeData )
{
    profile_GLES__technique__pass__states__light_diffuse__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_diffuse__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__light_diffuse__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_specular__AttributeData profile_GLES__technique__pass__states__light_specular__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_specular( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_specular__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_specular__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_SPECULAR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPECULAR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPECULAR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPECULAR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPECULAR,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPECULAR,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPECULAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_specular__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_SPECULAR, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_specular()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_specular();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_specular( void* attributeData )
{
    profile_GLES__technique__pass__states__light_specular__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_specular__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__light_specular__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_position__AttributeData profile_GLES__technique__pass__states__light_position__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_position( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_position( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_position( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_position__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_position__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_POSITION, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_POSITION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_POSITION,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_position__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_POSITION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_POSITION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_POSITION,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_position__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_POSITION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__light_position__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 1.0E0 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_position__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_position__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_POSITION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_position()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_position();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_position( void* attributeData )
{
    profile_GLES__technique__pass__states__light_position__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_position__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__light_position__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData::DEFAULT = {0, 1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_constant_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_constant_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_constant_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_constant_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_constant_attenuation( void* attributeData )
{
    profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__light_constant_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData::DEFAULT = {0, 1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_linear_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_linear_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_LINEAR_ATTENUATION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_linear_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_linear_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_linear_attenuation( void* attributeData )
{
    profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__light_linear_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData::DEFAULT = {0, 1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_quadratic_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_quadratic_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_quadratic_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_quadratic_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_quadratic_attenuation( void* attributeData )
{
    profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__light_quadratic_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData::DEFAULT = {0, 1.8E2, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_spot_cutoff( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_spot_cutoff( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_spot_cutoff( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_CUTOFF,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_CUTOFF,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_CUTOFF,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_CUTOFF,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_CUTOFF, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_SPOT_CUTOFF, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_spot_cutoff()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_spot_cutoff();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_spot_cutoff( void* attributeData )
{
    profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__light_spot_cutoff__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_spot_direction__AttributeData profile_GLES__technique__pass__states__light_spot_direction__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_spot_direction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_spot_direction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_spot_direction( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_spot_direction__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_spot_direction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_SPOT_DIRECTION, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_DIRECTION,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_DIRECTION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 -1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_spot_direction__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_SPOT_DIRECTION, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_spot_direction()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_spot_direction();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_spot_direction( void* attributeData )
{
    profile_GLES__technique__pass__states__light_spot_direction__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_spot_direction__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__light_spot_direction__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_spot_exponent__AttributeData profile_GLES__technique__pass__states__light_spot_exponent__AttributeData::DEFAULT = {0, 0.0E1, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_spot_exponent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_spot_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_spot_exponent( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_spot_exponent__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_spot_exponent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_EXPONENT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_EXPONENT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_SPOT_EXPONENT,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_SPOT_EXPONENT,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_spot_exponent__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_SPOT_EXPONENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_spot_exponent__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_SPOT_EXPONENT, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_spot_exponent()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_spot_exponent();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_spot_exponent( void* attributeData )
{
    profile_GLES__technique__pass__states__light_spot_exponent__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_spot_exponent__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__light_spot_exponent__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_model_ambient__AttributeData profile_GLES__technique__pass__states__light_model_ambient__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_model_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_model_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_model_ambient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_model_ambient__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_model_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_LIGHT_MODEL_AMBIENT, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_MODEL_AMBIENT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_MODEL_AMBIENT,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_model_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_MODEL_AMBIENT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_MODEL_AMBIENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__light_model_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("2.0E-1 2.0E-1 2.0E-1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_model_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_model_ambient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_model_ambient();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_model_ambient( void* attributeData )
{
    profile_GLES__technique__pass__states__light_model_ambient__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_model_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__light_model_ambient__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__line_width__AttributeData profile_GLES__technique__pass__states__line_width__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__line_width( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__line_width( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__line_width( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__line_width__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__line_width__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINE_WIDTH,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINE_WIDTH,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_WIDTH, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__line_width()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__line_width();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__line_width( void* attributeData )
{
    profile_GLES__technique__pass__states__line_width__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__line_width__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__line_width__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__material_ambient__AttributeData profile_GLES__technique__pass__states__material_ambient__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__material_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__material_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__material_ambient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__material_ambient__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__material_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MATERIAL_AMBIENT, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_AMBIENT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_AMBIENT,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__material_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_AMBIENT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_AMBIENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__material_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("2.0E-1 2.0E-1 2.0E-1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__material_ambient__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__material_ambient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__material_ambient();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__material_ambient( void* attributeData )
{
    profile_GLES__technique__pass__states__material_ambient__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__material_ambient__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__material_ambient__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__material_diffuse__AttributeData profile_GLES__technique__pass__states__material_diffuse__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__material_diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__material_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__material_diffuse( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__material_diffuse__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__material_diffuse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MATERIAL_DIFFUSE, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_DIFFUSE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_DIFFUSE,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__material_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_DIFFUSE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_DIFFUSE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__material_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("8.0E-1 8.0E-1 8.0E-1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__material_diffuse__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__material_diffuse()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__material_diffuse();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__material_diffuse( void* attributeData )
{
    profile_GLES__technique__pass__states__material_diffuse__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__material_diffuse__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__material_diffuse__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__material_emission__AttributeData profile_GLES__technique__pass__states__material_emission__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__material_emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__material_emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__material_emission( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__material_emission__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__material_emission__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MATERIAL_EMISSION, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_EMISSION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_EMISSION,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__material_emission__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_EMISSION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_EMISSION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__material_emission__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__material_emission__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__material_emission()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__material_emission();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__material_emission( void* attributeData )
{
    profile_GLES__technique__pass__states__material_emission__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__material_emission__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__material_emission__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__material_shininess__AttributeData profile_GLES__technique__pass__states__material_shininess__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__material_shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__material_shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__material_shininess( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__material_shininess__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__material_shininess__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_SHININESS,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_SHININESS,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_SHININESS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__material_shininess()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__material_shininess();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__material_shininess( void* attributeData )
{
    profile_GLES__technique__pass__states__material_shininess__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__material_shininess__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__material_shininess__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__material_specular__AttributeData profile_GLES__technique__pass__states__material_specular__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__material_specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__material_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__material_specular( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__material_specular__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__material_specular__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MATERIAL_SPECULAR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATERIAL_SPECULAR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_SPECULAR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__material_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATERIAL_SPECULAR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL_SPECULAR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__material_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__material_specular__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__material_specular()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__material_specular();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__material_specular( void* attributeData )
{
    profile_GLES__technique__pass__states__material_specular__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__material_specular__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__material_specular__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__model_view_matrix__AttributeData profile_GLES__technique__pass__states__model_view_matrix__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__model_view_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__model_view_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__model_view_matrix( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__model_view_matrix__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__model_view_matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_MODEL_VIEW_MATRIX, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MODEL_VIEW_MATRIX,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MODEL_VIEW_MATRIX,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__model_view_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MODEL_VIEW_MATRIX,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MODEL_VIEW_MATRIX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__model_view_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__model_view_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__model_view_matrix()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__model_view_matrix();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__model_view_matrix( void* attributeData )
{
    profile_GLES__technique__pass__states__model_view_matrix__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__model_view_matrix__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__model_view_matrix__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__point_distance_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__point_distance_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__point_distance_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_POINT_DISTANCE_ATTENUATION, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_DISTANCE_ATTENUATION,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_DISTANCE_ATTENUATION,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_DISTANCE_ATTENUATION,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_DISTANCE_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("1.0E0 0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__point_distance_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__point_distance_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__point_distance_attenuation( void* attributeData )
{
    profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__point_distance_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__point_fade_threshold_size__AttributeData profile_GLES__technique__pass__states__point_fade_threshold_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__point_fade_threshold_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__point_fade_threshold_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__point_fade_threshold_size( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__point_fade_threshold_size__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__point_fade_threshold_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__point_fade_threshold_size()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__point_fade_threshold_size();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__point_fade_threshold_size( void* attributeData )
{
    profile_GLES__technique__pass__states__point_fade_threshold_size__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__point_fade_threshold_size__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__point_fade_threshold_size__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__point_size__AttributeData profile_GLES__technique__pass__states__point_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__point_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__point_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__point_size( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__point_size__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__point_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SIZE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_SIZE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__point_size()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__point_size();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__point_size( void* attributeData )
{
    profile_GLES__technique__pass__states__point_size__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__point_size__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__point_size__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__point_size_min__AttributeData profile_GLES__technique__pass__states__point_size_min__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__point_size_min( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__point_size_min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__point_size_min( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__point_size_min__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__point_size_min__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SIZE_MIN,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_SIZE_MIN,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE_MIN, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__point_size_min()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__point_size_min();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__point_size_min( void* attributeData )
{
    profile_GLES__technique__pass__states__point_size_min__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__point_size_min__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__point_size_min__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__point_size_max__AttributeData profile_GLES__technique__pass__states__point_size_max__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__point_size_max( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__point_size_max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__point_size_max( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__point_size_max__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__point_size_max__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SIZE_MAX,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_SIZE_MAX,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SIZE_MAX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__point_size_max()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__point_size_max();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__point_size_max( void* attributeData )
{
    profile_GLES__technique__pass__states__point_size_max__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__point_size_max__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__point_size_max__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__polygon_offset__AttributeData profile_GLES__technique__pass__states__polygon_offset__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__polygon_offset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__polygon_offset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__polygon_offset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__polygon_offset__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__polygon_offset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_POLYGON_OFFSET, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_OFFSET,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float2_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("0.0E1 0.0E1", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__polygon_offset__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__polygon_offset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__polygon_offset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__polygon_offset( void* attributeData )
{
    profile_GLES__technique__pass__states__polygon_offset__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__polygon_offset__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__polygon_offset__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__projection_matrix__AttributeData profile_GLES__technique__pass__states__projection_matrix__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__projection_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__projection_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__projection_matrix( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__projection_matrix__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__projection_matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_PROJECTION_MATRIX, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PROJECTION_MATRIX,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROJECTION_MATRIX,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__projection_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PROJECTION_MATRIX,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PROJECTION_MATRIX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__projection_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    bool failed;
    failed = !characterData2FloatList("1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0", attributeData->value);
    if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__projection_matrix__AttributeData::ATTRIBUTE_VALUE_PRESENT;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__projection_matrix()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__projection_matrix();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__projection_matrix( void* attributeData )
{
    profile_GLES__technique__pass__states__projection_matrix__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__projection_matrix__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__projection_matrix__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__scissor__AttributeData profile_GLES__technique__pass__states__scissor__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<sint64>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__scissor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__scissor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__scissor( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__scissor__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__scissor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value, 0, HASH_ELEMENT_SCISSOR, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2Sint64List(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCISSOR,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__int4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCISSOR,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__scissor__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCISSOR,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCISSOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & profile_GLES__technique__pass__states__scissor__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    attributeData->value = GeneratedSaxParser::XSList<sint64>();
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__scissor()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__scissor();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__scissor( void* attributeData )
{
    profile_GLES__technique__pass__states__scissor__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__scissor__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~profile_GLES__technique__pass__states__scissor__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__shade_model__AttributeData profile_GLES__technique__pass__states__shade_model__AttributeData::DEFAULT = {ENUM__gl_shade_model_enum__SMOOTH, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__shade_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__shade_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__shade_model( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__shade_model__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__shade_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_shade_model_enum, StringHash, ENUM__gl_shade_model_enum__COUNT>(attributeValue, failed, ENUM__gl_shade_model_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SHADE_MODEL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SHADE_MODEL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SHADE_MODEL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__shade_model()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__shade_model();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__shade_model( void* attributeData )
{
    profile_GLES__technique__pass__states__shade_model__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__shade_model__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__shade_model__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_func( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__stencil_func__func__AttributeData profile_GLES__technique__pass__states__stencil_func__func__AttributeData::DEFAULT = {ENUM__gl_func_enum__ALWAYS, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_func__func( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__stencil_func__func__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__stencil_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gl_func_enum, StringHash, ENUM__gl_func_enum__COUNT>(attributeValue, failed, ENUM__gl_func_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FUNC,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FUNC,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FUNC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_func__func()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_func__func();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_func__func( void* attributeData )
{
    profile_GLES__technique__pass__states__stencil_func__func__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__stencil_func__func__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__stencil_func__func__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__stencil_func__ref__AttributeData profile_GLES__technique__pass__states__stencil_func__ref__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_func__ref( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_func__ref( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_func__ref( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__stencil_func__ref__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__stencil_func__ref__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REF,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_REF,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_func__ref()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_func__ref();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_func__ref( void* attributeData )
{
    profile_GLES__technique__pass__states__stencil_func__ref__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__stencil_func__ref__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__stencil_func__ref__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__stencil_func__mask__AttributeData profile_GLES__technique__pass__states__stencil_func__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_func__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_func__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_func__mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__stencil_func__mask__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__stencil_func__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUint8(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_func__mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_func__mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_func__mask( void* attributeData )
{
    profile_GLES__technique__pass__states__stencil_func__mask__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__stencil_func__mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__stencil_func__mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__stencil_mask__AttributeData profile_GLES__technique__pass__states__stencil_mask__AttributeData::DEFAULT = {4294967295ULL, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_mask( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__stencil_mask__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__stencil_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toSint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_MASK,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_STENCIL_MASK,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_MASK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_mask()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_mask();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_mask( void* attributeData )
{
    profile_GLES__technique__pass__states__stencil_mask__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__stencil_mask__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__stencil_mask__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_op( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_op()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_op();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_op( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__stencil_op__fail__AttributeData profile_GLES__technique__pass__states__stencil_op__fail__AttributeData::DEFAULT = {ENUM__gles_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_op__fail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_op__fail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_op__fail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__stencil_op__fail__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__stencil_op__fail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gles_stencil_op_enum, StringHash, ENUM__gles_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gles_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FAIL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_op__fail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_op__fail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_op__fail( void* attributeData )
{
    profile_GLES__technique__pass__states__stencil_op__fail__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__stencil_op__fail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__stencil_op__fail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__gles_stencil_op_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_stencil_op_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gles_stencil_op_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gles_stencil_op_enum, StringHash, ENUM__gles_stencil_op_enum__COUNT, &toEnum_ENUM__gles_stencil_op_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gles_stencil_op_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_stencil_op_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gles_stencil_op_enum, StringHash, ENUM__gles_stencil_op_enum__COUNT>(text, textLength, dataFunction, ENUM__gles_stencil_op_enumMap, baseConversionFunc, &toEnum_ENUM__gles_stencil_op_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_stencil_op_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gles_stencil_op_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_stencil_op_enum*, size_t ),
    const std::pair<StringHash, ENUM__gles_stencil_op_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gles_stencil_op_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gles_stencil_op_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gles_stencil_op_enum, StringHash, ENUM__gles_stencil_op_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__stencil_op__zfail__AttributeData profile_GLES__technique__pass__states__stencil_op__zfail__AttributeData::DEFAULT = {ENUM__gles_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_op__zfail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_op__zfail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_op__zfail( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__stencil_op__zfail__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__stencil_op__zfail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gles_stencil_op_enum, StringHash, ENUM__gles_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gles_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZFAIL,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ZFAIL,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZFAIL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_op__zfail()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_op__zfail();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_op__zfail( void* attributeData )
{
    profile_GLES__technique__pass__states__stencil_op__zfail__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__stencil_op__zfail__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__stencil_op__zfail__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__stencil_op__zpass__AttributeData profile_GLES__technique__pass__states__stencil_op__zpass__AttributeData::DEFAULT = {ENUM__gles_stencil_op_enum__KEEP, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_op__zpass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_op__zpass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_op__zpass( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__stencil_op__zpass__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__stencil_op__zpass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = Utils::toEnum<ENUM__gles_stencil_op_enum, StringHash, ENUM__gles_stencil_op_enum__COUNT>(attributeValue, failed, ENUM__gles_stencil_op_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ZPASS,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ZPASS,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ZPASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_op__zpass()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_op__zpass();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_op__zpass( void* attributeData )
{
    profile_GLES__technique__pass__states__stencil_op__zpass__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__stencil_op__zpass__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__stencil_op__zpass__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texture_pipeline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texture_pipeline( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texture_pipeline()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texture_pipeline();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texture_pipeline( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const value____gles_texture_pipeline_type__AttributeData value____gles_texture_pipeline_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__value____gles_texture_pipeline_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__value____gles_texture_pipeline_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__value____gles_texture_pipeline_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

value____gles_texture_pipeline_type__AttributeData* attributeData = newData<value____gles_texture_pipeline_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_VALUE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VALUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__value____gles_texture_pipeline_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__value____gles_texture_pipeline_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__value____gles_texture_pipeline_type( void* attributeData )
{
    value____gles_texture_pipeline_type__AttributeData* typedAttributeData = static_cast<value____gles_texture_pipeline_type__AttributeData*>(attributeData);

    typedAttributeData->~value____gles_texture_pipeline_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texcombiner( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texcombiner( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texcombiner( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texcombiner()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texcombiner();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texcombiner( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const constant____gles_texture_constant_type__AttributeData constant____gles_texture_constant_type__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<float>(), 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__constant____gles_texture_constant_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__constant____gles_texture_constant_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__constant____gles_texture_constant_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

constant____gles_texture_constant_type__AttributeData* attributeData = newData<constant____gles_texture_constant_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2FloatList(attributeValue, attributeData->value, 0, HASH_ELEMENT_CONSTANT, HASH_ATTRIBUTE_VALUE);
    }
    else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    }
#else
    {
failed = !characterData2FloatList(attributeValue, attributeData->value);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CONSTANT,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__float4_type(attributeData->value.data, attributeData->value.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CONSTANT,
            HASH_ATTRIBUTE_VALUE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= constant____gles_texture_constant_type__AttributeData::ATTRIBUTE_VALUE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CONSTANT,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONSTANT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & constant____gles_texture_constant_type__AttributeData::ATTRIBUTE_VALUE_PRESENT) == 0)
{
    attributeData->value = GeneratedSaxParser::XSList<float>();
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__constant____gles_texture_constant_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__constant____gles_texture_constant_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__constant____gles_texture_constant_type( void* attributeData )
{
    constant____gles_texture_constant_type__AttributeData* typedAttributeData = static_cast<constant____gles_texture_constant_type__AttributeData*>(attributeData);
    if (typedAttributeData->value.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~constant____gles_texture_constant_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const RGB__AttributeData RGB__AttributeData::DEFAULT = {0, ENUM__gles_texcombiner_operator_rgb_enum__NOT_PRESENT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__RGB( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__RGB( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__RGB( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

RGB__AttributeData* attributeData = newData<RGB__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPERATOR:
    {
bool failed;
attributeData->_operator = Utils::toEnum<ENUM__gles_texcombiner_operator_rgb_enum, StringHash, ENUM__gles_texcombiner_operator_rgb_enum__COUNT>(attributeValue, failed, ENUM__gles_texcombiner_operator_rgb_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RGB,
        HASH_ATTRIBUTE_OPERATOR,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SCALE:
    {
bool failed;
attributeData->scale = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RGB,
        HASH_ATTRIBUTE_SCALE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= RGB__AttributeData::ATTRIBUTE_SCALE_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RGB, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__RGB()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__RGB();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__RGB( void* attributeData )
{
    RGB__AttributeData* typedAttributeData = static_cast<RGB__AttributeData*>(attributeData);

    typedAttributeData->~RGB__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__gles_texcombiner_operator_rgb_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_operator_rgb_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gles_texcombiner_operator_rgb_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gles_texcombiner_operator_rgb_enum, StringHash, ENUM__gles_texcombiner_operator_rgb_enum__COUNT, &toEnum_ENUM__gles_texcombiner_operator_rgb_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gles_texcombiner_operator_rgb_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_operator_rgb_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gles_texcombiner_operator_rgb_enum, StringHash, ENUM__gles_texcombiner_operator_rgb_enum__COUNT>(text, textLength, dataFunction, ENUM__gles_texcombiner_operator_rgb_enumMap, baseConversionFunc, &toEnum_ENUM__gles_texcombiner_operator_rgb_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_operator_rgb_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gles_texcombiner_operator_rgb_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_operator_rgb_enum*, size_t ),
    const std::pair<StringHash, ENUM__gles_texcombiner_operator_rgb_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gles_texcombiner_operator_rgb_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gles_texcombiner_operator_rgb_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gles_texcombiner_operator_rgb_enum, StringHash, ENUM__gles_texcombiner_operator_rgb_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const argument____gles_texcombiner_argument_rgb_type__AttributeData argument____gles_texcombiner_argument_rgb_type__AttributeData::DEFAULT = {ENUM__gles_texcombiner_source_enum__NOT_PRESENT, ENUM__gles_texcombiner_operand_rgb_enum__SRC_COLOR, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__argument____gles_texcombiner_argument_rgb_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__argument____gles_texcombiner_argument_rgb_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__argument____gles_texcombiner_argument_rgb_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

argument____gles_texcombiner_argument_rgb_type__AttributeData* attributeData = newData<argument____gles_texcombiner_argument_rgb_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {
bool failed;
attributeData->source = Utils::toEnum<ENUM__gles_texcombiner_source_enum, StringHash, ENUM__gles_texcombiner_source_enum__COUNT>(attributeValue, failed, ENUM__gles_texcombiner_source_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARGUMENT,
        HASH_ATTRIBUTE_SOURCE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_OPERAND:
    {
bool failed;
attributeData->operand = Utils::toEnum<ENUM__gles_texcombiner_operand_rgb_enum, StringHash, ENUM__gles_texcombiner_operand_rgb_enum__COUNT>(attributeValue, failed, ENUM__gles_texcombiner_operand_rgb_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARGUMENT,
        HASH_ATTRIBUTE_OPERAND,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SAMPLER:
    {

attributeData->sampler = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->sampler, strlen(attributeData->sampler));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARGUMENT,
            HASH_ATTRIBUTE_SAMPLER,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARGUMENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__argument____gles_texcombiner_argument_rgb_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__argument____gles_texcombiner_argument_rgb_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__argument____gles_texcombiner_argument_rgb_type( void* attributeData )
{
    argument____gles_texcombiner_argument_rgb_type__AttributeData* typedAttributeData = static_cast<argument____gles_texcombiner_argument_rgb_type__AttributeData*>(attributeData);

    typedAttributeData->~argument____gles_texcombiner_argument_rgb_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__gles_texcombiner_source_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_source_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gles_texcombiner_source_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gles_texcombiner_source_enum, StringHash, ENUM__gles_texcombiner_source_enum__COUNT, &toEnum_ENUM__gles_texcombiner_source_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gles_texcombiner_source_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_source_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gles_texcombiner_source_enum, StringHash, ENUM__gles_texcombiner_source_enum__COUNT>(text, textLength, dataFunction, ENUM__gles_texcombiner_source_enumMap, baseConversionFunc, &toEnum_ENUM__gles_texcombiner_source_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_source_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gles_texcombiner_source_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_source_enum*, size_t ),
    const std::pair<StringHash, ENUM__gles_texcombiner_source_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gles_texcombiner_source_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gles_texcombiner_source_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gles_texcombiner_source_enum, StringHash, ENUM__gles_texcombiner_source_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__gles_texcombiner_operand_rgb_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_operand_rgb_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gles_texcombiner_operand_rgb_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gles_texcombiner_operand_rgb_enum, StringHash, ENUM__gles_texcombiner_operand_rgb_enum__COUNT, &toEnum_ENUM__gles_texcombiner_operand_rgb_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gles_texcombiner_operand_rgb_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_operand_rgb_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gles_texcombiner_operand_rgb_enum, StringHash, ENUM__gles_texcombiner_operand_rgb_enum__COUNT>(text, textLength, dataFunction, ENUM__gles_texcombiner_operand_rgb_enumMap, baseConversionFunc, &toEnum_ENUM__gles_texcombiner_operand_rgb_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_operand_rgb_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gles_texcombiner_operand_rgb_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_operand_rgb_enum*, size_t ),
    const std::pair<StringHash, ENUM__gles_texcombiner_operand_rgb_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gles_texcombiner_operand_rgb_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gles_texcombiner_operand_rgb_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gles_texcombiner_operand_rgb_enum, StringHash, ENUM__gles_texcombiner_operand_rgb_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const alpha____gles_texcombiner_command_alpha_type__AttributeData alpha____gles_texcombiner_command_alpha_type__AttributeData::DEFAULT = {0, ENUM__gles_texcombiner_operator_alpha_enum__NOT_PRESENT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__alpha____gles_texcombiner_command_alpha_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__alpha____gles_texcombiner_command_alpha_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__alpha____gles_texcombiner_command_alpha_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

alpha____gles_texcombiner_command_alpha_type__AttributeData* attributeData = newData<alpha____gles_texcombiner_command_alpha_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPERATOR:
    {
bool failed;
attributeData->_operator = Utils::toEnum<ENUM__gles_texcombiner_operator_alpha_enum, StringHash, ENUM__gles_texcombiner_operator_alpha_enum__COUNT>(attributeValue, failed, ENUM__gles_texcombiner_operator_alpha_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ALPHA,
        HASH_ATTRIBUTE_OPERATOR,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SCALE:
    {
bool failed;
attributeData->scale = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ALPHA,
        HASH_ATTRIBUTE_SCALE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= alpha____gles_texcombiner_command_alpha_type__AttributeData::ATTRIBUTE_SCALE_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__alpha____gles_texcombiner_command_alpha_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__alpha____gles_texcombiner_command_alpha_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__alpha____gles_texcombiner_command_alpha_type( void* attributeData )
{
    alpha____gles_texcombiner_command_alpha_type__AttributeData* typedAttributeData = static_cast<alpha____gles_texcombiner_command_alpha_type__AttributeData*>(attributeData);

    typedAttributeData->~alpha____gles_texcombiner_command_alpha_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__gles_texcombiner_operator_alpha_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_operator_alpha_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gles_texcombiner_operator_alpha_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gles_texcombiner_operator_alpha_enum, StringHash, ENUM__gles_texcombiner_operator_alpha_enum__COUNT, &toEnum_ENUM__gles_texcombiner_operator_alpha_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gles_texcombiner_operator_alpha_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_operator_alpha_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gles_texcombiner_operator_alpha_enum, StringHash, ENUM__gles_texcombiner_operator_alpha_enum__COUNT>(text, textLength, dataFunction, ENUM__gles_texcombiner_operator_alpha_enumMap, baseConversionFunc, &toEnum_ENUM__gles_texcombiner_operator_alpha_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_operator_alpha_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gles_texcombiner_operator_alpha_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_operator_alpha_enum*, size_t ),
    const std::pair<StringHash, ENUM__gles_texcombiner_operator_alpha_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gles_texcombiner_operator_alpha_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gles_texcombiner_operator_alpha_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gles_texcombiner_operator_alpha_enum, StringHash, ENUM__gles_texcombiner_operator_alpha_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const argument____gles_texcombiner_argument_alpha_type__AttributeData argument____gles_texcombiner_argument_alpha_type__AttributeData::DEFAULT = {ENUM__gles_texcombiner_source_enum__NOT_PRESENT, ENUM__gles_texcombiner_operand_alpha_enum__SRC_ALPHA, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__argument____gles_texcombiner_argument_alpha_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__argument____gles_texcombiner_argument_alpha_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__argument____gles_texcombiner_argument_alpha_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

argument____gles_texcombiner_argument_alpha_type__AttributeData* attributeData = newData<argument____gles_texcombiner_argument_alpha_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {
bool failed;
attributeData->source = Utils::toEnum<ENUM__gles_texcombiner_source_enum, StringHash, ENUM__gles_texcombiner_source_enum__COUNT>(attributeValue, failed, ENUM__gles_texcombiner_source_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARGUMENT,
        HASH_ATTRIBUTE_SOURCE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_OPERAND:
    {
bool failed;
attributeData->operand = Utils::toEnum<ENUM__gles_texcombiner_operand_alpha_enum, StringHash, ENUM__gles_texcombiner_operand_alpha_enum__COUNT>(attributeValue, failed, ENUM__gles_texcombiner_operand_alpha_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARGUMENT,
        HASH_ATTRIBUTE_OPERAND,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SAMPLER:
    {

attributeData->sampler = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->sampler, strlen(attributeData->sampler));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARGUMENT,
            HASH_ATTRIBUTE_SAMPLER,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARGUMENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__argument____gles_texcombiner_argument_alpha_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__argument____gles_texcombiner_argument_alpha_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__argument____gles_texcombiner_argument_alpha_type( void* attributeData )
{
    argument____gles_texcombiner_argument_alpha_type__AttributeData* typedAttributeData = static_cast<argument____gles_texcombiner_argument_alpha_type__AttributeData*>(attributeData);

    typedAttributeData->~argument____gles_texcombiner_argument_alpha_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__gles_texcombiner_operand_alpha_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_operand_alpha_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gles_texcombiner_operand_alpha_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gles_texcombiner_operand_alpha_enum, StringHash, ENUM__gles_texcombiner_operand_alpha_enum__COUNT, &toEnum_ENUM__gles_texcombiner_operand_alpha_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gles_texcombiner_operand_alpha_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_operand_alpha_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gles_texcombiner_operand_alpha_enum, StringHash, ENUM__gles_texcombiner_operand_alpha_enum__COUNT>(text, textLength, dataFunction, ENUM__gles_texcombiner_operand_alpha_enumMap, baseConversionFunc, &toEnum_ENUM__gles_texcombiner_operand_alpha_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texcombiner_operand_alpha_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gles_texcombiner_operand_alpha_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texcombiner_operand_alpha_enum*, size_t ),
    const std::pair<StringHash, ENUM__gles_texcombiner_operand_alpha_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gles_texcombiner_operand_alpha_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gles_texcombiner_operand_alpha_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gles_texcombiner_operand_alpha_enum, StringHash, ENUM__gles_texcombiner_operand_alpha_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const texenv__AttributeData texenv__AttributeData::DEFAULT = {ENUM__gles_texenv_mode_enum__NOT_PRESENT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__texenv( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__texenv( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__texenv( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

texenv__AttributeData* attributeData = newData<texenv__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPERATOR:
    {
bool failed;
attributeData->_operator = Utils::toEnum<ENUM__gles_texenv_mode_enum, StringHash, ENUM__gles_texenv_mode_enum__COUNT>(attributeValue, failed, ENUM__gles_texenv_mode_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TEXENV,
        HASH_ATTRIBUTE_OPERATOR,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SAMPLER:
    {

attributeData->sampler = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->sampler, strlen(attributeData->sampler));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TEXENV,
            HASH_ATTRIBUTE_SAMPLER,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TEXENV, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__texenv()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__texenv();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__texenv( void* attributeData )
{
    texenv__AttributeData* typedAttributeData = static_cast<texenv__AttributeData*>(attributeData);

    typedAttributeData->~texenv__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__gles_texenv_mode_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texenv_mode_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__gles_texenv_mode_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__gles_texenv_mode_enum, StringHash, ENUM__gles_texenv_mode_enum__COUNT, &toEnum_ENUM__gles_texenv_mode_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__gles_texenv_mode_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texenv_mode_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__gles_texenv_mode_enum, StringHash, ENUM__gles_texenv_mode_enum__COUNT>(text, textLength, dataFunction, ENUM__gles_texenv_mode_enumMap, baseConversionFunc, &toEnum_ENUM__gles_texenv_mode_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__gles_texenv_mode_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__gles_texenv_mode_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__gles_texenv_mode_enum*, size_t ),
    const std::pair<StringHash, ENUM__gles_texenv_mode_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__gles_texenv_mode_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__gles_texenv_mode_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__gles_texenv_mode_enum, StringHash, ENUM__gles_texenv_mode_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__alpha_test_enable__AttributeData profile_GLES__technique__pass__states__alpha_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__alpha_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__alpha_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__alpha_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__alpha_test_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__alpha_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ALPHA_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ALPHA_TEST_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ALPHA_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__alpha_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__alpha_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__alpha_test_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__alpha_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__alpha_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__alpha_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__blend_enable__AttributeData profile_GLES__technique__pass__states__blend_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__blend_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__blend_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__blend_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__blend_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__blend_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BLEND_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BLEND_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BLEND_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__blend_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__blend_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__blend_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__blend_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__blend_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__blend_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__clip_plane_enable__AttributeData profile_GLES__technique__pass__states__clip_plane_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__clip_plane_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__clip_plane_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__clip_plane_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__clip_plane_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__clip_plane_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CLIP_PLANE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CLIP_PLANE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CLIP_PLANE_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_clip_planes_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CLIP_PLANE_ENABLE,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__clip_plane_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CLIP_PLANE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__clip_plane_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__clip_plane_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__clip_plane_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__clip_plane_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__clip_plane_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__clip_plane_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__color_logic_op_enable__AttributeData profile_GLES__technique__pass__states__color_logic_op_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__color_logic_op_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__color_logic_op_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__color_logic_op_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__color_logic_op_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__color_logic_op_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__color_logic_op_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__color_logic_op_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__color_logic_op_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__color_logic_op_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__color_logic_op_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__color_logic_op_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__color_material_enable__AttributeData profile_GLES__technique__pass__states__color_material_enable__AttributeData::DEFAULT = {true, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__color_material_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__color_material_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__color_material_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__color_material_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__color_material_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COLOR_MATERIAL_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR_MATERIAL_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR_MATERIAL_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__color_material_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__color_material_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__color_material_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__color_material_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__color_material_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__color_material_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__cull_face_enable__AttributeData profile_GLES__technique__pass__states__cull_face_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__cull_face_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__cull_face_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__cull_face_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__cull_face_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__cull_face_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CULL_FACE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CULL_FACE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CULL_FACE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__cull_face_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__cull_face_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__cull_face_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__cull_face_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__cull_face_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__cull_face_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__depth_test_enable__AttributeData profile_GLES__technique__pass__states__depth_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__depth_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__depth_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__depth_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__depth_test_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__depth_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEPTH_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEPTH_TEST_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DEPTH_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__depth_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__depth_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__depth_test_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__depth_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__depth_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__depth_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__dither_enable__AttributeData profile_GLES__technique__pass__states__dither_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__dither_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__dither_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__dither_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__dither_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__dither_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DITHER_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DITHER_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DITHER_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__dither_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__dither_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__dither_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__dither_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__dither_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__dither_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__fog_enable__AttributeData profile_GLES__technique__pass__states__fog_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__fog_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__fog_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__fog_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__fog_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__fog_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FOG_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FOG_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FOG_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__fog_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__fog_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__fog_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__fog_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__fog_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__fog_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_enable__AttributeData profile_GLES__technique__pass__states__light_enable__AttributeData::DEFAULT = {0, false, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_ENABLE,
        HASH_ATTRIBUTE_INDEX,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__gles_max_lights_index_type(attributeData->index);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_ENABLE,
            HASH_ATTRIBUTE_INDEX,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= profile_GLES__technique__pass__states__light_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & profile_GLES__technique__pass__states__light_enable__AttributeData::ATTRIBUTE_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_LIGHT_ENABLE, HASH_ATTRIBUTE_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__light_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__light_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__lighting_enable__AttributeData profile_GLES__technique__pass__states__lighting_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__lighting_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__lighting_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__lighting_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__lighting_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__lighting_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHTING_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHTING_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHTING_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__lighting_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__lighting_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__lighting_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__lighting_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__lighting_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__lighting_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__light_model_two_side_enable__AttributeData profile_GLES__technique__pass__states__light_model_two_side_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__light_model_two_side_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__light_model_two_side_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__light_model_two_side_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__light_model_two_side_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__light_model_two_side_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__light_model_two_side_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__light_model_two_side_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__light_model_two_side_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__light_model_two_side_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__light_model_two_side_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__light_model_two_side_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__line_smooth_enable__AttributeData profile_GLES__technique__pass__states__line_smooth_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__line_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__line_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__line_smooth_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__line_smooth_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__line_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LINE_SMOOTH_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINE_SMOOTH_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINE_SMOOTH_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__line_smooth_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__line_smooth_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__line_smooth_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__line_smooth_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__line_smooth_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__line_smooth_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__multisample_enable__AttributeData profile_GLES__technique__pass__states__multisample_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__multisample_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__multisample_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__multisample_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__multisample_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__multisample_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MULTISAMPLE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MULTISAMPLE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MULTISAMPLE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__multisample_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__multisample_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__multisample_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__multisample_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__multisample_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__multisample_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__normalize_enable__AttributeData profile_GLES__technique__pass__states__normalize_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__normalize_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__normalize_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__normalize_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__normalize_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__normalize_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NORMALIZE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NORMALIZE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NORMALIZE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__normalize_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__normalize_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__normalize_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__normalize_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__normalize_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__normalize_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__point_smooth_enable__AttributeData profile_GLES__technique__pass__states__point_smooth_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__point_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__point_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__point_smooth_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__point_smooth_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__point_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POINT_SMOOTH_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POINT_SMOOTH_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POINT_SMOOTH_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__point_smooth_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__point_smooth_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__point_smooth_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__point_smooth_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__point_smooth_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__point_smooth_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__polygon_offset_fill_enable__AttributeData profile_GLES__technique__pass__states__polygon_offset_fill_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__polygon_offset_fill_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__polygon_offset_fill_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__polygon_offset_fill_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__polygon_offset_fill_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__polygon_offset_fill_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__polygon_offset_fill_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__polygon_offset_fill_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__polygon_offset_fill_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__polygon_offset_fill_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__polygon_offset_fill_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__polygon_offset_fill_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__rescale_normal_enable__AttributeData profile_GLES__technique__pass__states__rescale_normal_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__rescale_normal_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__rescale_normal_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__rescale_normal_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__rescale_normal_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__rescale_normal_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RESCALE_NORMAL_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_RESCALE_NORMAL_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RESCALE_NORMAL_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__rescale_normal_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__rescale_normal_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__rescale_normal_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__rescale_normal_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__rescale_normal_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__rescale_normal_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__sample_alpha_to_coverage_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__sample_alpha_to_one_enable__AttributeData profile_GLES__technique__pass__states__sample_alpha_to_one_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__sample_alpha_to_one_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__sample_alpha_to_one_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__sample_alpha_to_one_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__sample_alpha_to_one_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__sample_alpha_to_one_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__sample_alpha_to_one_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__sample_alpha_to_one_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__sample_alpha_to_one_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__sample_alpha_to_one_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__sample_alpha_to_one_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__sample_alpha_to_one_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__sample_coverage_enable__AttributeData profile_GLES__technique__pass__states__sample_coverage_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__sample_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__sample_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__sample_coverage_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__sample_coverage_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__sample_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__sample_coverage_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__sample_coverage_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__sample_coverage_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__sample_coverage_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__sample_coverage_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__sample_coverage_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__scissor_test_enable__AttributeData profile_GLES__technique__pass__states__scissor_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__scissor_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__scissor_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__scissor_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__scissor_test_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__scissor_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCISSOR_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCISSOR_TEST_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCISSOR_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__scissor_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__scissor_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__scissor_test_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__scissor_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__scissor_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__scissor_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const profile_GLES__technique__pass__states__stencil_test_enable__AttributeData profile_GLES__technique__pass__states__stencil_test_enable__AttributeData::DEFAULT = {false, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__states__stencil_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__states__stencil_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__states__stencil_test_enable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

profile_GLES__technique__pass__states__stencil_test_enable__AttributeData* attributeData = newData<profile_GLES__technique__pass__states__stencil_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_STENCIL_TEST_ENABLE,
        HASH_ATTRIBUTE_VALUE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->param, strlen(attributeData->param));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_STENCIL_TEST_ENABLE,
            HASH_ATTRIBUTE_PARAM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STENCIL_TEST_ENABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__states__stencil_test_enable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__states__stencil_test_enable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__states__stencil_test_enable( void* attributeData )
{
    profile_GLES__technique__pass__states__stencil_test_enable__AttributeData* typedAttributeData = static_cast<profile_GLES__technique__pass__states__stencil_test_enable__AttributeData*>(attributeData);

    typedAttributeData->~profile_GLES__technique__pass__states__stencil_test_enable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__profile_GLES__technique__pass__evaluate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__profile_GLES__technique__pass__evaluate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__profile_GLES__technique__pass__evaluate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__profile_GLES__technique__pass__evaluate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__profile_GLES__technique__pass__evaluate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__profile_GLES__technique__pass__evaluate( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const library_force_fields__AttributeData library_force_fields__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_force_fields( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_force_fields( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_force_fields( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_force_fields__AttributeData* attributeData = newData<library_force_fields__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_FORCE_FIELDS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_force_fields()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_force_fields();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_force_fields( void* attributeData )
{
    library_force_fields__AttributeData* typedAttributeData = static_cast<library_force_fields__AttributeData*>(attributeData);

    typedAttributeData->~library_force_fields__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const force_field__AttributeData force_field__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__force_field( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

force_field__AttributeData* attributeData = newData<force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FORCE_FIELD, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__force_field()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__force_field();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__force_field( void* attributeData )
{
    force_field__AttributeData* typedAttributeData = static_cast<force_field__AttributeData*>(attributeData);

    typedAttributeData->~force_field__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_images__AttributeData library_images__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_images( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_images( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_images( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_images__AttributeData* attributeData = newData<library_images__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_IMAGES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_images()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_images();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_images( void* attributeData )
{
    library_images__AttributeData* typedAttributeData = static_cast<library_images__AttributeData*>(attributeData);

    typedAttributeData->~library_images__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const image____image_type__AttributeData image____image_type__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__image____image_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__image____image_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__image____image_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

image____image_type__AttributeData* attributeData = newData<image____image_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_IMAGE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_IMAGE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__image____image_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__image____image_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__image____image_type( void* attributeData )
{
    image____image_type__AttributeData* typedAttributeData = static_cast<image____image_type__AttributeData*>(attributeData);

    typedAttributeData->~image____image_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const renderable__AttributeData renderable__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__renderable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__renderable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__renderable( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

renderable__AttributeData* attributeData = newData<renderable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SHARE:
    {
bool failed;
attributeData->share = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RENDERABLE,
        HASH_ATTRIBUTE_SHARE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= renderable__AttributeData::ATTRIBUTE_SHARE_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RENDERABLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & renderable__AttributeData::ATTRIBUTE_SHARE_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_RENDERABLE, HASH_ATTRIBUTE_SHARE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__renderable()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__renderable();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__renderable( void* attributeData )
{
    renderable__AttributeData* typedAttributeData = static_cast<renderable__AttributeData*>(attributeData);

    typedAttributeData->~renderable__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const image_type____init_from__AttributeData image_type____init_from__AttributeData::DEFAULT = {true};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__image_type____init_from( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__image_type____init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__image_type____init_from( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

image_type____init_from__AttributeData* attributeData = newData<image_type____init_from__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_MIPS_GENERATE:
    {
bool failed;
attributeData->mips_generate = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_MIPS_GENERATE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_FROM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__image_type____init_from()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__image_type____init_from();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__image_type____init_from( void* attributeData )
{
    image_type____init_from__AttributeData* typedAttributeData = static_cast<image_type____init_from__AttributeData*>(attributeData);

    typedAttributeData->~image_type____init_from__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_images__image__init_from__hex__AttributeData library_images__image__init_from__hex__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_images__image__init_from__hex( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
return characterData2Uint8Data(text, textLength, &ColladaParserAutoGen15::data__library_images__image__init_from__hex, 0, 0, 0);
    }
    else
    {
return characterData2Uint8Data(text, textLength, &ColladaParserAutoGen15::data__library_images__image__init_from__hex);
    }
#else
    {
return characterData2Uint8Data(text, textLength, &ColladaParserAutoGen15::data__library_images__image__init_from__hex);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_images__image__init_from__hex( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_images__image__init_from__hex( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_images__image__init_from__hex__AttributeData* attributeData = newData<library_images__image__init_from__hex__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_HEX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->format )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_HEX, HASH_ATTRIBUTE_FORMAT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_images__image__init_from__hex()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_images__image__init_from__hex();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
bool returnValue = uint8DataEnd( &ColladaParserAutoGen15::data__library_images__image__init_from__hex, 0, 0, 0 );
        return returnValue;
    }
    else
    {
return uint8DataEnd( &ColladaParserAutoGen15::data__library_images__image__init_from__hex );
    }
#else
    {
return uint8DataEnd( &ColladaParserAutoGen15::data__library_images__image__init_from__hex );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_images__image__init_from__hex( void* attributeData )
{
    library_images__image__init_from__hex__AttributeData* typedAttributeData = static_cast<library_images__image__init_from__hex__AttributeData*>(attributeData);

    typedAttributeData->~library_images__image__init_from__hex__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_2d( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_2d( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_2d( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_2d()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_2d();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_2d( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const size_exact__AttributeData size_exact__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__size_exact( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__size_exact( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__size_exact( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

size_exact__AttributeData* attributeData = newData<size_exact__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIZE_EXACT,
        HASH_ATTRIBUTE_WIDTH,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= size_exact__AttributeData::ATTRIBUTE_WIDTH_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIZE_EXACT,
        HASH_ATTRIBUTE_HEIGHT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= size_exact__AttributeData::ATTRIBUTE_HEIGHT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SIZE_EXACT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & size_exact__AttributeData::ATTRIBUTE_WIDTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIZE_EXACT, HASH_ATTRIBUTE_WIDTH, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & size_exact__AttributeData::ATTRIBUTE_HEIGHT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIZE_EXACT, HASH_ATTRIBUTE_HEIGHT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__size_exact()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__size_exact();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__size_exact( void* attributeData )
{
    size_exact__AttributeData* typedAttributeData = static_cast<size_exact__AttributeData*>(attributeData);

    typedAttributeData->~size_exact__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const size_ratio__AttributeData size_ratio__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__size_ratio( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__size_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__size_ratio( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

size_ratio__AttributeData* attributeData = newData<size_ratio__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIZE_RATIO,
        HASH_ATTRIBUTE_WIDTH,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= size_ratio__AttributeData::ATTRIBUTE_WIDTH_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIZE_RATIO,
        HASH_ATTRIBUTE_HEIGHT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= size_ratio__AttributeData::ATTRIBUTE_HEIGHT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SIZE_RATIO, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & size_ratio__AttributeData::ATTRIBUTE_WIDTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIZE_RATIO, HASH_ATTRIBUTE_WIDTH, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & size_ratio__AttributeData::ATTRIBUTE_HEIGHT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIZE_RATIO, HASH_ATTRIBUTE_HEIGHT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__size_ratio()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__size_ratio();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__size_ratio( void* attributeData )
{
    size_ratio__AttributeData* typedAttributeData = static_cast<size_ratio__AttributeData*>(attributeData);

    typedAttributeData->~size_ratio__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const mips__AttributeData mips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mips( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

mips__AttributeData* attributeData = newData<mips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LEVELS:
    {
bool failed;
attributeData->levels = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MIPS,
        HASH_ATTRIBUTE_LEVELS,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= mips__AttributeData::ATTRIBUTE_LEVELS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_AUTO_GENERATE:
    {
bool failed;
attributeData->auto_generate = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MIPS,
        HASH_ATTRIBUTE_AUTO_GENERATE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= mips__AttributeData::ATTRIBUTE_AUTO_GENERATE_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MIPS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & mips__AttributeData::ATTRIBUTE_LEVELS_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_MIPS, HASH_ATTRIBUTE_LEVELS, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & mips__AttributeData::ATTRIBUTE_AUTO_GENERATE_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_MIPS, HASH_ATTRIBUTE_AUTO_GENERATE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mips()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mips();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mips( void* attributeData )
{
    mips__AttributeData* typedAttributeData = static_cast<mips__AttributeData*>(attributeData);

    typedAttributeData->~mips__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const unnormalized__AttributeData unnormalized__AttributeData::DEFAULT = {GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__unnormalized( const ParserChar* text, size_t textLength )
{

return mImpl->data__unnormalized(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__unnormalized( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__unnormalized( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

unnormalized__AttributeData* attributeData = newData<unnormalized__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__unnormalized()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__unnormalized();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__unnormalized( void* attributeData )
{
    unnormalized__AttributeData* typedAttributeData = static_cast<unnormalized__AttributeData*>(attributeData);
    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~unnormalized__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const create_2d__array__AttributeData create_2d__array__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_2d__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_2d__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_2d__array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_2d__array__AttributeData* attributeData = newData<create_2d__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARRAY,
        HASH_ATTRIBUTE_LENGTH,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__positiveInteger(attributeData->length);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARRAY,
            HASH_ATTRIBUTE_LENGTH,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= create_2d__array__AttributeData::ATTRIBUTE_LENGTH_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & create_2d__array__AttributeData::ATTRIBUTE_LENGTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ARRAY, HASH_ATTRIBUTE_LENGTH, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_2d__array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_2d__array();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_2d__array( void* attributeData )
{
    create_2d__array__AttributeData* typedAttributeData = static_cast<create_2d__array__AttributeData*>(attributeData);

    typedAttributeData->~create_2d__array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_2d__format( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_2d__format( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_2d__format( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_2d__format()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_2d__format();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_2d__format( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const create_2d__format__hint__AttributeData create_2d__format__hint__AttributeData::DEFAULT = {ENUM__image_format_hint_channels_enum__NOT_PRESENT, ENUM__image_format_hint_range_enum__NOT_PRESENT, ENUM__image_format_hint_precision_enum__DEFAULT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_2d__format__hint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_2d__format__hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_2d__format__hint( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_2d__format__hint__AttributeData* attributeData = newData<create_2d__format__hint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CHANNELS:
    {
bool failed;
attributeData->channels = Utils::toEnum<ENUM__image_format_hint_channels_enum, StringHash, ENUM__image_format_hint_channels_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_channels_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_CHANNELS,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_RANGE:
    {
bool failed;
attributeData->range = Utils::toEnum<ENUM__image_format_hint_range_enum, StringHash, ENUM__image_format_hint_range_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_range_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_RANGE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PRECISION:
    {
bool failed;
attributeData->precision = Utils::toEnum<ENUM__image_format_hint_precision_enum, StringHash, ENUM__image_format_hint_precision_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_precision_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_PRECISION,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SPACE:
    {

attributeData->space = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_HINT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( attributeData->channels == ENUM__image_format_hint_channels_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_HINT, HASH_ATTRIBUTE_CHANNELS, 0 ) )
        return false;
}
if ( attributeData->range == ENUM__image_format_hint_range_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_HINT, HASH_ATTRIBUTE_RANGE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_2d__format__hint()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_2d__format__hint();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_2d__format__hint( void* attributeData )
{
    create_2d__format__hint__AttributeData* typedAttributeData = static_cast<create_2d__format__hint__AttributeData*>(attributeData);

    typedAttributeData->~create_2d__format__hint__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__image_format_hint_channels_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__image_format_hint_channels_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__image_format_hint_channels_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__image_format_hint_channels_enum, StringHash, ENUM__image_format_hint_channels_enum__COUNT, &toEnum_ENUM__image_format_hint_channels_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__image_format_hint_channels_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__image_format_hint_channels_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__image_format_hint_channels_enum, StringHash, ENUM__image_format_hint_channels_enum__COUNT>(text, textLength, dataFunction, ENUM__image_format_hint_channels_enumMap, baseConversionFunc, &toEnum_ENUM__image_format_hint_channels_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__image_format_hint_channels_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__image_format_hint_channels_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__image_format_hint_channels_enum*, size_t ),
    const std::pair<StringHash, ENUM__image_format_hint_channels_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__image_format_hint_channels_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__image_format_hint_channels_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__image_format_hint_channels_enum, StringHash, ENUM__image_format_hint_channels_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__image_format_hint_range_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__image_format_hint_range_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__image_format_hint_range_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__image_format_hint_range_enum, StringHash, ENUM__image_format_hint_range_enum__COUNT, &toEnum_ENUM__image_format_hint_range_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__image_format_hint_range_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__image_format_hint_range_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__image_format_hint_range_enum, StringHash, ENUM__image_format_hint_range_enum__COUNT>(text, textLength, dataFunction, ENUM__image_format_hint_range_enumMap, baseConversionFunc, &toEnum_ENUM__image_format_hint_range_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__image_format_hint_range_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__image_format_hint_range_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__image_format_hint_range_enum*, size_t ),
    const std::pair<StringHash, ENUM__image_format_hint_range_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__image_format_hint_range_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__image_format_hint_range_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__image_format_hint_range_enum, StringHash, ENUM__image_format_hint_range_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__image_format_hint_precision_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__image_format_hint_precision_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__image_format_hint_precision_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__image_format_hint_precision_enum, StringHash, ENUM__image_format_hint_precision_enum__COUNT, &toEnum_ENUM__image_format_hint_precision_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__image_format_hint_precision_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__image_format_hint_precision_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__image_format_hint_precision_enum, StringHash, ENUM__image_format_hint_precision_enum__COUNT>(text, textLength, dataFunction, ENUM__image_format_hint_precision_enumMap, baseConversionFunc, &toEnum_ENUM__image_format_hint_precision_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__image_format_hint_precision_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__image_format_hint_precision_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__image_format_hint_precision_enum*, size_t ),
    const std::pair<StringHash, ENUM__image_format_hint_precision_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__image_format_hint_precision_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__image_format_hint_precision_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__image_format_hint_precision_enum, StringHash, ENUM__image_format_hint_precision_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__exact( const ParserChar* text, size_t textLength )
{

return mImpl->data__exact(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__exact( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__exact( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__exact()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__exact();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__exact( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const create_2d__init_from__AttributeData create_2d__init_from__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_2d__init_from( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_2d__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_2d__init_from( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_2d__init_from__AttributeData* attributeData = newData<create_2d__init_from__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_MIP_INDEX:
    {
bool failed;
attributeData->mip_index = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_MIP_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_2d__init_from__AttributeData::ATTRIBUTE_MIP_INDEX_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_ARRAY_INDEX:
    {
bool failed;
attributeData->array_index = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_ARRAY_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_FROM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & create_2d__init_from__AttributeData::ATTRIBUTE_MIP_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INIT_FROM, HASH_ATTRIBUTE_MIP_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_2d__init_from()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_2d__init_from();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_2d__init_from( void* attributeData )
{
    create_2d__init_from__AttributeData* typedAttributeData = static_cast<create_2d__init_from__AttributeData*>(attributeData);

    typedAttributeData->~create_2d__init_from__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_3d( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_3d( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_3d( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_3d()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_3d();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_3d( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const create_3d__size__AttributeData create_3d__size__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_3d__size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_3d__size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_3d__size( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_3d__size__AttributeData* attributeData = newData<create_3d__size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIZE,
        HASH_ATTRIBUTE_WIDTH,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_3d__size__AttributeData::ATTRIBUTE_WIDTH_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {
bool failed;
attributeData->height = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIZE,
        HASH_ATTRIBUTE_HEIGHT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_3d__size__AttributeData::ATTRIBUTE_HEIGHT_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIZE,
        HASH_ATTRIBUTE_DEPTH,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_3d__size__AttributeData::ATTRIBUTE_DEPTH_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SIZE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & create_3d__size__AttributeData::ATTRIBUTE_WIDTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIZE, HASH_ATTRIBUTE_WIDTH, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & create_3d__size__AttributeData::ATTRIBUTE_HEIGHT_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIZE, HASH_ATTRIBUTE_HEIGHT, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & create_3d__size__AttributeData::ATTRIBUTE_DEPTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIZE, HASH_ATTRIBUTE_DEPTH, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_3d__size()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_3d__size();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_3d__size( void* attributeData )
{
    create_3d__size__AttributeData* typedAttributeData = static_cast<create_3d__size__AttributeData*>(attributeData);

    typedAttributeData->~create_3d__size__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const create_3d__array__AttributeData create_3d__array__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_3d__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_3d__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_3d__array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_3d__array__AttributeData* attributeData = newData<create_3d__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARRAY,
        HASH_ATTRIBUTE_LENGTH,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_3d__array__AttributeData::ATTRIBUTE_LENGTH_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & create_3d__array__AttributeData::ATTRIBUTE_LENGTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ARRAY, HASH_ATTRIBUTE_LENGTH, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_3d__array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_3d__array();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_3d__array( void* attributeData )
{
    create_3d__array__AttributeData* typedAttributeData = static_cast<create_3d__array__AttributeData*>(attributeData);

    typedAttributeData->~create_3d__array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_3d__format( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_3d__format( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_3d__format( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_3d__format()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_3d__format();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_3d__format( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const create_3d__format__hint__AttributeData create_3d__format__hint__AttributeData::DEFAULT = {ENUM__image_format_hint_channels_enum__NOT_PRESENT, ENUM__image_format_hint_range_enum__NOT_PRESENT, ENUM__image_format_hint_precision_enum__DEFAULT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_3d__format__hint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_3d__format__hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_3d__format__hint( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_3d__format__hint__AttributeData* attributeData = newData<create_3d__format__hint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CHANNELS:
    {
bool failed;
attributeData->channels = Utils::toEnum<ENUM__image_format_hint_channels_enum, StringHash, ENUM__image_format_hint_channels_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_channels_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_CHANNELS,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_RANGE:
    {
bool failed;
attributeData->range = Utils::toEnum<ENUM__image_format_hint_range_enum, StringHash, ENUM__image_format_hint_range_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_range_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_RANGE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PRECISION:
    {
bool failed;
attributeData->precision = Utils::toEnum<ENUM__image_format_hint_precision_enum, StringHash, ENUM__image_format_hint_precision_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_precision_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_PRECISION,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SPACE:
    {

attributeData->space = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_HINT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( attributeData->channels == ENUM__image_format_hint_channels_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_HINT, HASH_ATTRIBUTE_CHANNELS, 0 ) )
        return false;
}
if ( attributeData->range == ENUM__image_format_hint_range_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_HINT, HASH_ATTRIBUTE_RANGE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_3d__format__hint()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_3d__format__hint();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_3d__format__hint( void* attributeData )
{
    create_3d__format__hint__AttributeData* typedAttributeData = static_cast<create_3d__format__hint__AttributeData*>(attributeData);

    typedAttributeData->~create_3d__format__hint__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const create_3d__init_from__AttributeData create_3d__init_from__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_3d__init_from( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_3d__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_3d__init_from( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_3d__init_from__AttributeData* attributeData = newData<create_3d__init_from__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_DEPTH:
    {
bool failed;
attributeData->depth = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_DEPTH,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_3d__init_from__AttributeData::ATTRIBUTE_DEPTH_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_MIP_INDEX:
    {
bool failed;
attributeData->mip_index = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_MIP_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_3d__init_from__AttributeData::ATTRIBUTE_MIP_INDEX_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_ARRAY_INDEX:
    {
bool failed;
attributeData->array_index = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_ARRAY_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_FROM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & create_3d__init_from__AttributeData::ATTRIBUTE_DEPTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INIT_FROM, HASH_ATTRIBUTE_DEPTH, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & create_3d__init_from__AttributeData::ATTRIBUTE_MIP_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INIT_FROM, HASH_ATTRIBUTE_MIP_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_3d__init_from()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_3d__init_from();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_3d__init_from( void* attributeData )
{
    create_3d__init_from__AttributeData* typedAttributeData = static_cast<create_3d__init_from__AttributeData*>(attributeData);

    typedAttributeData->~create_3d__init_from__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_cube( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_cube( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_cube( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_cube()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_cube();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_cube( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const create_cube__size__AttributeData create_cube__size__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_cube__size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_cube__size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_cube__size( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_cube__size__AttributeData* attributeData = newData<create_cube__size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_WIDTH:
    {
bool failed;
attributeData->width = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIZE,
        HASH_ATTRIBUTE_WIDTH,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_cube__size__AttributeData::ATTRIBUTE_WIDTH_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SIZE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & create_cube__size__AttributeData::ATTRIBUTE_WIDTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SIZE, HASH_ATTRIBUTE_WIDTH, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_cube__size()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_cube__size();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_cube__size( void* attributeData )
{
    create_cube__size__AttributeData* typedAttributeData = static_cast<create_cube__size__AttributeData*>(attributeData);

    typedAttributeData->~create_cube__size__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const create_cube__array__AttributeData create_cube__array__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_cube__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_cube__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_cube__array( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_cube__array__AttributeData* attributeData = newData<create_cube__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARRAY,
        HASH_ATTRIBUTE_LENGTH,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_cube__array__AttributeData::ATTRIBUTE_LENGTH_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARRAY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( (attributeData->present_attributes & create_cube__array__AttributeData::ATTRIBUTE_LENGTH_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ARRAY, HASH_ATTRIBUTE_LENGTH, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_cube__array()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_cube__array();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_cube__array( void* attributeData )
{
    create_cube__array__AttributeData* typedAttributeData = static_cast<create_cube__array__AttributeData*>(attributeData);

    typedAttributeData->~create_cube__array__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_cube__format( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_cube__format( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_cube__format( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_cube__format()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_cube__format();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_cube__format( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const create_cube__format__hint__AttributeData create_cube__format__hint__AttributeData::DEFAULT = {ENUM__image_format_hint_channels_enum__NOT_PRESENT, ENUM__image_format_hint_range_enum__NOT_PRESENT, ENUM__image_format_hint_precision_enum__DEFAULT, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_cube__format__hint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_cube__format__hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_cube__format__hint( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_cube__format__hint__AttributeData* attributeData = newData<create_cube__format__hint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CHANNELS:
    {
bool failed;
attributeData->channels = Utils::toEnum<ENUM__image_format_hint_channels_enum, StringHash, ENUM__image_format_hint_channels_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_channels_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_CHANNELS,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_RANGE:
    {
bool failed;
attributeData->range = Utils::toEnum<ENUM__image_format_hint_range_enum, StringHash, ENUM__image_format_hint_range_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_range_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_RANGE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_PRECISION:
    {
bool failed;
attributeData->precision = Utils::toEnum<ENUM__image_format_hint_precision_enum, StringHash, ENUM__image_format_hint_precision_enum__COUNT>(attributeValue, failed, ENUM__image_format_hint_precision_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_HINT,
        HASH_ATTRIBUTE_PRECISION,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_SPACE:
    {

attributeData->space = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_HINT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( attributeData->channels == ENUM__image_format_hint_channels_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_HINT, HASH_ATTRIBUTE_CHANNELS, 0 ) )
        return false;
}
if ( attributeData->range == ENUM__image_format_hint_range_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_HINT, HASH_ATTRIBUTE_RANGE, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_cube__format__hint()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_cube__format__hint();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_cube__format__hint( void* attributeData )
{
    create_cube__format__hint__AttributeData* typedAttributeData = static_cast<create_cube__format__hint__AttributeData*>(attributeData);

    typedAttributeData->~create_cube__format__hint__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const create_cube__init_from__AttributeData create_cube__init_from__AttributeData::DEFAULT = {0, ENUM__image_face_enum__NOT_PRESENT, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__create_cube__init_from( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__create_cube__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__create_cube__init_from( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

create_cube__init_from__AttributeData* attributeData = newData<create_cube__init_from__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_FACE:
    {
bool failed;
attributeData->face = Utils::toEnum<ENUM__image_face_enum, StringHash, ENUM__image_face_enum__COUNT>(attributeValue, failed, ENUM__image_face_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_FACE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_MIP_INDEX:
    {
bool failed;
attributeData->mip_index = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_MIP_INDEX,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= create_cube__init_from__AttributeData::ATTRIBUTE_MIP_INDEX_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_ARRAY_INDEX:
    {
bool failed;
attributeData->array_index = GeneratedSaxParser::Utils::toUint32(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INIT_FROM,
        HASH_ATTRIBUTE_ARRAY_INDEX,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INIT_FROM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( attributeData->face == ENUM__image_face_enum__NOT_PRESENT )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INIT_FROM, HASH_ATTRIBUTE_FACE, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & create_cube__init_from__AttributeData::ATTRIBUTE_MIP_INDEX_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INIT_FROM, HASH_ATTRIBUTE_MIP_INDEX, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__create_cube__init_from()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__create_cube__init_from();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__create_cube__init_from( void* attributeData )
{
    create_cube__init_from__AttributeData* typedAttributeData = static_cast<create_cube__init_from__AttributeData*>(attributeData);

    typedAttributeData->~create_cube__init_from__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_lights__AttributeData library_lights__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_lights( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_lights( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_lights( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_lights__AttributeData* attributeData = newData<library_lights__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_LIGHTS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_lights()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_lights();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_lights( void* attributeData )
{
    library_lights__AttributeData* typedAttributeData = static_cast<library_lights__AttributeData*>(attributeData);

    typedAttributeData->~library_lights__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const light__AttributeData light__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__light( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__light( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__light( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

light__AttributeData* attributeData = newData<light__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIGHT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__light()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__light();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__light( void* attributeData )
{
    light__AttributeData* typedAttributeData = static_cast<light__AttributeData*>(attributeData);

    typedAttributeData->~light__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__light_type____technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__light_type____technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__light_type____technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__light_type____technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__light_type____technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__light_type____technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__light__technique_common__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__light__technique_common__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__light__technique_common__ambient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__light__technique_common__ambient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__light__technique_common__ambient();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__light__technique_common__ambient( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const color____targetable_float3_type__AttributeData color____targetable_float3_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__color____targetable_float3_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__color____targetable_float3_type, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__color____targetable_float3_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__color____targetable_float3_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__color____targetable_float3_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__color____targetable_float3_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

color____targetable_float3_type__AttributeData* attributeData = newData<color____targetable_float3_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COLOR,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_COLOR, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__color____targetable_float3_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__color____targetable_float3_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__color____targetable_float3_type, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_COLOR,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__color____targetable_float3_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__color____targetable_float3_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__color____targetable_float3_type( void* attributeData )
{
    color____targetable_float3_type__AttributeData* typedAttributeData = static_cast<color____targetable_float3_type__AttributeData*>(attributeData);

    typedAttributeData->~color____targetable_float3_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__directional( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__directional( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__directional( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__directional()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__directional();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__directional( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__point( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__point( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__point( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__point()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__point();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__point( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const constant_attenuation__AttributeData constant_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__constant_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__constant_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

constant_attenuation__AttributeData* attributeData = newData<constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CONSTANT_ATTENUATION,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONSTANT_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__constant_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__constant_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__constant_attenuation(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_CONSTANT_ATTENUATION, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__constant_attenuation( void* attributeData )
{
    constant_attenuation__AttributeData* typedAttributeData = static_cast<constant_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~constant_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const linear_attenuation__AttributeData linear_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__linear_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__linear_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

linear_attenuation__AttributeData* attributeData = newData<linear_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINEAR_ATTENUATION,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINEAR_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__linear_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__linear_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__linear_attenuation(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_LINEAR_ATTENUATION, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__linear_attenuation( void* attributeData )
{
    linear_attenuation__AttributeData* typedAttributeData = static_cast<linear_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~linear_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const quadratic_attenuation__AttributeData quadratic_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__quadratic_attenuation( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__quadratic_attenuation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

quadratic_attenuation__AttributeData* attributeData = newData<quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_QUADRATIC_ATTENUATION,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_QUADRATIC_ATTENUATION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__quadratic_attenuation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__quadratic_attenuation();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__quadratic_attenuation(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_QUADRATIC_ATTENUATION, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__quadratic_attenuation( void* attributeData )
{
    quadratic_attenuation__AttributeData* typedAttributeData = static_cast<quadratic_attenuation__AttributeData*>(attributeData);

    typedAttributeData->~quadratic_attenuation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__spot( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__spot( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__spot( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__spot()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__spot();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__spot( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const falloff_angle__AttributeData falloff_angle__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__falloff_angle( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__falloff_angle( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__falloff_angle( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

falloff_angle__AttributeData* attributeData = newData<falloff_angle__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FALLOFF_ANGLE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FALLOFF_ANGLE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__falloff_angle()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__falloff_angle();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__falloff_angle(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FALLOFF_ANGLE, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__falloff_angle( void* attributeData )
{
    falloff_angle__AttributeData* typedAttributeData = static_cast<falloff_angle__AttributeData*>(attributeData);

    typedAttributeData->~falloff_angle__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const falloff_exponent__AttributeData falloff_exponent__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__falloff_exponent( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__falloff_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__falloff_exponent( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

falloff_exponent__AttributeData* attributeData = newData<falloff_exponent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FALLOFF_EXPONENT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FALLOFF_EXPONENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__falloff_exponent()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__falloff_exponent();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__falloff_exponent(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_FALLOFF_EXPONENT, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__falloff_exponent( void* attributeData )
{
    falloff_exponent__AttributeData* typedAttributeData = static_cast<falloff_exponent__AttributeData*>(attributeData);

    typedAttributeData->~falloff_exponent__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_materials__AttributeData library_materials__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_materials( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_materials( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_materials( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_materials__AttributeData* attributeData = newData<library_materials__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_MATERIALS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_materials()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_materials();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_materials( void* attributeData )
{
    library_materials__AttributeData* typedAttributeData = static_cast<library_materials__AttributeData*>(attributeData);

    typedAttributeData->~library_materials__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const material__AttributeData material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__material( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

material__AttributeData* attributeData = newData<material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATERIAL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__material()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__material();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__material( void* attributeData )
{
    material__AttributeData* typedAttributeData = static_cast<material__AttributeData*>(attributeData);

    typedAttributeData->~material__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_effect__AttributeData instance_effect__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_effect( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_effect__AttributeData* attributeData = newData<instance_effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_EFFECT,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_effect__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_EFFECT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_EFFECT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_effect__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_effect__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_EFFECT, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_effect()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_effect();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_effect( void* attributeData )
{
    instance_effect__AttributeData* typedAttributeData = static_cast<instance_effect__AttributeData*>(attributeData);

    typedAttributeData->~instance_effect__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const technique_hint__AttributeData technique_hint__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__technique_hint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__technique_hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__technique_hint( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

technique_hint__AttributeData* attributeData = newData<technique_hint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->platform, strlen(attributeData->platform));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE_HINT,
            HASH_ATTRIBUTE_PLATFORM,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->profile, strlen(attributeData->profile));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE_HINT,
            HASH_ATTRIBUTE_PROFILE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->ref, strlen(attributeData->ref));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE_HINT,
            HASH_ATTRIBUTE_REF,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE_HINT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TECHNIQUE_HINT, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__technique_hint()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__technique_hint();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__technique_hint( void* attributeData )
{
    technique_hint__AttributeData* typedAttributeData = static_cast<technique_hint__AttributeData*>(attributeData);

    typedAttributeData->~technique_hint__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_effect_type____setparam__AttributeData instance_effect_type____setparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_effect_type____setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_effect_type____setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_effect_type____setparam( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_effect_type____setparam__AttributeData* attributeData = newData<instance_effect_type____setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SETPARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_effect_type____setparam()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_effect_type____setparam();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_effect_type____setparam( void* attributeData )
{
    instance_effect_type____setparam__AttributeData* typedAttributeData = static_cast<instance_effect_type____setparam__AttributeData*>(attributeData);

    typedAttributeData->~instance_effect_type____setparam__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const sampler_image__AttributeData sampler_image__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sampler_image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sampler_image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sampler_image( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sampler_image__AttributeData* attributeData = newData<sampler_image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SAMPLER_IMAGE,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sampler_image__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SAMPLER_IMAGE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SAMPLER_IMAGE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & sampler_image__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & sampler_image__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SAMPLER_IMAGE, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sampler_image()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sampler_image();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sampler_image( void* attributeData )
{
    sampler_image__AttributeData* typedAttributeData = static_cast<sampler_image__AttributeData*>(attributeData);

    typedAttributeData->~sampler_image__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sampler_states( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sampler_states( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sampler_states( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sampler_states()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sampler_states();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sampler_states( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const library_nodes__AttributeData library_nodes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_nodes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_nodes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_nodes( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_nodes__AttributeData* attributeData = newData<library_nodes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_NODES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_nodes()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_nodes();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_nodes( void* attributeData )
{
    library_nodes__AttributeData* typedAttributeData = static_cast<library_nodes__AttributeData*>(attributeData);

    typedAttributeData->~library_nodes__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const node__AttributeData node__AttributeData::DEFAULT = {0, 0, 0, 0, ENUM__node_enum__NODE, GeneratedSaxParser::XSList<ParserString>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__node( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

node__AttributeData* attributeData = newData<node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NODE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<ENUM__node_enum, StringHash, ENUM__node_enum__COUNT>(attributeValue, failed, ENUM__node_enumMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NODE,
        HASH_ATTRIBUTE_TYPE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_LAYER:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->layer, &validate__Name, HASH_ELEMENT_NODE, HASH_ATTRIBUTE_LAYER);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->layer);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->layer);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NODE,
        HASH_ATTRIBUTE_LAYER,
        attributeValue))
{
    return false;
}

if ( !failed )
    attributeData->present_attributes |= node__AttributeData::ATTRIBUTE_LAYER_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NODE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & node__AttributeData::ATTRIBUTE_LAYER_PRESENT) == 0)
{
    attributeData->layer = GeneratedSaxParser::XSList<ParserString>();
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__node()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__node();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__node( void* attributeData )
{
    node__AttributeData* typedAttributeData = static_cast<node__AttributeData*>(attributeData);
    if (typedAttributeData->layer.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~node__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__node_enum ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__node_enum (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__node_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__node_enum, StringHash, ENUM__node_enum__COUNT, &toEnum_ENUM__node_enum>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__node_enum (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__node_enum*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__node_enum, StringHash, ENUM__node_enum__COUNT>(text, textLength, dataFunction, ENUM__node_enumMap, baseConversionFunc, &toEnum_ENUM__node_enum, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__node_enum);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__node_enum (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__node_enum*, size_t ),
    const std::pair<StringHash, ENUM__node_enum>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__node_enum (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__node_enum>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__node_enum, StringHash, ENUM__node_enum__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const lookat__AttributeData lookat__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__lookat( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__lookat, &validate__float3x3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__lookat);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__lookat);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__lookat( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__lookat( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

lookat__AttributeData* attributeData = newData<lookat__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LOOKAT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LOOKAT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__lookat()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__lookat();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        float3x3__ValidationData* validationData = (float3x3__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__lookat, &validate__float3x3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3x3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_LOOKAT,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__lookat );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__lookat );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__lookat( void* attributeData )
{
    lookat__AttributeData* typedAttributeData = static_cast<lookat__AttributeData*>(attributeData);

    typedAttributeData->~lookat__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const matrix____matrix_type__AttributeData matrix____matrix_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__matrix____matrix_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__matrix____matrix_type, &validate__float4x4_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__matrix____matrix_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__matrix____matrix_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__matrix____matrix_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__matrix____matrix_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

matrix____matrix_type__AttributeData* attributeData = newData<matrix____matrix_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATRIX,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MATRIX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__matrix____matrix_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__matrix____matrix_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        bind_shape_matrix__ValidationData* validationData = (bind_shape_matrix__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__matrix____matrix_type, &validate__float4x4_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float4x4_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_MATRIX,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__matrix____matrix_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__matrix____matrix_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__matrix____matrix_type( void* attributeData )
{
    matrix____matrix_type__AttributeData* typedAttributeData = static_cast<matrix____matrix_type__AttributeData*>(attributeData);

    typedAttributeData->~matrix____matrix_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const rotate__AttributeData rotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rotate( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        rotate__ValidationData* validationData = (rotate__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__rotate, &validate__rotate__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__rotate);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__rotate);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rotate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

rotate__AttributeData* attributeData = newData<rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ROTATE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ROTATE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rotate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rotate();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        rotate__ValidationData* validationData = (rotate__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__rotate, &validate__rotate__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__rotate(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_ROTATE,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__rotate );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__rotate );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rotate( void* attributeData )
{
    rotate__AttributeData* typedAttributeData = static_cast<rotate__AttributeData*>(attributeData);

    typedAttributeData->~rotate__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const scale__AttributeData scale__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__scale( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        scale__ValidationData* validationData = (scale__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__scale, &validate__scale__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__scale);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__scale);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__scale( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__scale( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

scale__AttributeData* attributeData = newData<scale__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCALE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SCALE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__scale()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__scale();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        scale__ValidationData* validationData = (scale__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__scale, &validate__scale__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__scale(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_SCALE,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__scale );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__scale );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__scale( void* attributeData )
{
    scale__AttributeData* typedAttributeData = static_cast<scale__AttributeData*>(attributeData);

    typedAttributeData->~scale__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const skew__AttributeData skew__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__skew( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        skew__ValidationData* validationData = (skew__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__skew, &validate__float7_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__skew);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__skew);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__skew( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__skew( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

skew__AttributeData* attributeData = newData<skew__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SKEW,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SKEW, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__skew()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__skew();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        skew__ValidationData* validationData = (skew__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__skew, &validate__float7_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float7_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_SKEW,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__skew );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__skew );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__skew( void* attributeData )
{
    skew__AttributeData* typedAttributeData = static_cast<skew__AttributeData*>(attributeData);

    typedAttributeData->~skew__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const translate__AttributeData translate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__translate( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        translate__ValidationData* validationData = (translate__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__translate, &validate__translate__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__translate);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__translate);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__translate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

translate__AttributeData* attributeData = newData<translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TRANSLATE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TRANSLATE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__translate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__translate();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        translate__ValidationData* validationData = (translate__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__translate, &validate__translate__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__translate(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_TRANSLATE,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__translate );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__translate );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__translate( void* attributeData )
{
    translate__AttributeData* typedAttributeData = static_cast<translate__AttributeData*>(attributeData);

    typedAttributeData->~translate__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_camera__AttributeData instance_camera__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_camera( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_camera( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_camera( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_camera__AttributeData* attributeData = newData<instance_camera__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_CAMERA,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_camera__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_CAMERA,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_CAMERA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_camera__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_camera__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_CAMERA, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_camera()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_camera();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_camera( void* attributeData )
{
    instance_camera__AttributeData* typedAttributeData = static_cast<instance_camera__AttributeData*>(attributeData);

    typedAttributeData->~instance_camera__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_controller__AttributeData instance_controller__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_controller( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_controller( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_controller( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_controller__AttributeData* attributeData = newData<instance_controller__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_CONTROLLER,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_controller__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_CONTROLLER,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_CONTROLLER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_controller__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_controller__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_CONTROLLER, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_controller()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_controller();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_controller( void* attributeData )
{
    instance_controller__AttributeData* typedAttributeData = static_cast<instance_controller__AttributeData*>(attributeData);

    typedAttributeData->~instance_controller__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__skeleton( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__skeleton( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__skeleton( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__skeleton()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__skeleton();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
COLLADABU::URI parameter = GeneratedSaxParser::Utils::toURI((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__skeleton(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_SKELETON, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__skeleton( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bind_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bind_material( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bind_material()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bind_material();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bind_material( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bind_material_type____technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bind_material_type____technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bind_material_type____technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bind_material_type____technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bind_material_type____technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bind_material_type____technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const instance_material____instance_material_type__AttributeData instance_material____instance_material_type__AttributeData::DEFAULT = {0, 0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_material____instance_material_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_material____instance_material_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_material____instance_material_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_material____instance_material_type__AttributeData* attributeData = newData<instance_material____instance_material_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->symbol, strlen(attributeData->symbol));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_MATERIAL,
            HASH_ATTRIBUTE_SYMBOL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {
bool failed;
attributeData->target = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_MATERIAL,
        HASH_ATTRIBUTE_TARGET,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_material____instance_material_type__AttributeData::ATTRIBUTE_TARGET_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_MATERIAL,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_MATERIAL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_material____instance_material_type__AttributeData::ATTRIBUTE_TARGET_PRESENT) == 0)
{
    attributeData->target = COLLADABU::URI("");
}
if ( !attributeData->symbol )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_MATERIAL, HASH_ATTRIBUTE_SYMBOL, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & instance_material____instance_material_type__AttributeData::ATTRIBUTE_TARGET_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_MATERIAL, HASH_ATTRIBUTE_TARGET, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_material____instance_material_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_material____instance_material_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_material____instance_material_type( void* attributeData )
{
    instance_material____instance_material_type__AttributeData* typedAttributeData = static_cast<instance_material____instance_material_type__AttributeData*>(attributeData);

    typedAttributeData->~instance_material____instance_material_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_material_type____bind__AttributeData instance_material_type____bind__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_material_type____bind( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_material_type____bind( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_material_type____bind( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_material_type____bind__AttributeData* attributeData = newData<instance_material_type____bind__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->semantic, strlen(attributeData->semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BIND,
            HASH_ATTRIBUTE_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->semantic )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND, HASH_ATTRIBUTE_SEMANTIC, 0 ) )
        return false;
}
if ( !attributeData->target )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND, HASH_ATTRIBUTE_TARGET, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_material_type____bind()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_material_type____bind();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_material_type____bind( void* attributeData )
{
    instance_material_type____bind__AttributeData* typedAttributeData = static_cast<instance_material_type____bind__AttributeData*>(attributeData);

    typedAttributeData->~instance_material_type____bind__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const bind_vertex_input__AttributeData bind_vertex_input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bind_vertex_input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bind_vertex_input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bind_vertex_input( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

bind_vertex_input__AttributeData* attributeData = newData<bind_vertex_input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->semantic, strlen(attributeData->semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BIND_VERTEX_INPUT,
            HASH_ATTRIBUTE_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INPUT_SEMANTIC:
    {

attributeData->input_semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->input_semantic, strlen(attributeData->input_semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BIND_VERTEX_INPUT,
            HASH_ATTRIBUTE_INPUT_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_INPUT_SET:
    {
bool failed;
attributeData->input_set = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BIND_VERTEX_INPUT,
        HASH_ATTRIBUTE_INPUT_SET,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= bind_vertex_input__AttributeData::ATTRIBUTE_INPUT_SET_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_VERTEX_INPUT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->semantic )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND_VERTEX_INPUT, HASH_ATTRIBUTE_SEMANTIC, 0 ) )
        return false;
}
if ( !attributeData->input_semantic )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND_VERTEX_INPUT, HASH_ATTRIBUTE_INPUT_SEMANTIC, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bind_vertex_input()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bind_vertex_input();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bind_vertex_input( void* attributeData )
{
    bind_vertex_input__AttributeData* typedAttributeData = static_cast<bind_vertex_input__AttributeData*>(attributeData);

    typedAttributeData->~bind_vertex_input__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_geometry__AttributeData instance_geometry__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_geometry( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_geometry__AttributeData* attributeData = newData<instance_geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_GEOMETRY,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_geometry__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_GEOMETRY,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_GEOMETRY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_geometry__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_geometry__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_GEOMETRY, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_geometry()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_geometry();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_geometry( void* attributeData )
{
    instance_geometry__AttributeData* typedAttributeData = static_cast<instance_geometry__AttributeData*>(attributeData);

    typedAttributeData->~instance_geometry__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_light__AttributeData instance_light__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_light( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_light( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_light( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_light__AttributeData* attributeData = newData<instance_light__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_LIGHT,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_light__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_LIGHT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_LIGHT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_light__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_light__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_LIGHT, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_light()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_light();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_light( void* attributeData )
{
    instance_light__AttributeData* typedAttributeData = static_cast<instance_light__AttributeData*>(attributeData);

    typedAttributeData->~instance_light__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_node__AttributeData instance_node__AttributeData::DEFAULT = {0, 0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_node( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_node__AttributeData* attributeData = newData<instance_node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROXY:
    {
bool failed;
attributeData->proxy = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_NODE,
        HASH_ATTRIBUTE_PROXY,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_node__AttributeData::ATTRIBUTE_PROXY_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_NODE,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_node__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_NODE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_NODE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_node__AttributeData::ATTRIBUTE_PROXY_PRESENT) == 0)
{
    attributeData->proxy = COLLADABU::URI("");
}
if ((attributeData->present_attributes & instance_node__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_node__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_NODE, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_node()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_node();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_node( void* attributeData )
{
    instance_node__AttributeData* typedAttributeData = static_cast<instance_node__AttributeData*>(attributeData);

    typedAttributeData->~instance_node__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_physics_materials__AttributeData library_physics_materials__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_physics_materials( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_physics_materials( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_physics_materials( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_physics_materials__AttributeData* attributeData = newData<library_physics_materials__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_physics_materials()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_physics_materials();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_physics_materials( void* attributeData )
{
    library_physics_materials__AttributeData* typedAttributeData = static_cast<library_physics_materials__AttributeData*>(attributeData);

    typedAttributeData->~library_physics_materials__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const physics_material__AttributeData physics_material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__physics_material( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

physics_material__AttributeData* attributeData = newData<physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_MATERIAL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__physics_material()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__physics_material();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__physics_material( void* attributeData )
{
    physics_material__AttributeData* typedAttributeData = static_cast<physics_material__AttributeData*>(attributeData);

    typedAttributeData->~physics_material__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__physics_material_type____technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__physics_material_type____technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__physics_material_type____technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__physics_material_type____technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__physics_material_type____technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__physics_material_type____technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const dynamic_friction__AttributeData dynamic_friction__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__dynamic_friction( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__dynamic_friction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__dynamic_friction( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

dynamic_friction__AttributeData* attributeData = newData<dynamic_friction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DYNAMIC_FRICTION,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DYNAMIC_FRICTION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__dynamic_friction()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__dynamic_friction();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__dynamic_friction(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DYNAMIC_FRICTION, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__dynamic_friction( void* attributeData )
{
    dynamic_friction__AttributeData* typedAttributeData = static_cast<dynamic_friction__AttributeData*>(attributeData);

    typedAttributeData->~dynamic_friction__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const restitution__AttributeData restitution__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__restitution( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__restitution( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__restitution( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

restitution__AttributeData* attributeData = newData<restitution__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_RESTITUTION,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RESTITUTION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__restitution()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__restitution();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__restitution(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_RESTITUTION, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__restitution( void* attributeData )
{
    restitution__AttributeData* typedAttributeData = static_cast<restitution__AttributeData*>(attributeData);

    typedAttributeData->~restitution__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const static_friction__AttributeData static_friction__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__static_friction( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__static_friction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__static_friction( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

static_friction__AttributeData* attributeData = newData<static_friction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_STATIC_FRICTION,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STATIC_FRICTION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__static_friction()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__static_friction();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__static_friction(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_STATIC_FRICTION, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__static_friction( void* attributeData )
{
    static_friction__AttributeData* typedAttributeData = static_cast<static_friction__AttributeData*>(attributeData);

    typedAttributeData->~static_friction__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_physics_models__AttributeData library_physics_models__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_physics_models( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_physics_models( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_physics_models( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_physics_models__AttributeData* attributeData = newData<library_physics_models__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_MODELS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_physics_models()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_physics_models();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_physics_models( void* attributeData )
{
    library_physics_models__AttributeData* typedAttributeData = static_cast<library_physics_models__AttributeData*>(attributeData);

    typedAttributeData->~library_physics_models__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const physics_model__AttributeData physics_model__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__physics_model( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

physics_model__AttributeData* attributeData = newData<physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_MODEL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__physics_model()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__physics_model();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__physics_model( void* attributeData )
{
    physics_model__AttributeData* typedAttributeData = static_cast<physics_model__AttributeData*>(attributeData);

    typedAttributeData->~physics_model__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const rigid_body__AttributeData rigid_body__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_body( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_body( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_body( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

rigid_body__AttributeData* attributeData = newData<rigid_body__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_RIGID_BODY,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RIGID_BODY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_RIGID_BODY, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_body()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_body();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_body( void* attributeData )
{
    rigid_body__AttributeData* typedAttributeData = static_cast<rigid_body__AttributeData*>(attributeData);

    typedAttributeData->~rigid_body__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_body_type____technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_body_type____technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_body_type____technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_body_type____technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_body_type____technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_body_type____technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const rigid_body__technique_common__dynamic__AttributeData rigid_body__technique_common__dynamic__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_body__technique_common__dynamic( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_body__technique_common__dynamic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_body__technique_common__dynamic( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

rigid_body__technique_common__dynamic__AttributeData* attributeData = newData<rigid_body__technique_common__dynamic__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DYNAMIC,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DYNAMIC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_body__technique_common__dynamic()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_body__technique_common__dynamic();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__rigid_body__technique_common__dynamic(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DYNAMIC, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_body__technique_common__dynamic( void* attributeData )
{
    rigid_body__technique_common__dynamic__AttributeData* typedAttributeData = static_cast<rigid_body__technique_common__dynamic__AttributeData*>(attributeData);

    typedAttributeData->~rigid_body__technique_common__dynamic__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const mass__AttributeData mass__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mass( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mass( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

mass__AttributeData* attributeData = newData<mass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MASS,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MASS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mass()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mass();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__mass(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MASS, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mass( void* attributeData )
{
    mass__AttributeData* typedAttributeData = static_cast<mass__AttributeData*>(attributeData);

    typedAttributeData->~mass__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_body__technique_common__mass_frame( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_body__technique_common__mass_frame( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_body__technique_common__mass_frame( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_body__technique_common__mass_frame()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_body__technique_common__mass_frame();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_body__technique_common__mass_frame( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const inertia__AttributeData inertia__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__inertia( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__inertia, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__inertia);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__inertia);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__inertia( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__inertia( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

inertia__AttributeData* attributeData = newData<inertia__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INERTIA,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INERTIA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__inertia()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__inertia();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__inertia, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_INERTIA,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__inertia );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__inertia );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__inertia( void* attributeData )
{
    inertia__AttributeData* typedAttributeData = static_cast<inertia__AttributeData*>(attributeData);

    typedAttributeData->~inertia__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_physics_material__AttributeData instance_physics_material__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_physics_material( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_physics_material__AttributeData* attributeData = newData<instance_physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_physics_material__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_physics_material__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_physics_material__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_physics_material()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_physics_material();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_physics_material( void* attributeData )
{
    instance_physics_material__AttributeData* typedAttributeData = static_cast<instance_physics_material__AttributeData*>(attributeData);

    typedAttributeData->~instance_physics_material__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_body__technique_common__shape( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_body__technique_common__shape( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_body__technique_common__shape( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_body__technique_common__shape()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_body__technique_common__shape();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_body__technique_common__shape( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const rigid_body__technique_common__shape__hollow__AttributeData rigid_body__technique_common__shape__hollow__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_body__technique_common__shape__hollow( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_body__technique_common__shape__hollow( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_body__technique_common__shape__hollow( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

rigid_body__technique_common__shape__hollow__AttributeData* attributeData = newData<rigid_body__technique_common__shape__hollow__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_HOLLOW,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_HOLLOW, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_body__technique_common__shape__hollow()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_body__technique_common__shape__hollow();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__rigid_body__technique_common__shape__hollow(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_HOLLOW, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_body__technique_common__shape__hollow( void* attributeData )
{
    rigid_body__technique_common__shape__hollow__AttributeData* typedAttributeData = static_cast<rigid_body__technique_common__shape__hollow__AttributeData*>(attributeData);

    typedAttributeData->~rigid_body__technique_common__shape__hollow__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const density__AttributeData density__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__density( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__density( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

density__AttributeData* attributeData = newData<density__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DENSITY,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DENSITY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__density()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__density();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__density(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DENSITY, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__density( void* attributeData )
{
    density__AttributeData* typedAttributeData = static_cast<density__AttributeData*>(attributeData);

    typedAttributeData->~density__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__box( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__box( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__box( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__box()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__box();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__box( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__half_extents( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half_extents, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half_extents);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__half_extents);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__half_extents( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__half_extents( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__half_extents()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__half_extents();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__half_extents, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_HALF_EXTENTS,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half_extents );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__half_extents );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__half_extents( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cylinder____cylinder_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cylinder____cylinder_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cylinder____cylinder_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cylinder____cylinder_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cylinder____cylinder_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cylinder____cylinder_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__height( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__height( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__height()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__height();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__height(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_HEIGHT, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__height( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__capsule( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__capsule( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__capsule( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__capsule()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__capsule();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__capsule( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__radius____float3_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__radius____float3_type, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__radius____float3_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__radius____float3_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__radius____float3_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__radius____float3_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__radius____float3_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__radius____float3_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__radius____float3_type, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_RADIUS,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__radius____float3_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__radius____float3_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__radius____float3_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const rigid_constraint__AttributeData rigid_constraint__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_constraint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_constraint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_constraint( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

rigid_constraint__AttributeData* attributeData = newData<rigid_constraint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_RIGID_CONSTRAINT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RIGID_CONSTRAINT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->sid )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_RIGID_CONSTRAINT, HASH_ATTRIBUTE_SID, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_constraint()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_constraint();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_constraint( void* attributeData )
{
    rigid_constraint__AttributeData* typedAttributeData = static_cast<rigid_constraint__AttributeData*>(attributeData);

    typedAttributeData->~rigid_constraint__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const ref_attachment__AttributeData ref_attachment__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ref_attachment( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ref_attachment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ref_attachment( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

ref_attachment__AttributeData* attributeData = newData<ref_attachment__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_RIGID_BODY:
    {
bool failed;
attributeData->rigid_body = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REF_ATTACHMENT,
        HASH_ATTRIBUTE_RIGID_BODY,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ref_attachment__AttributeData::ATTRIBUTE_RIGID_BODY_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REF_ATTACHMENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & ref_attachment__AttributeData::ATTRIBUTE_RIGID_BODY_PRESENT) == 0)
{
    attributeData->rigid_body = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ref_attachment()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ref_attachment();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ref_attachment( void* attributeData )
{
    ref_attachment__AttributeData* typedAttributeData = static_cast<ref_attachment__AttributeData*>(attributeData);

    typedAttributeData->~ref_attachment__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const attachment__AttributeData attachment__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__attachment( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__attachment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__attachment( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

attachment__AttributeData* attributeData = newData<attachment__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_RIGID_BODY:
    {
bool failed;
attributeData->rigid_body = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ATTACHMENT,
        HASH_ATTRIBUTE_RIGID_BODY,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= attachment__AttributeData::ATTRIBUTE_RIGID_BODY_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ATTACHMENT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & attachment__AttributeData::ATTRIBUTE_RIGID_BODY_PRESENT) == 0)
{
    attributeData->rigid_body = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__attachment()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__attachment();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__attachment( void* attributeData )
{
    attachment__AttributeData* typedAttributeData = static_cast<attachment__AttributeData*>(attributeData);

    typedAttributeData->~attachment__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_constraint_type____technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_constraint_type____technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_constraint_type____technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_constraint_type____technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_constraint_type____technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_constraint_type____technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const enabled__AttributeData enabled__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__enabled( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__enabled( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__enabled( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

enabled__AttributeData* attributeData = newData<enabled__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ENABLED,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ENABLED, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__enabled()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__enabled();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__enabled(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_ENABLED, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__enabled( void* attributeData )
{
    enabled__AttributeData* typedAttributeData = static_cast<enabled__AttributeData*>(attributeData);

    typedAttributeData->~enabled__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const interpenetrate__AttributeData interpenetrate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__interpenetrate( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__interpenetrate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__interpenetrate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

interpenetrate__AttributeData* attributeData = newData<interpenetrate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INTERPENETRATE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INTERPENETRATE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__interpenetrate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__interpenetrate();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__interpenetrate(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_INTERPENETRATE, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__interpenetrate( void* attributeData )
{
    interpenetrate__AttributeData* typedAttributeData = static_cast<interpenetrate__AttributeData*>(attributeData);

    typedAttributeData->~interpenetrate__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_constraint__technique_common__limits( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_constraint__technique_common__limits( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_constraint__technique_common__limits( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_constraint__technique_common__limits()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_constraint__technique_common__limits();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_constraint__technique_common__limits( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__swing_cone_and_twist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__swing_cone_and_twist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__swing_cone_and_twist( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__swing_cone_and_twist()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__swing_cone_and_twist();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__swing_cone_and_twist( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__min____targetable_float3_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__min____targetable_float3_type, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__min____targetable_float3_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__min____targetable_float3_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__min____targetable_float3_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__min____targetable_float3_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

min____targetable_float3_type__AttributeData* attributeData = newData<min____targetable_float3_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MIN,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MIN, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__min____targetable_float3_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__min____targetable_float3_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__min____targetable_float3_type, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_MIN,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__min____targetable_float3_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__min____targetable_float3_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__min____targetable_float3_type( void* attributeData )
{
    min____targetable_float3_type__AttributeData* typedAttributeData = static_cast<min____targetable_float3_type__AttributeData*>(attributeData);

    typedAttributeData->~min____targetable_float3_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__max____targetable_float3_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__max____targetable_float3_type, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__max____targetable_float3_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__max____targetable_float3_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__max____targetable_float3_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__max____targetable_float3_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

max____targetable_float3_type__AttributeData* attributeData = newData<max____targetable_float3_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MAX,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MAX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__max____targetable_float3_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__max____targetable_float3_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__max____targetable_float3_type, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_MAX,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__max____targetable_float3_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__max____targetable_float3_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__max____targetable_float3_type( void* attributeData )
{
    max____targetable_float3_type__AttributeData* typedAttributeData = static_cast<max____targetable_float3_type__AttributeData*>(attributeData);

    typedAttributeData->~max____targetable_float3_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rigid_constraint__technique_common__limits__linear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rigid_constraint__technique_common__limits__linear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rigid_constraint__technique_common__limits__linear( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rigid_constraint__technique_common__limits__linear()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rigid_constraint__technique_common__limits__linear();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rigid_constraint__technique_common__limits__linear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__spring( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__spring( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__spring( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__spring()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__spring();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__spring( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__angular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__angular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__angular( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__angular()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__angular();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__angular( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const stiffness__AttributeData stiffness__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__stiffness( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__stiffness( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__stiffness( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

stiffness__AttributeData* attributeData = newData<stiffness__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_STIFFNESS,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_STIFFNESS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__stiffness()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__stiffness();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__stiffness(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_STIFFNESS, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__stiffness( void* attributeData )
{
    stiffness__AttributeData* typedAttributeData = static_cast<stiffness__AttributeData*>(attributeData);

    typedAttributeData->~stiffness__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const damping__AttributeData damping__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__damping( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__damping( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__damping( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

damping__AttributeData* attributeData = newData<damping__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DAMPING,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DAMPING, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__damping()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__damping();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__damping(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DAMPING, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__damping( void* attributeData )
{
    damping__AttributeData* typedAttributeData = static_cast<damping__AttributeData*>(attributeData);

    typedAttributeData->~damping__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const target_value__AttributeData target_value__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__target_value( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__target_value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__target_value( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

target_value__AttributeData* attributeData = newData<target_value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TARGET_VALUE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TARGET_VALUE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__target_value()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__target_value();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__target_value(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_TARGET_VALUE, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__target_value( void* attributeData )
{
    target_value__AttributeData* typedAttributeData = static_cast<target_value__AttributeData*>(attributeData);

    typedAttributeData->~target_value__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__spring__linear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__spring__linear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__spring__linear( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__spring__linear()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__spring__linear();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__spring__linear( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const instance_physics_model__AttributeData instance_physics_model__AttributeData::DEFAULT = {0, 0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_physics_model( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_physics_model__AttributeData* attributeData = newData<instance_physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_PHYSICS_MODEL,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_physics_model__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_PHYSICS_MODEL,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PARENT:
    {
bool failed;
attributeData->parent = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_PHYSICS_MODEL,
        HASH_ATTRIBUTE_PARENT,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_physics_model__AttributeData::ATTRIBUTE_PARENT_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_PHYSICS_MODEL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_physics_model__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ((attributeData->present_attributes & instance_physics_model__AttributeData::ATTRIBUTE_PARENT_PRESENT) == 0)
{
    attributeData->parent = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_physics_model__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_PHYSICS_MODEL, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_physics_model()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_physics_model();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_physics_model( void* attributeData )
{
    instance_physics_model__AttributeData* typedAttributeData = static_cast<instance_physics_model__AttributeData*>(attributeData);

    typedAttributeData->~instance_physics_model__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_force_field__AttributeData instance_force_field__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_force_field( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_force_field__AttributeData* attributeData = newData<instance_force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_FORCE_FIELD,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_force_field__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_FORCE_FIELD,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_FORCE_FIELD, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_force_field__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_force_field__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_FORCE_FIELD, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_force_field()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_force_field();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_force_field( void* attributeData )
{
    instance_force_field__AttributeData* typedAttributeData = static_cast<instance_force_field__AttributeData*>(attributeData);

    typedAttributeData->~instance_force_field__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_rigid_body__AttributeData instance_rigid_body__AttributeData::DEFAULT = {0, 0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_rigid_body( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_rigid_body( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_rigid_body( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_rigid_body__AttributeData* attributeData = newData<instance_rigid_body__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_BODY:
    {

attributeData->body = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->body, strlen(attributeData->body));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_RIGID_BODY,
            HASH_ATTRIBUTE_BODY,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_RIGID_BODY,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {
bool failed;
attributeData->target = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_RIGID_BODY,
        HASH_ATTRIBUTE_TARGET,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_rigid_body__AttributeData::ATTRIBUTE_TARGET_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_RIGID_BODY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_rigid_body__AttributeData::ATTRIBUTE_TARGET_PRESENT) == 0)
{
    attributeData->target = COLLADABU::URI("");
}
if ( !attributeData->body )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_RIGID_BODY, HASH_ATTRIBUTE_BODY, 0 ) )
        return false;
}
if ( (attributeData->present_attributes & instance_rigid_body__AttributeData::ATTRIBUTE_TARGET_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_RIGID_BODY, HASH_ATTRIBUTE_TARGET, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_rigid_body()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_rigid_body();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_rigid_body( void* attributeData )
{
    instance_rigid_body__AttributeData* typedAttributeData = static_cast<instance_rigid_body__AttributeData*>(attributeData);

    typedAttributeData->~instance_rigid_body__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_rigid_body_type____technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_rigid_body_type____technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_rigid_body_type____technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_rigid_body_type____technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_rigid_body_type____technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_rigid_body_type____technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__angular_velocity( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__angular_velocity, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__angular_velocity);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__angular_velocity);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__angular_velocity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__angular_velocity( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__angular_velocity()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__angular_velocity();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__angular_velocity, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_ANGULAR_VELOCITY,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__angular_velocity );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__angular_velocity );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__angular_velocity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__velocity( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__velocity, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__velocity);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__velocity);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__velocity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__velocity( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__velocity()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__velocity();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__velocity, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_VELOCITY,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__velocity );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__velocity );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__velocity( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const instance_rigid_body__technique_common__dynamic__AttributeData instance_rigid_body__technique_common__dynamic__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_rigid_body__technique_common__dynamic( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_rigid_body__technique_common__dynamic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_rigid_body__technique_common__dynamic( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_rigid_body__technique_common__dynamic__AttributeData* attributeData = newData<instance_rigid_body__technique_common__dynamic__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DYNAMIC,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DYNAMIC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_rigid_body__technique_common__dynamic()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_rigid_body__technique_common__dynamic();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__instance_rigid_body__technique_common__dynamic(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_DYNAMIC, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_rigid_body__technique_common__dynamic( void* attributeData )
{
    instance_rigid_body__technique_common__dynamic__AttributeData* typedAttributeData = static_cast<instance_rigid_body__technique_common__dynamic__AttributeData*>(attributeData);

    typedAttributeData->~instance_rigid_body__technique_common__dynamic__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_rigid_body__technique_common__mass_frame( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_rigid_body__technique_common__mass_frame( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_rigid_body__technique_common__mass_frame( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_rigid_body__technique_common__mass_frame()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_rigid_body__technique_common__mass_frame();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_rigid_body__technique_common__mass_frame( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_rigid_body__technique_common__shape( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_rigid_body__technique_common__shape( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_rigid_body__technique_common__shape( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_rigid_body__technique_common__shape()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_rigid_body__technique_common__shape();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_rigid_body__technique_common__shape( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const instance_rigid_body__technique_common__shape__hollow__AttributeData instance_rigid_body__technique_common__shape__hollow__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_rigid_body__technique_common__shape__hollow( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_rigid_body__technique_common__shape__hollow( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_rigid_body__technique_common__shape__hollow( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_rigid_body__technique_common__shape__hollow__AttributeData* attributeData = newData<instance_rigid_body__technique_common__shape__hollow__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_HOLLOW,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_HOLLOW, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_rigid_body__technique_common__shape__hollow()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_rigid_body__technique_common__shape__hollow();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
bool parameter = GeneratedSaxParser::Utils::toBool((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__instance_rigid_body__technique_common__shape__hollow(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_HOLLOW, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_rigid_body__technique_common__shape__hollow( void* attributeData )
{
    instance_rigid_body__technique_common__shape__hollow__AttributeData* typedAttributeData = static_cast<instance_rigid_body__technique_common__shape__hollow__AttributeData*>(attributeData);

    typedAttributeData->~instance_rigid_body__technique_common__shape__hollow__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_rigid_constraint__AttributeData instance_rigid_constraint__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_rigid_constraint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_rigid_constraint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_rigid_constraint( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_rigid_constraint__AttributeData* attributeData = newData<instance_rigid_constraint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CONSTRAINT:
    {

attributeData->constraint = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->constraint, strlen(attributeData->constraint));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT,
            HASH_ATTRIBUTE_CONSTRAINT,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->constraint )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT, HASH_ATTRIBUTE_CONSTRAINT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_rigid_constraint()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_rigid_constraint();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_rigid_constraint( void* attributeData )
{
    instance_rigid_constraint__AttributeData* typedAttributeData = static_cast<instance_rigid_constraint__AttributeData*>(attributeData);

    typedAttributeData->~instance_rigid_constraint__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_physics_scenes__AttributeData library_physics_scenes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_physics_scenes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_physics_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_physics_scenes( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_physics_scenes__AttributeData* attributeData = newData<library_physics_scenes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_PHYSICS_SCENES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_physics_scenes()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_physics_scenes();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_physics_scenes( void* attributeData )
{
    library_physics_scenes__AttributeData* typedAttributeData = static_cast<library_physics_scenes__AttributeData*>(attributeData);

    typedAttributeData->~library_physics_scenes__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const physics_scene__AttributeData physics_scene__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__physics_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__physics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__physics_scene( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

physics_scene__AttributeData* attributeData = newData<physics_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PHYSICS_SCENE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__physics_scene()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__physics_scene();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__physics_scene( void* attributeData )
{
    physics_scene__AttributeData* typedAttributeData = static_cast<physics_scene__AttributeData*>(attributeData);

    typedAttributeData->~physics_scene__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__physics_scene_type____technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__physics_scene_type____technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__physics_scene_type____technique_common( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__physics_scene_type____technique_common()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__physics_scene_type____technique_common();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__physics_scene_type____technique_common( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const gravity__AttributeData gravity__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__gravity( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__gravity, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__gravity);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__gravity);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__gravity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__gravity( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

gravity__AttributeData* attributeData = newData<gravity__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_GRAVITY,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_GRAVITY, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__gravity()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__gravity();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__gravity, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_GRAVITY,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__gravity );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__gravity );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__gravity( void* attributeData )
{
    gravity__AttributeData* typedAttributeData = static_cast<gravity__AttributeData*>(attributeData);

    typedAttributeData->~gravity__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const time_step__AttributeData time_step__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__time_step( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__time_step( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__time_step( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

time_step__AttributeData* attributeData = newData<time_step__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TIME_STEP,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TIME_STEP, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__time_step()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__time_step();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__time_step(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_TIME_STEP, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__time_step( void* attributeData )
{
    time_step__AttributeData* typedAttributeData = static_cast<time_step__AttributeData*>(attributeData);

    typedAttributeData->~time_step__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_visual_scenes__AttributeData library_visual_scenes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_visual_scenes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_visual_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_visual_scenes( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_visual_scenes__AttributeData* attributeData = newData<library_visual_scenes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_VISUAL_SCENES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_visual_scenes()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_visual_scenes();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_visual_scenes( void* attributeData )
{
    library_visual_scenes__AttributeData* typedAttributeData = static_cast<library_visual_scenes__AttributeData*>(attributeData);

    typedAttributeData->~library_visual_scenes__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const visual_scene__AttributeData visual_scene__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__visual_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__visual_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__visual_scene( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

visual_scene__AttributeData* attributeData = newData<visual_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_VISUAL_SCENE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__visual_scene()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__visual_scene();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__visual_scene( void* attributeData )
{
    visual_scene__AttributeData* typedAttributeData = static_cast<visual_scene__AttributeData*>(attributeData);

    typedAttributeData->~visual_scene__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const evaluate_scene__AttributeData evaluate_scene__AttributeData::DEFAULT = {0, 0, 0, true};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__evaluate_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__evaluate_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__evaluate_scene( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

evaluate_scene__AttributeData* attributeData = newData<evaluate_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EVALUATE_SCENE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ENABLE:
    {
bool failed;
attributeData->enable = GeneratedSaxParser::Utils::toBool(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EVALUATE_SCENE,
        HASH_ATTRIBUTE_ENABLE,
        attributeValue))
{
    return false;
}

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EVALUATE_SCENE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__evaluate_scene()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__evaluate_scene();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__evaluate_scene( void* attributeData )
{
    evaluate_scene__AttributeData* typedAttributeData = static_cast<evaluate_scene__AttributeData*>(attributeData);

    typedAttributeData->~evaluate_scene__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const render__AttributeData render__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__render( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__render( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__render( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

render__AttributeData* attributeData = newData<render__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_RENDER,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_CAMERA_NODE:
    {
bool failed;
attributeData->camera_node = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RENDER,
        HASH_ATTRIBUTE_CAMERA_NODE,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= render__AttributeData::ATTRIBUTE_CAMERA_NODE_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_RENDER, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & render__AttributeData::ATTRIBUTE_CAMERA_NODE_PRESENT) == 0)
{
    attributeData->camera_node = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__render()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__render();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__render( void* attributeData )
{
    render__AttributeData* typedAttributeData = static_cast<render__AttributeData*>(attributeData);

    typedAttributeData->~render__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__layer( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__layer( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__layer( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__layer()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__layer();
        if ( !validationResult ) return false;

    } // validation
#endif

bool returnValue = true;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
ParserError::ErrorType simpleTypeValidationResult = validate__NCName(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
{
    ParserChar msg[21];
    Utils::fillErrorMsg(msg, mLastIncompleteFragmentInCharacterData, 20);
    if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        simpleTypeValidationResult,
        0,
        msg) )
    {
        returnValue =  false;
    }
}
if (!returnValue)
{
    mStackMemoryManager.deleteObject();
    mLastIncompleteFragmentInCharacterData = 0;
    mEndOfDataInCurrentObjectOnStack = 0;
    return returnValue;
}
    } // validation
#endif
returnValue = mImpl->data__layer(mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData);
mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__layer( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const render__instance_material__AttributeData render__instance_material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__render__instance_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__render__instance_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__render__instance_material( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

render__instance_material__AttributeData* attributeData = newData<render__instance_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_MATERIAL,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= render__instance_material__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_MATERIAL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & render__instance_material__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & render__instance_material__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_MATERIAL, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__render__instance_material()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__render__instance_material();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__render__instance_material( void* attributeData )
{
    render__instance_material__AttributeData* typedAttributeData = static_cast<render__instance_material__AttributeData*>(attributeData);

    typedAttributeData->~render__instance_material__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const technique_override__AttributeData technique_override__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__technique_override( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__technique_override( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__technique_override( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

technique_override__AttributeData* attributeData = newData<technique_override__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->ref, strlen(attributeData->ref));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE_OVERRIDE,
            HASH_ATTRIBUTE_REF,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_PASS:
    {

attributeData->pass = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->pass, strlen(attributeData->pass));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TECHNIQUE_OVERRIDE,
            HASH_ATTRIBUTE_PASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_TECHNIQUE_OVERRIDE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_TECHNIQUE_OVERRIDE, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__technique_override()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__technique_override();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__technique_override( void* attributeData )
{
    technique_override__AttributeData* typedAttributeData = static_cast<technique_override__AttributeData*>(attributeData);

    typedAttributeData->~technique_override__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const render__instance_material__bind__AttributeData render__instance_material__bind__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__render__instance_material__bind( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__render__instance_material__bind( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__render__instance_material__bind( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

render__instance_material__bind__AttributeData* attributeData = newData<render__instance_material__bind__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->semantic, strlen(attributeData->semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BIND,
            HASH_ATTRIBUTE_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->semantic )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND, HASH_ATTRIBUTE_SEMANTIC, 0 ) )
        return false;
}
if ( !attributeData->target )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND, HASH_ATTRIBUTE_TARGET, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__render__instance_material__bind()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__render__instance_material__bind();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__render__instance_material__bind( void* attributeData )
{
    render__instance_material__bind__AttributeData* typedAttributeData = static_cast<render__instance_material__bind__AttributeData*>(attributeData);

    typedAttributeData->~render__instance_material__bind__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_joints__AttributeData library_joints__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_joints( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_joints( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_joints( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_joints__AttributeData* attributeData = newData<library_joints__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_JOINTS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_joints()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_joints();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_joints( void* attributeData )
{
    library_joints__AttributeData* typedAttributeData = static_cast<library_joints__AttributeData*>(attributeData);

    typedAttributeData->~library_joints__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const joint__AttributeData joint__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__joint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__joint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__joint( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

joint__AttributeData* attributeData = newData<joint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_JOINT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_JOINT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__joint()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__joint();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__joint( void* attributeData )
{
    joint__AttributeData* typedAttributeData = static_cast<joint__AttributeData*>(attributeData);

    typedAttributeData->~joint__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const prismatic__AttributeData prismatic__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__prismatic( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__prismatic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__prismatic( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

prismatic__AttributeData* attributeData = newData<prismatic__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PRISMATIC,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PRISMATIC, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__prismatic()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__prismatic();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__prismatic( void* attributeData )
{
    prismatic__AttributeData* typedAttributeData = static_cast<prismatic__AttributeData*>(attributeData);

    typedAttributeData->~prismatic__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const axis____axis_type__AttributeData axis____axis_type__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__axis____axis_type( const ParserChar* text, size_t textLength )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__axis____axis_type, &validate__float3_type__stream, &validationData->validationWholeSize, 0);
    }
    else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__axis____axis_type);
    }
#else
    {
return characterData2FloatData(text, textLength, &ColladaParserAutoGen15::data__axis____axis_type);
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__axis____axis_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__axis____axis_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

axis____axis_type__AttributeData* attributeData = newData<axis____axis_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_AXIS,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_AXIS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__axis____axis_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__axis____axis_type();
        if ( !validationResult ) return false;

    } // validation
#endif

#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
        origin____float3_type__ValidationData* validationData = (origin____float3_type__ValidationData*)mValidationDataStack.top();
        DISABLE_WARNING_UNUSED(validationData)
bool returnValue = floatDataEnd( &ColladaParserAutoGen15::data__axis____axis_type, &validate__float3_type__streamEnd, &validationData->validationWholeSize, 0 );
        ParserError::ErrorType simpleTypeValidationResult = validate__float3_type(0, (*(&validationData->validationWholeSize)));
        mValidationDataStack.deleteObject();
        if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
        {
            if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
                simpleTypeValidationResult,
                HASH_ELEMENT_AXIS,
                (ParserChar*)0, 0 ) )
            {
                return false;
            }
        }
        return returnValue;
    }
    else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__axis____axis_type );
    }
#else
    {
return floatDataEnd( &ColladaParserAutoGen15::data__axis____axis_type );
    } // validation
#endif

}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__axis____axis_type( void* attributeData )
{
    axis____axis_type__AttributeData* typedAttributeData = static_cast<axis____axis_type__AttributeData*>(attributeData);

    typedAttributeData->~axis____axis_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__limits____joint_limits_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__limits____joint_limits_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__limits____joint_limits_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__limits____joint_limits_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__limits____joint_limits_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__limits____joint_limits_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const min____minmax_type__AttributeData min____minmax_type__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__min____minmax_type( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__min____minmax_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__min____minmax_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

min____minmax_type__AttributeData* attributeData = newData<min____minmax_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MIN,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MIN, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__min____minmax_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__min____minmax_type();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__min____minmax_type(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MIN, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__min____minmax_type( void* attributeData )
{
    min____minmax_type__AttributeData* typedAttributeData = static_cast<min____minmax_type__AttributeData*>(attributeData);

    typedAttributeData->~min____minmax_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__max____minmax_type( const ParserChar* text, size_t textLength )
{
if (!mLastIncompleteFragmentInCharacterData)
{
    mLastIncompleteFragmentInCharacterData = (ParserChar*)mStackMemoryManager.newObject(textLength);
    memcpy(mLastIncompleteFragmentInCharacterData, text, textLength);
    mEndOfDataInCurrentObjectOnStack = mLastIncompleteFragmentInCharacterData + textLength;
}
else
{
    ParserChar* tmp = (ParserChar*)mStackMemoryManager.growObject(textLength);
    if ( tmp != mLastIncompleteFragmentInCharacterData ) {
        mEndOfDataInCurrentObjectOnStack = (mEndOfDataInCurrentObjectOnStack - mLastIncompleteFragmentInCharacterData) + tmp;
        mLastIncompleteFragmentInCharacterData = tmp;
    }
    memcpy(mEndOfDataInCurrentObjectOnStack, text, textLength);
    mEndOfDataInCurrentObjectOnStack += textLength;
}
return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__max____minmax_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__max____minmax_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

max____minmax_type__AttributeData* attributeData = newData<max____minmax_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MAX,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_MAX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__max____minmax_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__max____minmax_type();
        if ( !validationResult ) return false;

    } // validation
#endif

bool failed;
const ParserChar* ptrForErr = mLastIncompleteFragmentInCharacterData;
DISABLE_WARNING_UNUSED(ptrForErr)
float parameter = GeneratedSaxParser::Utils::toFloat((const ParserChar**)&mLastIncompleteFragmentInCharacterData, mEndOfDataInCurrentObjectOnStack, failed);
bool returnValue;
if (!failed)
{
    returnValue = mImpl->data__max____minmax_type(parameter);
}
else
    returnValue = !handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_TEXTDATA_PARSING_FAILED, HASH_ELEMENT_MAX, (const ParserChar*)0, mLastIncompleteFragmentInCharacterData);
if (mLastIncompleteFragmentInCharacterData)
    mStackMemoryManager.deleteObject();
mLastIncompleteFragmentInCharacterData = 0;
mEndOfDataInCurrentObjectOnStack = 0;
return returnValue;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__max____minmax_type( void* attributeData )
{
    max____minmax_type__AttributeData* typedAttributeData = static_cast<max____minmax_type__AttributeData*>(attributeData);

    typedAttributeData->~max____minmax_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const revolute__AttributeData revolute__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__revolute( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__revolute( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__revolute( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

revolute__AttributeData* attributeData = newData<revolute__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_REVOLUTE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_REVOLUTE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__revolute()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__revolute();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__revolute( void* attributeData )
{
    revolute__AttributeData* typedAttributeData = static_cast<revolute__AttributeData*>(attributeData);

    typedAttributeData->~revolute__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_kinematics_models__AttributeData library_kinematics_models__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_kinematics_models( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_kinematics_models( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_kinematics_models( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_kinematics_models__AttributeData* attributeData = newData<library_kinematics_models__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_KINEMATICS_MODELS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_kinematics_models()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_kinematics_models();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_kinematics_models( void* attributeData )
{
    library_kinematics_models__AttributeData* typedAttributeData = static_cast<library_kinematics_models__AttributeData*>(attributeData);

    typedAttributeData->~library_kinematics_models__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const kinematics_model__AttributeData kinematics_model__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__kinematics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__kinematics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__kinematics_model( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

kinematics_model__AttributeData* attributeData = newData<kinematics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_KINEMATICS_MODEL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__kinematics_model()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__kinematics_model();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__kinematics_model( void* attributeData )
{
    kinematics_model__AttributeData* typedAttributeData = static_cast<kinematics_model__AttributeData*>(attributeData);

    typedAttributeData->~kinematics_model__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__technique_common____kinematics_model_technique_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__technique_common____kinematics_model_technique_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__technique_common____kinematics_model_technique_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__technique_common____kinematics_model_technique_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__technique_common____kinematics_model_technique_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__technique_common____kinematics_model_technique_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const newparam____kinematics_newparam_type__AttributeData newparam____kinematics_newparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__newparam____kinematics_newparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__newparam____kinematics_newparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__newparam____kinematics_newparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

newparam____kinematics_newparam_type__AttributeData* attributeData = newData<newparam____kinematics_newparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEWPARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__newparam____kinematics_newparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__newparam____kinematics_newparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__newparam____kinematics_newparam_type( void* attributeData )
{
    newparam____kinematics_newparam_type__AttributeData* typedAttributeData = static_cast<newparam____kinematics_newparam_type__AttributeData*>(attributeData);

    typedAttributeData->~newparam____kinematics_newparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_joint__AttributeData instance_joint__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_joint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_joint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_joint( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_joint__AttributeData* attributeData = newData<instance_joint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_JOINT,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_joint__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_JOINT,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_JOINT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_joint__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_joint__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_JOINT, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_joint()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_joint();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_joint( void* attributeData )
{
    instance_joint__AttributeData* typedAttributeData = static_cast<instance_joint__AttributeData*>(attributeData);

    typedAttributeData->~instance_joint__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const link__AttributeData link__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__link( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__link( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__link( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

link__AttributeData* attributeData = newData<link__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LINK,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LINK, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__link()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__link();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__link( void* attributeData )
{
    link__AttributeData* typedAttributeData = static_cast<link__AttributeData*>(attributeData);

    typedAttributeData->~link__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const attachment_full__AttributeData attachment_full__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__attachment_full( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__attachment_full( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__attachment_full( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

attachment_full__AttributeData* attributeData = newData<attachment_full__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_JOINT:
    {

attributeData->joint = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ATTACHMENT_FULL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->joint )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ATTACHMENT_FULL, HASH_ATTRIBUTE_JOINT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__attachment_full()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__attachment_full();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__attachment_full( void* attributeData )
{
    attachment_full__AttributeData* typedAttributeData = static_cast<attachment_full__AttributeData*>(attributeData);

    typedAttributeData->~attachment_full__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const attachment_start__AttributeData attachment_start__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__attachment_start( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__attachment_start( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__attachment_start( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

attachment_start__AttributeData* attributeData = newData<attachment_start__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_JOINT:
    {

attributeData->joint = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ATTACHMENT_START, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->joint )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ATTACHMENT_START, HASH_ATTRIBUTE_JOINT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__attachment_start()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__attachment_start();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__attachment_start( void* attributeData )
{
    attachment_start__AttributeData* typedAttributeData = static_cast<attachment_start__AttributeData*>(attributeData);

    typedAttributeData->~attachment_start__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const attachment_end__AttributeData attachment_end__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__attachment_end( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__attachment_end( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__attachment_end( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

attachment_end__AttributeData* attributeData = newData<attachment_end__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_JOINT:
    {

attributeData->joint = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ATTACHMENT_END, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->joint )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_ATTACHMENT_END, HASH_ATTRIBUTE_JOINT, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__attachment_end()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__attachment_end();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__attachment_end( void* attributeData )
{
    attachment_end__AttributeData* typedAttributeData = static_cast<attachment_end__AttributeData*>(attributeData);

    typedAttributeData->~attachment_end__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const formula__AttributeData formula__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__formula( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__formula( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__formula( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

formula__AttributeData* attributeData = newData<formula__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FORMULA,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FORMULA, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__formula()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__formula();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__formula( void* attributeData )
{
    formula__AttributeData* typedAttributeData = static_cast<formula__AttributeData*>(attributeData);

    typedAttributeData->~formula__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const newparam____formula_newparam_type__AttributeData newparam____formula_newparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__newparam____formula_newparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__newparam____formula_newparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__newparam____formula_newparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

newparam____formula_newparam_type__AttributeData* attributeData = newData<newparam____formula_newparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEWPARAM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_NEWPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__newparam____formula_newparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__newparam____formula_newparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__newparam____formula_newparam_type( void* attributeData )
{
    newparam____formula_newparam_type__AttributeData* typedAttributeData = static_cast<newparam____formula_newparam_type__AttributeData*>(attributeData);

    typedAttributeData->~newparam____formula_newparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__target( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__target( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__target()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__target();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__target( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__param____common_param_type( const ParserChar* text, size_t textLength )
{

return mImpl->data__param____common_param_type(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__param____common_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__param____common_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__param____common_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__param____common_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__param____common_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__technique_common____formula_technique_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__technique_common____formula_technique_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__technique_common____formula_technique_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__technique_common____formula_technique_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__technique_common____formula_technique_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__technique_common____formula_technique_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const math__AttributeData math__AttributeData::DEFAULT = {0, 0, ENUM__mathml__overflow__scroll, 0, 0, 0, 0, 0, 0, 0, ENUM__mathml__display__inline, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__math( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__math( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__math( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

math__AttributeData* attributeData = newData<math__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_BASELINE:
    {

attributeData->baseline = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_OVERFLOW:
    {
bool failed;
attributeData->overflow = Utils::toEnum<ENUM__mathml__overflow, StringHash, ENUM__mathml__overflow__COUNT>(attributeValue, failed, ENUM__mathml__overflowMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATH,
        HASH_ATTRIBUTE_OVERFLOW,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_ALTIMG:
    {
bool failed;
attributeData->altimg = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATH,
        HASH_ATTRIBUTE_ALTIMG,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= math__AttributeData::ATTRIBUTE_ALTIMG_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_ALTTEXT:
    {

attributeData->alttext = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {

attributeData->height = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {

attributeData->width = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_MACROS:
    {

attributeData->macros = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DISPLAY:
    {
bool failed;
attributeData->display = Utils::toEnum<ENUM__mathml__display, StringHash, ENUM__mathml__display__COUNT>(attributeValue, failed, ENUM__mathml__displayMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATH,
        HASH_ATTRIBUTE_DISPLAY,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MATH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= math__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= math__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_XMLNS:
    {
    // ignore

    break;
    }
    default:
    {
        StringHashPair hashPair = Utils::calculateStringHashWithNamespace( attribute );
        if ( hashPair.first != HASH_ATTRIBUTE_XMLNS )
        {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;
        }
        else
        {
            // ignore
        }

    }
    }
    }
}
if ((attributeData->present_attributes & math__AttributeData::ATTRIBUTE_ALTIMG_PRESENT) == 0)
{
    attributeData->altimg = COLLADABU::URI("");
}
if ((attributeData->present_attributes & math__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & math__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__math()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__math();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__math( void* attributeData )
{
    math__AttributeData* typedAttributeData = static_cast<math__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~math__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__mathml__overflow ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__overflow (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__mathml__overflow>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__mathml__overflow, StringHash, ENUM__mathml__overflow__COUNT, &toEnum_ENUM__mathml__overflow>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__mathml__overflow (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__overflow*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__mathml__overflow, StringHash, ENUM__mathml__overflow__COUNT>(text, textLength, dataFunction, ENUM__mathml__overflowMap, baseConversionFunc, &toEnum_ENUM__mathml__overflow, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__overflow);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__mathml__overflow (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__overflow*, size_t ),
    const std::pair<StringHash, ENUM__mathml__overflow>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__mathml__overflow (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__mathml__overflow>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__mathml__overflow, StringHash, ENUM__mathml__overflow__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
ENUM__mathml__display ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__display (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__mathml__display>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__mathml__display, StringHash, ENUM__mathml__display__COUNT, &toEnum_ENUM__mathml__display>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__mathml__display (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__display*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__mathml__display, StringHash, ENUM__mathml__display__COUNT>(text, textLength, dataFunction, ENUM__mathml__displayMap, baseConversionFunc, &toEnum_ENUM__mathml__display, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__display);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__mathml__display (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__display*, size_t ),
    const std::pair<StringHash, ENUM__mathml__display>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__mathml__display (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__mathml__display>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__mathml__display, StringHash, ENUM__mathml__display__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const cn__AttributeData cn__AttributeData::DEFAULT = {0, 0, ENUM__mathml__cn__type__NOT_PRESENT, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cn( const ParserChar* text, size_t textLength )
{

return mImpl->data__cn(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cn( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cn( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

cn__AttributeData* attributeData = newData<cn__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_BASE:
    {
bool failed;
attributeData->base = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CN,
        HASH_ATTRIBUTE_BASE,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__cn(attributeData->base);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CN,
            HASH_ATTRIBUTE_BASE,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif
if ( !failed )
    attributeData->present_attributes |= cn__AttributeData::ATTRIBUTE_BASE_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {
bool failed;
attributeData->type = Utils::toEnum<ENUM__mathml__cn__type, StringHash, ENUM__mathml__cn__type__COUNT>(attributeValue, failed, ENUM__mathml__cn__typeMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CN,
        HASH_ATTRIBUTE_TYPE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cn__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= cn__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cn__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & cn__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & cn__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & cn__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cn()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cn();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cn( void* attributeData )
{
    cn__AttributeData* typedAttributeData = static_cast<cn__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~cn__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__mathml__cn__type ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__cn__type (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__mathml__cn__type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__mathml__cn__type, StringHash, ENUM__mathml__cn__type__COUNT, &toEnum_ENUM__mathml__cn__type>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__mathml__cn__type (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__cn__type*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__mathml__cn__type, StringHash, ENUM__mathml__cn__type__COUNT>(text, textLength, dataFunction, ENUM__mathml__cn__typeMap, baseConversionFunc, &toEnum_ENUM__mathml__cn__type, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__cn__type);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__mathml__cn__type (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__cn__type*, size_t ),
    const std::pair<StringHash, ENUM__mathml__cn__type>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__mathml__cn__type (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__mathml__cn__type>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__mathml__cn__type, StringHash, ENUM__mathml__cn__type__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const ci__AttributeData ci__AttributeData::DEFAULT = {0, 0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ci( const ParserChar* text, size_t textLength )
{

return mImpl->data__ci(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ci( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ci( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

ci__AttributeData* attributeData = newData<ci__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CI,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ci__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CI, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CI,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CI,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= ci__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CI,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ci__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & ci__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & ci__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & ci__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ci()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ci();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ci( void* attributeData )
{
    ci__AttributeData* typedAttributeData = static_cast<ci__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~ci__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const csymbol__AttributeData csymbol__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__csymbol( const ParserChar* text, size_t textLength )
{

return mImpl->data__csymbol(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__csymbol( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__csymbol( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

csymbol__AttributeData* attributeData = newData<csymbol__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSYMBOL,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= csymbol__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CSYMBOL, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSYMBOL,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CSYMBOL,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= csymbol__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSYMBOL,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= csymbol__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & csymbol__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & csymbol__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & csymbol__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__csymbol()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__csymbol();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__csymbol( void* attributeData )
{
    csymbol__AttributeData* typedAttributeData = static_cast<csymbol__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~csymbol__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const abs__AttributeData abs__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__abs( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__abs( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__abs( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

abs__AttributeData* attributeData = newData<abs__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ABS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= abs__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ABS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ABS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ABS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= abs__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ABS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= abs__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & abs__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & abs__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & abs__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__abs()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__abs();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__abs( void* attributeData )
{
    abs__AttributeData* typedAttributeData = static_cast<abs__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~abs__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const conjugate__AttributeData conjugate__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__conjugate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__conjugate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__conjugate( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

conjugate__AttributeData* attributeData = newData<conjugate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CONJUGATE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= conjugate__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CONJUGATE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CONJUGATE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CONJUGATE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= conjugate__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CONJUGATE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= conjugate__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & conjugate__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & conjugate__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & conjugate__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__conjugate()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__conjugate();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__conjugate( void* attributeData )
{
    conjugate__AttributeData* typedAttributeData = static_cast<conjugate__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~conjugate__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const factorial__AttributeData factorial__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__factorial( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__factorial( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__factorial( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

factorial__AttributeData* attributeData = newData<factorial__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACTORIAL,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= factorial__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_FACTORIAL, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACTORIAL,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FACTORIAL,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= factorial__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACTORIAL,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= factorial__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & factorial__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & factorial__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & factorial__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__factorial()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__factorial();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__factorial( void* attributeData )
{
    factorial__AttributeData* typedAttributeData = static_cast<factorial__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~factorial__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arg__AttributeData arg__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arg( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arg( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arg( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arg__AttributeData* attributeData = newData<arg__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARG,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arg__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARG, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARG,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARG,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arg__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARG,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arg__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arg__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arg__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arg__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arg()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arg();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arg( void* attributeData )
{
    arg__AttributeData* typedAttributeData = static_cast<arg__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arg__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const real__AttributeData real__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__real( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__real( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__real( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

real__AttributeData* attributeData = newData<real__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REAL,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= real__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_REAL, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REAL,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_REAL,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= real__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REAL,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= real__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & real__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & real__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & real__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__real()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__real();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__real( void* attributeData )
{
    real__AttributeData* typedAttributeData = static_cast<real__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~real__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const imaginary__AttributeData imaginary__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__imaginary( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__imaginary( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__imaginary( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

imaginary__AttributeData* attributeData = newData<imaginary__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGINARY,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= imaginary__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_IMAGINARY, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGINARY,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_IMAGINARY,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= imaginary__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGINARY,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= imaginary__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & imaginary__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & imaginary__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & imaginary__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__imaginary()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__imaginary();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__imaginary( void* attributeData )
{
    imaginary__AttributeData* typedAttributeData = static_cast<imaginary__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~imaginary__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const floor__AttributeData floor__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__floor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__floor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__floor( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

floor__AttributeData* attributeData = newData<floor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FLOOR,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= floor__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_FLOOR, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FLOOR,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FLOOR,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= floor__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FLOOR,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= floor__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & floor__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & floor__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & floor__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__floor()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__floor();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__floor( void* attributeData )
{
    floor__AttributeData* typedAttributeData = static_cast<floor__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~floor__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const ceiling__AttributeData ceiling__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ceiling( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ceiling( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ceiling( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

ceiling__AttributeData* attributeData = newData<ceiling__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CEILING,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ceiling__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CEILING, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CEILING,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CEILING,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= ceiling__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CEILING,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ceiling__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & ceiling__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & ceiling__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & ceiling__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ceiling()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ceiling();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ceiling( void* attributeData )
{
    ceiling__AttributeData* typedAttributeData = static_cast<ceiling__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~ceiling__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const quotient__AttributeData quotient__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__quotient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__quotient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__quotient( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

quotient__AttributeData* attributeData = newData<quotient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_QUOTIENT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= quotient__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_QUOTIENT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_QUOTIENT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_QUOTIENT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= quotient__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_QUOTIENT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= quotient__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & quotient__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & quotient__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & quotient__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__quotient()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__quotient();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__quotient( void* attributeData )
{
    quotient__AttributeData* typedAttributeData = static_cast<quotient__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~quotient__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const divide__AttributeData divide__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__divide( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__divide( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__divide( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

divide__AttributeData* attributeData = newData<divide__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIVIDE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= divide__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_DIVIDE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIVIDE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DIVIDE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= divide__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIVIDE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= divide__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & divide__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & divide__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & divide__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__divide()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__divide();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__divide( void* attributeData )
{
    divide__AttributeData* typedAttributeData = static_cast<divide__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~divide__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const rem__AttributeData rem__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rem( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rem( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rem( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

rem__AttributeData* attributeData = newData<rem__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REM,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= rem__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_REM, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REM,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_REM,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= rem__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REM,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= rem__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & rem__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & rem__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & rem__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rem()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rem();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rem( void* attributeData )
{
    rem__AttributeData* typedAttributeData = static_cast<rem__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~rem__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const minus__AttributeData minus__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__minus( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__minus( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__minus( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

minus__AttributeData* attributeData = newData<minus__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MINUS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= minus__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MINUS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MINUS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MINUS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= minus__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MINUS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= minus__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & minus__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & minus__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & minus__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__minus()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__minus();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__minus( void* attributeData )
{
    minus__AttributeData* typedAttributeData = static_cast<minus__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~minus__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const plus__AttributeData plus__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__plus( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__plus( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__plus( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

plus__AttributeData* attributeData = newData<plus__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PLUS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= plus__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_PLUS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PLUS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PLUS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= plus__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PLUS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= plus__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & plus__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & plus__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & plus__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__plus()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__plus();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__plus( void* attributeData )
{
    plus__AttributeData* typedAttributeData = static_cast<plus__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~plus__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const times__AttributeData times__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__times( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__times( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__times( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

times__AttributeData* attributeData = newData<times__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TIMES,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= times__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_TIMES, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TIMES,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TIMES,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= times__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TIMES,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= times__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & times__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & times__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & times__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__times()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__times();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__times( void* attributeData )
{
    times__AttributeData* typedAttributeData = static_cast<times__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~times__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const power__AttributeData power__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__power( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__power( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__power( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

power__AttributeData* attributeData = newData<power__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POWER,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= power__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_POWER, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POWER,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_POWER,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= power__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_POWER,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= power__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & power__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & power__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & power__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__power()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__power();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__power( void* attributeData )
{
    power__AttributeData* typedAttributeData = static_cast<power__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~power__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const root__AttributeData root__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__root( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__root( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__root( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

root__AttributeData* attributeData = newData<root__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ROOT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= root__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ROOT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ROOT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ROOT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= root__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ROOT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= root__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & root__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & root__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & root__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__root()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__root();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__root( void* attributeData )
{
    root__AttributeData* typedAttributeData = static_cast<root__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~root__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__max____Arith_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__max____Arith_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__max____Arith_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

max____Arith_type__AttributeData* attributeData = newData<max____Arith_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MAX,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= max____Arith_type__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MAX, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MAX,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MAX,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= max____Arith_type__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MAX,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= max____Arith_type__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & max____Arith_type__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & max____Arith_type__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & max____Arith_type__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__max____Arith_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__max____Arith_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__max____Arith_type( void* attributeData )
{
    max____Arith_type__AttributeData* typedAttributeData = static_cast<max____Arith_type__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~max____Arith_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__min____Arith_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__min____Arith_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__min____Arith_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

min____Arith_type__AttributeData* attributeData = newData<min____Arith_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MIN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= min____Arith_type__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MIN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MIN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MIN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= min____Arith_type__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MIN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= min____Arith_type__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & min____Arith_type__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & min____Arith_type__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & min____Arith_type__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__min____Arith_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__min____Arith_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__min____Arith_type( void* attributeData )
{
    min____Arith_type__AttributeData* typedAttributeData = static_cast<min____Arith_type__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~min____Arith_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const gcd__AttributeData gcd__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__gcd( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__gcd( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__gcd( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

gcd__AttributeData* attributeData = newData<gcd__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GCD,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= gcd__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_GCD, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GCD,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_GCD,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= gcd__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GCD,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= gcd__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & gcd__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & gcd__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & gcd__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__gcd()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__gcd();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__gcd( void* attributeData )
{
    gcd__AttributeData* typedAttributeData = static_cast<gcd__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~gcd__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const lcm__AttributeData lcm__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__lcm( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__lcm( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__lcm( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

lcm__AttributeData* attributeData = newData<lcm__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LCM,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= lcm__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LCM, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LCM,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LCM,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= lcm__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LCM,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= lcm__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & lcm__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & lcm__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & lcm__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__lcm()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__lcm();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__lcm( void* attributeData )
{
    lcm__AttributeData* typedAttributeData = static_cast<lcm__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~lcm__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const sum__AttributeData sum__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sum( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sum( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sum__AttributeData* attributeData = newData<sum__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SUM,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sum__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SUM, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SUM,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SUM,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= sum__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SUM,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sum__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & sum__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & sum__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & sum__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sum()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sum();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sum( void* attributeData )
{
    sum__AttributeData* typedAttributeData = static_cast<sum__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~sum__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const product__AttributeData product__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__product( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__product( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__product( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

product__AttributeData* attributeData = newData<product__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRODUCT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= product__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_PRODUCT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRODUCT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PRODUCT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= product__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRODUCT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= product__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & product__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & product__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & product__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__product()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__product();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__product( void* attributeData )
{
    product__AttributeData* typedAttributeData = static_cast<product__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~product__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const compose__AttributeData compose__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__compose( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__compose( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__compose( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

compose__AttributeData* attributeData = newData<compose__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COMPOSE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= compose__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_COMPOSE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COMPOSE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COMPOSE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= compose__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COMPOSE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= compose__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & compose__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & compose__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & compose__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__compose()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__compose();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__compose( void* attributeData )
{
    compose__AttributeData* typedAttributeData = static_cast<compose__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~compose__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const domain__AttributeData domain__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__domain( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__domain( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__domain( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

domain__AttributeData* attributeData = newData<domain__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DOMAIN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= domain__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_DOMAIN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DOMAIN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DOMAIN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= domain__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DOMAIN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= domain__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & domain__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & domain__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & domain__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__domain()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__domain();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__domain( void* attributeData )
{
    domain__AttributeData* typedAttributeData = static_cast<domain__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~domain__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const codomain__AttributeData codomain__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__codomain( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__codomain( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__codomain( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

codomain__AttributeData* attributeData = newData<codomain__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CODOMAIN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= codomain__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CODOMAIN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CODOMAIN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CODOMAIN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= codomain__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CODOMAIN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= codomain__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & codomain__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & codomain__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & codomain__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__codomain()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__codomain();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__codomain( void* attributeData )
{
    codomain__AttributeData* typedAttributeData = static_cast<codomain__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~codomain__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__image____Functions_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__image____Functions_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__image____Functions_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

image____Functions_type__AttributeData* attributeData = newData<image____Functions_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= image____Functions_type__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_IMAGE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_IMAGE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= image____Functions_type__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= image____Functions_type__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & image____Functions_type__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & image____Functions_type__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & image____Functions_type__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__image____Functions_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__image____Functions_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__image____Functions_type( void* attributeData )
{
    image____Functions_type__AttributeData* typedAttributeData = static_cast<image____Functions_type__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~image____Functions_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const domainofapplication__AttributeData domainofapplication__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__domainofapplication( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__domainofapplication( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__domainofapplication( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

domainofapplication__AttributeData* attributeData = newData<domainofapplication__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DOMAINOFAPPLICATION,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= domainofapplication__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_DOMAINOFAPPLICATION, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DOMAINOFAPPLICATION,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DOMAINOFAPPLICATION,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= domainofapplication__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DOMAINOFAPPLICATION,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= domainofapplication__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & domainofapplication__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & domainofapplication__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & domainofapplication__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__domainofapplication()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__domainofapplication();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__domainofapplication( void* attributeData )
{
    domainofapplication__AttributeData* typedAttributeData = static_cast<domainofapplication__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~domainofapplication__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const ident__AttributeData ident__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ident( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ident( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ident( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

ident__AttributeData* attributeData = newData<ident__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IDENT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ident__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_IDENT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IDENT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_IDENT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= ident__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IDENT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ident__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & ident__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & ident__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & ident__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ident()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ident();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ident( void* attributeData )
{
    ident__AttributeData* typedAttributeData = static_cast<ident__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~ident__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const and__AttributeData and__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__and( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__and( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__and( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

and__AttributeData* attributeData = newData<and__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_AND,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= and__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_AND, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_AND,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_AND,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= and__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_AND,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= and__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & and__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & and__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & and__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__and()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__and();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__and( void* attributeData )
{
    and__AttributeData* typedAttributeData = static_cast<and__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~and__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const or__AttributeData or__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__or( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__or( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__or( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

or__AttributeData* attributeData = newData<or__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_OR,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= or__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_OR, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_OR,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_OR,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= or__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_OR,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= or__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & or__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & or__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & or__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__or()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__or();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__or( void* attributeData )
{
    or__AttributeData* typedAttributeData = static_cast<or__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~or__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const xor__AttributeData xor__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__xor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__xor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__xor( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

xor__AttributeData* attributeData = newData<xor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_XOR,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= xor__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_XOR, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_XOR,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_XOR,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= xor__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_XOR,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= xor__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & xor__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & xor__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & xor__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__xor()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__xor();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__xor( void* attributeData )
{
    xor__AttributeData* typedAttributeData = static_cast<xor__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~xor__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const not__AttributeData not__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__not( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__not( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__not( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

not__AttributeData* attributeData = newData<not__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= not__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_NOT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NOT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= not__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= not__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & not__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & not__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & not__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__not()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__not();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__not( void* attributeData )
{
    not__AttributeData* typedAttributeData = static_cast<not__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~not__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const exists__AttributeData exists__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__exists( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__exists( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__exists( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

exists__AttributeData* attributeData = newData<exists__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXISTS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= exists__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_EXISTS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXISTS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EXISTS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= exists__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXISTS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= exists__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & exists__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & exists__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & exists__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__exists()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__exists();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__exists( void* attributeData )
{
    exists__AttributeData* typedAttributeData = static_cast<exists__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~exists__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const forall__AttributeData forall__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__forall( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__forall( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__forall( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

forall__AttributeData* attributeData = newData<forall__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FORALL,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= forall__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_FORALL, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FORALL,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FORALL,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= forall__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FORALL,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= forall__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & forall__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & forall__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & forall__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__forall()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__forall();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__forall( void* attributeData )
{
    forall__AttributeData* typedAttributeData = static_cast<forall__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~forall__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const implies__AttributeData implies__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__implies( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__implies( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__implies( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

implies__AttributeData* attributeData = newData<implies__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMPLIES,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= implies__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_IMPLIES, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMPLIES,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_IMPLIES,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= implies__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMPLIES,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= implies__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & implies__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & implies__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & implies__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__implies()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__implies();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__implies( void* attributeData )
{
    implies__AttributeData* typedAttributeData = static_cast<implies__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~implies__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const naturalnumbers__AttributeData naturalnumbers__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__naturalnumbers( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__naturalnumbers( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__naturalnumbers( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

naturalnumbers__AttributeData* attributeData = newData<naturalnumbers__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NATURALNUMBERS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= naturalnumbers__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_NATURALNUMBERS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NATURALNUMBERS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NATURALNUMBERS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= naturalnumbers__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NATURALNUMBERS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= naturalnumbers__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & naturalnumbers__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & naturalnumbers__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & naturalnumbers__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__naturalnumbers()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__naturalnumbers();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__naturalnumbers( void* attributeData )
{
    naturalnumbers__AttributeData* typedAttributeData = static_cast<naturalnumbers__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~naturalnumbers__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const primes__AttributeData primes__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__primes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__primes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__primes( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

primes__AttributeData* attributeData = newData<primes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRIMES,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= primes__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_PRIMES, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRIMES,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PRIMES,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= primes__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRIMES,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= primes__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & primes__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & primes__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & primes__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__primes()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__primes();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__primes( void* attributeData )
{
    primes__AttributeData* typedAttributeData = static_cast<primes__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~primes__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const integers__AttributeData integers__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__integers( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__integers( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__integers( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

integers__AttributeData* attributeData = newData<integers__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTEGERS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= integers__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_INTEGERS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTEGERS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INTEGERS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= integers__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTEGERS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= integers__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & integers__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & integers__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & integers__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__integers()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__integers();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__integers( void* attributeData )
{
    integers__AttributeData* typedAttributeData = static_cast<integers__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~integers__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const rationals__AttributeData rationals__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__rationals( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__rationals( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__rationals( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

rationals__AttributeData* attributeData = newData<rationals__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RATIONALS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= rationals__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_RATIONALS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RATIONALS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_RATIONALS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= rationals__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_RATIONALS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= rationals__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & rationals__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & rationals__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & rationals__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__rationals()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__rationals();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__rationals( void* attributeData )
{
    rationals__AttributeData* typedAttributeData = static_cast<rationals__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~rationals__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const reals__AttributeData reals__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__reals( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__reals( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__reals( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

reals__AttributeData* attributeData = newData<reals__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REALS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= reals__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_REALS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REALS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_REALS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= reals__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_REALS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= reals__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & reals__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & reals__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & reals__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__reals()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__reals();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__reals( void* attributeData )
{
    reals__AttributeData* typedAttributeData = static_cast<reals__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~reals__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const complexes__AttributeData complexes__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__complexes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__complexes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__complexes( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

complexes__AttributeData* attributeData = newData<complexes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COMPLEXES,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= complexes__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_COMPLEXES, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COMPLEXES,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COMPLEXES,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= complexes__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COMPLEXES,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= complexes__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & complexes__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & complexes__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & complexes__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__complexes()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__complexes();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__complexes( void* attributeData )
{
    complexes__AttributeData* typedAttributeData = static_cast<complexes__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~complexes__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const emptyset__AttributeData emptyset__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__emptyset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__emptyset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__emptyset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

emptyset__AttributeData* attributeData = newData<emptyset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EMPTYSET,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= emptyset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_EMPTYSET, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EMPTYSET,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EMPTYSET,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= emptyset__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EMPTYSET,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= emptyset__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & emptyset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & emptyset__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & emptyset__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__emptyset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__emptyset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__emptyset( void* attributeData )
{
    emptyset__AttributeData* typedAttributeData = static_cast<emptyset__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~emptyset__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const exponentiale__AttributeData exponentiale__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__exponentiale( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__exponentiale( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__exponentiale( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

exponentiale__AttributeData* attributeData = newData<exponentiale__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXPONENTIALE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= exponentiale__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_EXPONENTIALE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXPONENTIALE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EXPONENTIALE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= exponentiale__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXPONENTIALE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= exponentiale__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & exponentiale__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & exponentiale__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & exponentiale__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__exponentiale()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__exponentiale();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__exponentiale( void* attributeData )
{
    exponentiale__AttributeData* typedAttributeData = static_cast<exponentiale__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~exponentiale__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const imaginaryi__AttributeData imaginaryi__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__imaginaryi( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__imaginaryi( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__imaginaryi( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

imaginaryi__AttributeData* attributeData = newData<imaginaryi__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGINARYI,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= imaginaryi__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_IMAGINARYI, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGINARYI,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_IMAGINARYI,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= imaginaryi__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IMAGINARYI,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= imaginaryi__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & imaginaryi__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & imaginaryi__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & imaginaryi__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__imaginaryi()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__imaginaryi();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__imaginaryi( void* attributeData )
{
    imaginaryi__AttributeData* typedAttributeData = static_cast<imaginaryi__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~imaginaryi__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const pi__AttributeData pi__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__pi( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__pi( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__pi( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

pi__AttributeData* attributeData = newData<pi__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PI,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= pi__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_PI, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PI,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PI,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= pi__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PI,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= pi__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & pi__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & pi__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & pi__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__pi()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__pi();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__pi( void* attributeData )
{
    pi__AttributeData* typedAttributeData = static_cast<pi__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~pi__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const eulergamma__AttributeData eulergamma__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__eulergamma( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__eulergamma( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__eulergamma( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

eulergamma__AttributeData* attributeData = newData<eulergamma__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EULERGAMMA,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= eulergamma__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_EULERGAMMA, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EULERGAMMA,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EULERGAMMA,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= eulergamma__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EULERGAMMA,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= eulergamma__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & eulergamma__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & eulergamma__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & eulergamma__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__eulergamma()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__eulergamma();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__eulergamma( void* attributeData )
{
    eulergamma__AttributeData* typedAttributeData = static_cast<eulergamma__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~eulergamma__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const true__AttributeData true__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__true( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__true( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__true( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

true__AttributeData* attributeData = newData<true__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRUE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= true__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_TRUE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRUE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TRUE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= true__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRUE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= true__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & true__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & true__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & true__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__true()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__true();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__true( void* attributeData )
{
    true__AttributeData* typedAttributeData = static_cast<true__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~true__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const false__AttributeData false__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__false( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__false( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__false( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

false__AttributeData* attributeData = newData<false__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FALSE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= false__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_FALSE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FALSE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FALSE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= false__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FALSE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= false__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & false__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & false__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & false__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__false()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__false();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__false( void* attributeData )
{
    false__AttributeData* typedAttributeData = static_cast<false__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~false__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const infinity__AttributeData infinity__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__infinity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__infinity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__infinity( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

infinity__AttributeData* attributeData = newData<infinity__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INFINITY,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= infinity__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_INFINITY, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INFINITY,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INFINITY,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= infinity__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INFINITY,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= infinity__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & infinity__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & infinity__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & infinity__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__infinity()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__infinity();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__infinity( void* attributeData )
{
    infinity__AttributeData* typedAttributeData = static_cast<infinity__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~infinity__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const notanumber__AttributeData notanumber__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__notanumber( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__notanumber( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__notanumber( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

notanumber__AttributeData* attributeData = newData<notanumber__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTANUMBER,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= notanumber__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_NOTANUMBER, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTANUMBER,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NOTANUMBER,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= notanumber__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTANUMBER,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= notanumber__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & notanumber__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & notanumber__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & notanumber__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__notanumber()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__notanumber();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__notanumber( void* attributeData )
{
    notanumber__AttributeData* typedAttributeData = static_cast<notanumber__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~notanumber__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const set__AttributeData set__AttributeData::DEFAULT = {0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__set( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__set( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__set( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

set__AttributeData* attributeData = newData<set__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SET, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SET,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SET,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= set__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SET,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= set__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & set__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & set__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__set()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__set();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__set( void* attributeData )
{
    set__AttributeData* typedAttributeData = static_cast<set__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~set__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const list__AttributeData list__AttributeData::DEFAULT = {0, ENUM__mathml__list__order__NOT_PRESENT, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__list( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__list( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__list( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

list__AttributeData* attributeData = newData<list__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ORDER:
    {
bool failed;
attributeData->order = Utils::toEnum<ENUM__mathml__list__order, StringHash, ENUM__mathml__list__order__COUNT>(attributeValue, failed, ENUM__mathml__list__orderMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIST,
        HASH_ATTRIBUTE_ORDER,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LIST, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIST,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIST,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= list__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIST,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= list__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & list__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & list__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__list()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__list();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__list( void* attributeData )
{
    list__AttributeData* typedAttributeData = static_cast<list__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~list__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__mathml__list__order ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__list__order (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__mathml__list__order>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__mathml__list__order, StringHash, ENUM__mathml__list__order__COUNT, &toEnum_ENUM__mathml__list__order>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__mathml__list__order (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__list__order*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__mathml__list__order, StringHash, ENUM__mathml__list__order__COUNT>(text, textLength, dataFunction, ENUM__mathml__list__orderMap, baseConversionFunc, &toEnum_ENUM__mathml__list__order, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__list__order);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__mathml__list__order (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__list__order*, size_t ),
    const std::pair<StringHash, ENUM__mathml__list__order>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__mathml__list__order (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__mathml__list__order>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__mathml__list__order, StringHash, ENUM__mathml__list__order__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const union__AttributeData union__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__union( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__union( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__union( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

union__AttributeData* attributeData = newData<union__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_UNION,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= union__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_UNION, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_UNION,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_UNION,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= union__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_UNION,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= union__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & union__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & union__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & union__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__union()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__union();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__union( void* attributeData )
{
    union__AttributeData* typedAttributeData = static_cast<union__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~union__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const intersect__AttributeData intersect__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__intersect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__intersect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__intersect( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

intersect__AttributeData* attributeData = newData<intersect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTERSECT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= intersect__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_INTERSECT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTERSECT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INTERSECT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= intersect__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTERSECT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= intersect__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & intersect__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & intersect__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & intersect__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__intersect()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__intersect();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__intersect( void* attributeData )
{
    intersect__AttributeData* typedAttributeData = static_cast<intersect__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~intersect__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const in__AttributeData in__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__in( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__in( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__in( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

in__AttributeData* attributeData = newData<in__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= in__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_IN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_IN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= in__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_IN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= in__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & in__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & in__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & in__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__in()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__in();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__in( void* attributeData )
{
    in__AttributeData* typedAttributeData = static_cast<in__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~in__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const notin__AttributeData notin__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__notin( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__notin( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__notin( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

notin__AttributeData* attributeData = newData<notin__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTIN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= notin__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_NOTIN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTIN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NOTIN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= notin__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTIN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= notin__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & notin__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & notin__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & notin__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__notin()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__notin();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__notin( void* attributeData )
{
    notin__AttributeData* typedAttributeData = static_cast<notin__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~notin__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const subset__AttributeData subset__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__subset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__subset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__subset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

subset__AttributeData* attributeData = newData<subset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SUBSET,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= subset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SUBSET, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SUBSET,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SUBSET,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= subset__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SUBSET,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= subset__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & subset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & subset__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & subset__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__subset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__subset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__subset( void* attributeData )
{
    subset__AttributeData* typedAttributeData = static_cast<subset__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~subset__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const prsubset__AttributeData prsubset__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__prsubset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__prsubset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__prsubset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

prsubset__AttributeData* attributeData = newData<prsubset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRSUBSET,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= prsubset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_PRSUBSET, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRSUBSET,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PRSUBSET,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= prsubset__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PRSUBSET,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= prsubset__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & prsubset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & prsubset__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & prsubset__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__prsubset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__prsubset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__prsubset( void* attributeData )
{
    prsubset__AttributeData* typedAttributeData = static_cast<prsubset__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~prsubset__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const notsubset__AttributeData notsubset__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__notsubset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__notsubset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__notsubset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

notsubset__AttributeData* attributeData = newData<notsubset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTSUBSET,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= notsubset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_NOTSUBSET, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTSUBSET,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NOTSUBSET,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= notsubset__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTSUBSET,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= notsubset__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & notsubset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & notsubset__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & notsubset__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__notsubset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__notsubset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__notsubset( void* attributeData )
{
    notsubset__AttributeData* typedAttributeData = static_cast<notsubset__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~notsubset__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const notprsubset__AttributeData notprsubset__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__notprsubset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__notprsubset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__notprsubset( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

notprsubset__AttributeData* attributeData = newData<notprsubset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTPRSUBSET,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= notprsubset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_NOTPRSUBSET, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTPRSUBSET,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NOTPRSUBSET,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= notprsubset__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NOTPRSUBSET,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= notprsubset__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & notprsubset__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & notprsubset__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & notprsubset__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__notprsubset()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__notprsubset();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__notprsubset( void* attributeData )
{
    notprsubset__AttributeData* typedAttributeData = static_cast<notprsubset__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~notprsubset__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const setdiff__AttributeData setdiff__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__setdiff( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__setdiff( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__setdiff( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

setdiff__AttributeData* attributeData = newData<setdiff__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SETDIFF,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= setdiff__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SETDIFF, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SETDIFF,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SETDIFF,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= setdiff__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SETDIFF,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= setdiff__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & setdiff__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & setdiff__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & setdiff__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__setdiff()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__setdiff();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__setdiff( void* attributeData )
{
    setdiff__AttributeData* typedAttributeData = static_cast<setdiff__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~setdiff__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const card__AttributeData card__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__card( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__card( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__card( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

card__AttributeData* attributeData = newData<card__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CARD,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= card__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CARD, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CARD,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CARD,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= card__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CARD,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= card__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & card__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & card__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & card__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__card()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__card();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__card( void* attributeData )
{
    card__AttributeData* typedAttributeData = static_cast<card__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~card__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const cartesianproduct__AttributeData cartesianproduct__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cartesianproduct( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cartesianproduct( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cartesianproduct( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

cartesianproduct__AttributeData* attributeData = newData<cartesianproduct__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CARTESIANPRODUCT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cartesianproduct__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CARTESIANPRODUCT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CARTESIANPRODUCT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CARTESIANPRODUCT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= cartesianproduct__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CARTESIANPRODUCT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cartesianproduct__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & cartesianproduct__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & cartesianproduct__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & cartesianproduct__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cartesianproduct()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cartesianproduct();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cartesianproduct( void* attributeData )
{
    cartesianproduct__AttributeData* typedAttributeData = static_cast<cartesianproduct__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~cartesianproduct__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const eq__AttributeData eq__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__eq( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__eq( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__eq( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

eq__AttributeData* attributeData = newData<eq__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EQ,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= eq__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_EQ, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EQ,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EQ,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= eq__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EQ,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= eq__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & eq__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & eq__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & eq__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__eq()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__eq();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__eq( void* attributeData )
{
    eq__AttributeData* typedAttributeData = static_cast<eq__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~eq__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const neq__AttributeData neq__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__neq( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__neq( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__neq( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

neq__AttributeData* attributeData = newData<neq__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NEQ,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= neq__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_NEQ, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NEQ,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_NEQ,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= neq__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_NEQ,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= neq__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & neq__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & neq__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & neq__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__neq()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__neq();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__neq( void* attributeData )
{
    neq__AttributeData* typedAttributeData = static_cast<neq__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~neq__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const leq__AttributeData leq__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__leq( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__leq( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__leq( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

leq__AttributeData* attributeData = newData<leq__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LEQ,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= leq__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LEQ, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LEQ,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LEQ,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= leq__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LEQ,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= leq__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & leq__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & leq__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & leq__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__leq()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__leq();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__leq( void* attributeData )
{
    leq__AttributeData* typedAttributeData = static_cast<leq__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~leq__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const lt__AttributeData lt__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__lt( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__lt( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__lt( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

lt__AttributeData* attributeData = newData<lt__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= lt__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= lt__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= lt__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & lt__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & lt__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & lt__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__lt()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__lt();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__lt( void* attributeData )
{
    lt__AttributeData* typedAttributeData = static_cast<lt__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~lt__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const geq__AttributeData geq__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__geq( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__geq( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__geq( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

geq__AttributeData* attributeData = newData<geq__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GEQ,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= geq__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_GEQ, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GEQ,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_GEQ,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= geq__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GEQ,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= geq__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & geq__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & geq__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & geq__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__geq()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__geq();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__geq( void* attributeData )
{
    geq__AttributeData* typedAttributeData = static_cast<geq__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~geq__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const gt__AttributeData gt__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__gt( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__gt( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__gt( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

gt__AttributeData* attributeData = newData<gt__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= gt__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_GT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_GT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= gt__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= gt__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & gt__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & gt__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & gt__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__gt()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__gt();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__gt( void* attributeData )
{
    gt__AttributeData* typedAttributeData = static_cast<gt__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~gt__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const equivalent__AttributeData equivalent__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__equivalent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__equivalent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__equivalent( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

equivalent__AttributeData* attributeData = newData<equivalent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EQUIVALENT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= equivalent__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_EQUIVALENT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EQUIVALENT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EQUIVALENT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= equivalent__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EQUIVALENT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= equivalent__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & equivalent__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & equivalent__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & equivalent__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__equivalent()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__equivalent();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__equivalent( void* attributeData )
{
    equivalent__AttributeData* typedAttributeData = static_cast<equivalent__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~equivalent__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const approx__AttributeData approx__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__approx( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__approx( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__approx( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

approx__AttributeData* attributeData = newData<approx__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_APPROX,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= approx__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_APPROX, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_APPROX,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_APPROX,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= approx__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_APPROX,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= approx__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & approx__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & approx__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & approx__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__approx()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__approx();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__approx( void* attributeData )
{
    approx__AttributeData* typedAttributeData = static_cast<approx__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~approx__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const factorof__AttributeData factorof__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__factorof( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__factorof( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__factorof( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

factorof__AttributeData* attributeData = newData<factorof__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACTOROF,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= factorof__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_FACTOROF, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACTOROF,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_FACTOROF,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= factorof__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_FACTOROF,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= factorof__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & factorof__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & factorof__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & factorof__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__factorof()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__factorof();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__factorof( void* attributeData )
{
    factorof__AttributeData* typedAttributeData = static_cast<factorof__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~factorof__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const exp__AttributeData exp__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__exp( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__exp( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__exp( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

exp__AttributeData* attributeData = newData<exp__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXP,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= exp__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_EXP, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXP,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EXP,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= exp__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_EXP,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= exp__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & exp__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & exp__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & exp__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__exp()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__exp();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__exp( void* attributeData )
{
    exp__AttributeData* typedAttributeData = static_cast<exp__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~exp__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const ln__AttributeData ln__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__ln( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__ln( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__ln( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

ln__AttributeData* attributeData = newData<ln__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ln__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= ln__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= ln__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & ln__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & ln__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & ln__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__ln()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__ln();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__ln( void* attributeData )
{
    ln__AttributeData* typedAttributeData = static_cast<ln__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~ln__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const log__AttributeData log__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__log( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__log( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__log( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

log__AttributeData* attributeData = newData<log__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOG,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= log__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LOG, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOG,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LOG,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= log__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOG,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= log__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & log__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & log__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & log__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__log()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__log();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__log( void* attributeData )
{
    log__AttributeData* typedAttributeData = static_cast<log__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~log__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const logbase__AttributeData logbase__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__logbase( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__logbase( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__logbase( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

logbase__AttributeData* attributeData = newData<logbase__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LOGBASE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOGBASE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LOGBASE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= logbase__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOGBASE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= logbase__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & logbase__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & logbase__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__logbase()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__logbase();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__logbase( void* attributeData )
{
    logbase__AttributeData* typedAttributeData = static_cast<logbase__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~logbase__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const sin__AttributeData sin__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sin( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sin( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sin( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sin__AttributeData* attributeData = newData<sin__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sin__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SIN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SIN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= sin__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SIN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sin__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & sin__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & sin__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & sin__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sin()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sin();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sin( void* attributeData )
{
    sin__AttributeData* typedAttributeData = static_cast<sin__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~sin__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const cos__AttributeData cos__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cos( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cos( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cos( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

cos__AttributeData* attributeData = newData<cos__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cos__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_COS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= cos__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cos__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & cos__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & cos__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & cos__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cos()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cos();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cos( void* attributeData )
{
    cos__AttributeData* typedAttributeData = static_cast<cos__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~cos__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const tan__AttributeData tan__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__tan( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__tan( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__tan( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

tan__AttributeData* attributeData = newData<tan__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TAN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= tan__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_TAN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TAN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TAN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= tan__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TAN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= tan__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & tan__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & tan__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & tan__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__tan()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__tan();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__tan( void* attributeData )
{
    tan__AttributeData* typedAttributeData = static_cast<tan__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~tan__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const sec__AttributeData sec__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sec( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sec( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sec( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sec__AttributeData* attributeData = newData<sec__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SEC,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sec__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SEC, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SEC,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SEC,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= sec__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SEC,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sec__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & sec__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & sec__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & sec__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sec()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sec();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sec( void* attributeData )
{
    sec__AttributeData* typedAttributeData = static_cast<sec__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~sec__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const csc__AttributeData csc__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__csc( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__csc( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__csc( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

csc__AttributeData* attributeData = newData<csc__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSC,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= csc__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CSC, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSC,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CSC,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= csc__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSC,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= csc__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & csc__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & csc__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & csc__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__csc()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__csc();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__csc( void* attributeData )
{
    csc__AttributeData* typedAttributeData = static_cast<csc__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~csc__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const cot__AttributeData cot__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cot( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cot( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cot( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

cot__AttributeData* attributeData = newData<cot__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cot__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_COT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= cot__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cot__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & cot__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & cot__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & cot__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cot()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cot();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cot( void* attributeData )
{
    cot__AttributeData* typedAttributeData = static_cast<cot__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~cot__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arcsin__AttributeData arcsin__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arcsin( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arcsin( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arcsin( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arcsin__AttributeData* attributeData = newData<arcsin__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSIN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arcsin__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCSIN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSIN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCSIN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arcsin__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSIN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arcsin__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arcsin__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arcsin__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arcsin__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arcsin()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arcsin();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arcsin( void* attributeData )
{
    arcsin__AttributeData* typedAttributeData = static_cast<arcsin__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arcsin__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arccos__AttributeData arccos__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arccos( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arccos( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arccos( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arccos__AttributeData* attributeData = newData<arccos__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccos__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCCOS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCCOS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arccos__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccos__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arccos__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arccos__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arccos__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arccos()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arccos();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arccos( void* attributeData )
{
    arccos__AttributeData* typedAttributeData = static_cast<arccos__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arccos__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arctan__AttributeData arctan__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arctan( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arctan( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arctan( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arctan__AttributeData* attributeData = newData<arctan__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCTAN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arctan__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCTAN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCTAN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCTAN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arctan__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCTAN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arctan__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arctan__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arctan__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arctan__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arctan()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arctan();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arctan( void* attributeData )
{
    arctan__AttributeData* typedAttributeData = static_cast<arctan__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arctan__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arcsec__AttributeData arcsec__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arcsec( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arcsec( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arcsec( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arcsec__AttributeData* attributeData = newData<arcsec__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSEC,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arcsec__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCSEC, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSEC,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCSEC,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arcsec__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSEC,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arcsec__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arcsec__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arcsec__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arcsec__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arcsec()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arcsec();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arcsec( void* attributeData )
{
    arcsec__AttributeData* typedAttributeData = static_cast<arcsec__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arcsec__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arccsc__AttributeData arccsc__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arccsc( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arccsc( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arccsc( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arccsc__AttributeData* attributeData = newData<arccsc__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCSC,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccsc__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCCSC, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCSC,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCCSC,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arccsc__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCSC,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccsc__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arccsc__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arccsc__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arccsc__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arccsc()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arccsc();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arccsc( void* attributeData )
{
    arccsc__AttributeData* typedAttributeData = static_cast<arccsc__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arccsc__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arccot__AttributeData arccot__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arccot( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arccot( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arccot( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arccot__AttributeData* attributeData = newData<arccot__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccot__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCCOT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCCOT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arccot__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccot__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arccot__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arccot__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arccot__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arccot()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arccot();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arccot( void* attributeData )
{
    arccot__AttributeData* typedAttributeData = static_cast<arccot__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arccot__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const sinh__AttributeData sinh__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sinh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sinh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sinh( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sinh__AttributeData* attributeData = newData<sinh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SINH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sinh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SINH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SINH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SINH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= sinh__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SINH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sinh__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & sinh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & sinh__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & sinh__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sinh()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sinh();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sinh( void* attributeData )
{
    sinh__AttributeData* typedAttributeData = static_cast<sinh__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~sinh__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const cosh__AttributeData cosh__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__cosh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__cosh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__cosh( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

cosh__AttributeData* attributeData = newData<cosh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COSH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cosh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_COSH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COSH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COSH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= cosh__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COSH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= cosh__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & cosh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & cosh__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & cosh__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__cosh()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__cosh();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__cosh( void* attributeData )
{
    cosh__AttributeData* typedAttributeData = static_cast<cosh__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~cosh__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const tanh__AttributeData tanh__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__tanh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__tanh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__tanh( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

tanh__AttributeData* attributeData = newData<tanh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TANH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= tanh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_TANH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TANH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TANH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= tanh__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TANH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= tanh__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & tanh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & tanh__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & tanh__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__tanh()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__tanh();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__tanh( void* attributeData )
{
    tanh__AttributeData* typedAttributeData = static_cast<tanh__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~tanh__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const sech__AttributeData sech__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sech( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sech( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sech( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sech__AttributeData* attributeData = newData<sech__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SECH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sech__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SECH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SECH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SECH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= sech__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SECH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sech__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & sech__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & sech__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & sech__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sech()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sech();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sech( void* attributeData )
{
    sech__AttributeData* typedAttributeData = static_cast<sech__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~sech__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const csch__AttributeData csch__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__csch( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__csch( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__csch( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

csch__AttributeData* attributeData = newData<csch__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSCH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= csch__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CSCH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSCH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CSCH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= csch__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CSCH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= csch__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & csch__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & csch__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & csch__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__csch()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__csch();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__csch( void* attributeData )
{
    csch__AttributeData* typedAttributeData = static_cast<csch__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~csch__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const coth__AttributeData coth__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__coth( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__coth( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__coth( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

coth__AttributeData* attributeData = newData<coth__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COTH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= coth__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_COTH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COTH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_COTH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= coth__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_COTH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= coth__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & coth__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & coth__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & coth__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__coth()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__coth();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__coth( void* attributeData )
{
    coth__AttributeData* typedAttributeData = static_cast<coth__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~coth__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arccosh__AttributeData arccosh__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arccosh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arccosh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arccosh( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arccosh__AttributeData* attributeData = newData<arccosh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOSH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccosh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCCOSH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOSH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCCOSH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arccosh__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOSH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccosh__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arccosh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arccosh__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arccosh__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arccosh()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arccosh();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arccosh( void* attributeData )
{
    arccosh__AttributeData* typedAttributeData = static_cast<arccosh__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arccosh__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arccoth__AttributeData arccoth__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arccoth( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arccoth( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arccoth( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arccoth__AttributeData* attributeData = newData<arccoth__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOTH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccoth__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCCOTH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOTH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCCOTH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arccoth__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCOTH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccoth__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arccoth__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arccoth__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arccoth__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arccoth()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arccoth();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arccoth( void* attributeData )
{
    arccoth__AttributeData* typedAttributeData = static_cast<arccoth__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arccoth__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arccsch__AttributeData arccsch__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arccsch( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arccsch( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arccsch( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arccsch__AttributeData* attributeData = newData<arccsch__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCSCH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccsch__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCCSCH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCSCH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCCSCH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arccsch__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCCSCH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arccsch__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arccsch__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arccsch__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arccsch__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arccsch()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arccsch();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arccsch( void* attributeData )
{
    arccsch__AttributeData* typedAttributeData = static_cast<arccsch__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arccsch__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arcsech__AttributeData arcsech__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arcsech( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arcsech( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arcsech( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arcsech__AttributeData* attributeData = newData<arcsech__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSECH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arcsech__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCSECH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSECH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCSECH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arcsech__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSECH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arcsech__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arcsech__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arcsech__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arcsech__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arcsech()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arcsech();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arcsech( void* attributeData )
{
    arcsech__AttributeData* typedAttributeData = static_cast<arcsech__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arcsech__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arcsinh__AttributeData arcsinh__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arcsinh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arcsinh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arcsinh( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arcsinh__AttributeData* attributeData = newData<arcsinh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSINH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arcsinh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCSINH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSINH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCSINH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arcsinh__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCSINH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arcsinh__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arcsinh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arcsinh__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arcsinh__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arcsinh()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arcsinh();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arcsinh( void* attributeData )
{
    arcsinh__AttributeData* typedAttributeData = static_cast<arcsinh__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arcsinh__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const arctanh__AttributeData arctanh__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__arctanh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__arctanh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__arctanh( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

arctanh__AttributeData* attributeData = newData<arctanh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCTANH,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arctanh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ARCTANH, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCTANH,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ARCTANH,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= arctanh__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ARCTANH,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= arctanh__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & arctanh__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & arctanh__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & arctanh__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__arctanh()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__arctanh();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__arctanh( void* attributeData )
{
    arctanh__AttributeData* typedAttributeData = static_cast<arctanh__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~arctanh__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const int____int_type____mathml__AttributeData int____int_type____mathml__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__int____int_type____mathml( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__int____int_type____mathml( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__int____int_type____mathml( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

int____int_type____mathml__AttributeData* attributeData = newData<int____int_type____mathml__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= int____int_type____mathml__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_INT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= int____int_type____mathml__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= int____int_type____mathml__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & int____int_type____mathml__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & int____int_type____mathml__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & int____int_type____mathml__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__int____int_type____mathml()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__int____int_type____mathml();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__int____int_type____mathml( void* attributeData )
{
    int____int_type____mathml__AttributeData* typedAttributeData = static_cast<int____int_type____mathml__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~int____int_type____mathml__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const diff__AttributeData diff__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__diff( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__diff( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__diff( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

diff__AttributeData* attributeData = newData<diff__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIFF,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= diff__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_DIFF, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIFF,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DIFF,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= diff__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIFF,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= diff__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & diff__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & diff__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & diff__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__diff()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__diff();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__diff( void* attributeData )
{
    diff__AttributeData* typedAttributeData = static_cast<diff__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~diff__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const partialdiff__AttributeData partialdiff__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__partialdiff( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__partialdiff( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__partialdiff( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

partialdiff__AttributeData* attributeData = newData<partialdiff__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PARTIALDIFF,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= partialdiff__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_PARTIALDIFF, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PARTIALDIFF,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PARTIALDIFF,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= partialdiff__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PARTIALDIFF,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= partialdiff__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & partialdiff__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & partialdiff__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & partialdiff__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__partialdiff()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__partialdiff();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__partialdiff( void* attributeData )
{
    partialdiff__AttributeData* typedAttributeData = static_cast<partialdiff__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~partialdiff__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const limit__AttributeData limit__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__limit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__limit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__limit( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

limit__AttributeData* attributeData = newData<limit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIMIT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= limit__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LIMIT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIMIT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LIMIT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= limit__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LIMIT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= limit__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & limit__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & limit__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & limit__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__limit()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__limit();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__limit( void* attributeData )
{
    limit__AttributeData* typedAttributeData = static_cast<limit__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~limit__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const lowlimit__AttributeData lowlimit__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__lowlimit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__lowlimit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__lowlimit( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

lowlimit__AttributeData* attributeData = newData<lowlimit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOWLIMIT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= lowlimit__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LOWLIMIT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOWLIMIT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LOWLIMIT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= lowlimit__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LOWLIMIT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= lowlimit__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & lowlimit__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & lowlimit__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & lowlimit__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__lowlimit()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__lowlimit();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__lowlimit( void* attributeData )
{
    lowlimit__AttributeData* typedAttributeData = static_cast<lowlimit__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~lowlimit__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const uplimit__AttributeData uplimit__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__uplimit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__uplimit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__uplimit( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

uplimit__AttributeData* attributeData = newData<uplimit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_UPLIMIT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= uplimit__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_UPLIMIT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_UPLIMIT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_UPLIMIT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= uplimit__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_UPLIMIT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= uplimit__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & uplimit__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & uplimit__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & uplimit__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__uplimit()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__uplimit();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__uplimit( void* attributeData )
{
    uplimit__AttributeData* typedAttributeData = static_cast<uplimit__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~uplimit__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const tendsto__AttributeData tendsto__AttributeData::DEFAULT = {0, 0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__tendsto( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__tendsto( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__tendsto( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

tendsto__AttributeData* attributeData = newData<tendsto__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TENDSTO,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= tendsto__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_TENDSTO, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TENDSTO,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TENDSTO,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= tendsto__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TENDSTO,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= tendsto__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & tendsto__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & tendsto__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & tendsto__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__tendsto()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__tendsto();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__tendsto( void* attributeData )
{
    tendsto__AttributeData* typedAttributeData = static_cast<tendsto__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~tendsto__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const vector__AttributeData vector__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__vector( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__vector( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__vector( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

vector__AttributeData* attributeData = newData<vector__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_VECTOR, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VECTOR,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_VECTOR,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= vector__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VECTOR,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= vector__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & vector__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & vector__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__vector()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__vector();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__vector( void* attributeData )
{
    vector__AttributeData* typedAttributeData = static_cast<vector__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~vector__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const matrix____matrix_type____mathml__AttributeData matrix____matrix_type____mathml__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__matrix____matrix_type____mathml( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__matrix____matrix_type____mathml( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__matrix____matrix_type____mathml( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

matrix____matrix_type____mathml__AttributeData* attributeData = newData<matrix____matrix_type____mathml__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MATRIX, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATRIX,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATRIX,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= matrix____matrix_type____mathml__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATRIX,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= matrix____matrix_type____mathml__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & matrix____matrix_type____mathml__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & matrix____matrix_type____mathml__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__matrix____matrix_type____mathml()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__matrix____matrix_type____mathml();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__matrix____matrix_type____mathml( void* attributeData )
{
    matrix____matrix_type____mathml__AttributeData* typedAttributeData = static_cast<matrix____matrix_type____mathml__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~matrix____matrix_type____mathml__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const matrixrow__AttributeData matrixrow__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__matrixrow( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__matrixrow( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__matrixrow( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

matrixrow__AttributeData* attributeData = newData<matrixrow__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MATRIXROW, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATRIXROW,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MATRIXROW,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= matrixrow__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MATRIXROW,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= matrixrow__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & matrixrow__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & matrixrow__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__matrixrow()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__matrixrow();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__matrixrow( void* attributeData )
{
    matrixrow__AttributeData* typedAttributeData = static_cast<matrixrow__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~matrixrow__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const determinant__AttributeData determinant__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__determinant( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__determinant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__determinant( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

determinant__AttributeData* attributeData = newData<determinant__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DETERMINANT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= determinant__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_DETERMINANT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DETERMINANT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DETERMINANT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= determinant__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DETERMINANT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= determinant__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & determinant__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & determinant__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & determinant__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__determinant()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__determinant();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__determinant( void* attributeData )
{
    determinant__AttributeData* typedAttributeData = static_cast<determinant__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~determinant__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const transpose__AttributeData transpose__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__transpose( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__transpose( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__transpose( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

transpose__AttributeData* attributeData = newData<transpose__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRANSPOSE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= transpose__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_TRANSPOSE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRANSPOSE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_TRANSPOSE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= transpose__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_TRANSPOSE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= transpose__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & transpose__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & transpose__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & transpose__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__transpose()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__transpose();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__transpose( void* attributeData )
{
    transpose__AttributeData* typedAttributeData = static_cast<transpose__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~transpose__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const selector__AttributeData selector__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__selector( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__selector( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__selector( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

selector__AttributeData* attributeData = newData<selector__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SELECTOR,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= selector__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SELECTOR, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SELECTOR,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SELECTOR,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= selector__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SELECTOR,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= selector__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & selector__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & selector__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & selector__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__selector()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__selector();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__selector( void* attributeData )
{
    selector__AttributeData* typedAttributeData = static_cast<selector__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~selector__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const vectorproduct__AttributeData vectorproduct__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__vectorproduct( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__vectorproduct( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__vectorproduct( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

vectorproduct__AttributeData* attributeData = newData<vectorproduct__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VECTORPRODUCT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= vectorproduct__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_VECTORPRODUCT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VECTORPRODUCT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_VECTORPRODUCT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= vectorproduct__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VECTORPRODUCT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= vectorproduct__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & vectorproduct__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & vectorproduct__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & vectorproduct__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__vectorproduct()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__vectorproduct();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__vectorproduct( void* attributeData )
{
    vectorproduct__AttributeData* typedAttributeData = static_cast<vectorproduct__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~vectorproduct__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const scalarproduct__AttributeData scalarproduct__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__scalarproduct( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__scalarproduct( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__scalarproduct( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

scalarproduct__AttributeData* attributeData = newData<scalarproduct__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCALARPRODUCT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= scalarproduct__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SCALARPRODUCT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCALARPRODUCT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SCALARPRODUCT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= scalarproduct__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SCALARPRODUCT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= scalarproduct__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & scalarproduct__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & scalarproduct__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & scalarproduct__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__scalarproduct()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__scalarproduct();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__scalarproduct( void* attributeData )
{
    scalarproduct__AttributeData* typedAttributeData = static_cast<scalarproduct__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~scalarproduct__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const outerproduct__AttributeData outerproduct__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__outerproduct( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__outerproduct( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__outerproduct( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

outerproduct__AttributeData* attributeData = newData<outerproduct__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_OUTERPRODUCT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= outerproduct__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_OUTERPRODUCT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_OUTERPRODUCT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_OUTERPRODUCT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= outerproduct__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_OUTERPRODUCT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= outerproduct__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & outerproduct__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & outerproduct__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & outerproduct__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__outerproduct()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__outerproduct();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__outerproduct( void* attributeData )
{
    outerproduct__AttributeData* typedAttributeData = static_cast<outerproduct__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~outerproduct__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const divergence__AttributeData divergence__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__divergence( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__divergence( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__divergence( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

divergence__AttributeData* attributeData = newData<divergence__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIVERGENCE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= divergence__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_DIVERGENCE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIVERGENCE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DIVERGENCE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= divergence__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DIVERGENCE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= divergence__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & divergence__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & divergence__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & divergence__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__divergence()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__divergence();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__divergence( void* attributeData )
{
    divergence__AttributeData* typedAttributeData = static_cast<divergence__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~divergence__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const grad__AttributeData grad__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__grad( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__grad( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__grad( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

grad__AttributeData* attributeData = newData<grad__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GRAD,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= grad__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_GRAD, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GRAD,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_GRAD,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= grad__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_GRAD,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= grad__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & grad__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & grad__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & grad__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__grad()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__grad();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__grad( void* attributeData )
{
    grad__AttributeData* typedAttributeData = static_cast<grad__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~grad__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const curl__AttributeData curl__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__curl( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__curl( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__curl( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

curl__AttributeData* attributeData = newData<curl__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CURL,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= curl__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_CURL, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CURL,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_CURL,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= curl__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CURL,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= curl__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & curl__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & curl__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & curl__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__curl()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__curl();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__curl( void* attributeData )
{
    curl__AttributeData* typedAttributeData = static_cast<curl__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~curl__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const laplacian__AttributeData laplacian__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__laplacian( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__laplacian( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__laplacian( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

laplacian__AttributeData* attributeData = newData<laplacian__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LAPLACIAN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= laplacian__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LAPLACIAN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LAPLACIAN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LAPLACIAN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= laplacian__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LAPLACIAN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= laplacian__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & laplacian__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & laplacian__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & laplacian__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__laplacian()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__laplacian();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__laplacian( void* attributeData )
{
    laplacian__AttributeData* typedAttributeData = static_cast<laplacian__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~laplacian__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const mean__AttributeData mean__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mean( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mean( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mean( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

mean__AttributeData* attributeData = newData<mean__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MEAN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= mean__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MEAN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MEAN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MEAN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= mean__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MEAN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= mean__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & mean__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & mean__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & mean__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mean()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mean();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mean( void* attributeData )
{
    mean__AttributeData* typedAttributeData = static_cast<mean__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~mean__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const sdev__AttributeData sdev__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sdev( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sdev( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sdev( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

sdev__AttributeData* attributeData = newData<sdev__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SDEV,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sdev__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SDEV, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SDEV,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SDEV,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= sdev__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SDEV,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= sdev__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & sdev__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & sdev__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & sdev__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sdev()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sdev();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sdev( void* attributeData )
{
    sdev__AttributeData* typedAttributeData = static_cast<sdev__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~sdev__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const variance__AttributeData variance__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__variance( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__variance( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__variance( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

variance__AttributeData* attributeData = newData<variance__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VARIANCE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= variance__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_VARIANCE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VARIANCE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_VARIANCE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= variance__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_VARIANCE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= variance__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & variance__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & variance__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & variance__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__variance()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__variance();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__variance( void* attributeData )
{
    variance__AttributeData* typedAttributeData = static_cast<variance__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~variance__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const median__AttributeData median__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__median( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__median( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__median( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

median__AttributeData* attributeData = newData<median__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MEDIAN,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= median__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MEDIAN, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MEDIAN,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MEDIAN,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= median__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MEDIAN,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= median__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & median__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & median__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & median__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__median()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__median();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__median( void* attributeData )
{
    median__AttributeData* typedAttributeData = static_cast<median__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~median__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const mode____mode_type__AttributeData mode____mode_type__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__mode____mode_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__mode____mode_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__mode____mode_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

mode____mode_type__AttributeData* attributeData = newData<mode____mode_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MODE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= mode____mode_type__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MODE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MODE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MODE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= mode____mode_type__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MODE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= mode____mode_type__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & mode____mode_type__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & mode____mode_type__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & mode____mode_type__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__mode____mode_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__mode____mode_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__mode____mode_type( void* attributeData )
{
    mode____mode_type__AttributeData* typedAttributeData = static_cast<mode____mode_type__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~mode____mode_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const moment__AttributeData moment__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__moment( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__moment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__moment( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

moment__AttributeData* attributeData = newData<moment__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MOMENT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= moment__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MOMENT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MOMENT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MOMENT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= moment__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MOMENT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= moment__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & moment__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & moment__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & moment__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__moment()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__moment();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__moment( void* attributeData )
{
    moment__AttributeData* typedAttributeData = static_cast<moment__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~moment__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const momentabout__AttributeData momentabout__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__momentabout( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__momentabout( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__momentabout( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

momentabout__AttributeData* attributeData = newData<momentabout__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MOMENTABOUT,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= momentabout__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_MOMENTABOUT, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MOMENTABOUT,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_MOMENTABOUT,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= momentabout__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_MOMENTABOUT,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= momentabout__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & momentabout__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & momentabout__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & momentabout__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__momentabout()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__momentabout();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__momentabout( void* attributeData )
{
    momentabout__AttributeData* typedAttributeData = static_cast<momentabout__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~momentabout__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const apply__AttributeData apply__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__apply( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__apply( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__apply( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

apply__AttributeData* attributeData = newData<apply__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_APPLY, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_APPLY,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_APPLY,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= apply__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_APPLY,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= apply__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & apply__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & apply__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__apply()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__apply();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__apply( void* attributeData )
{
    apply__AttributeData* typedAttributeData = static_cast<apply__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~apply__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const interval__AttributeData interval__AttributeData::DEFAULT = {0, ENUM__mathml__interval__closure__closed, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__interval( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__interval( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__interval( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

interval__AttributeData* attributeData = newData<interval__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLOSURE:
    {
bool failed;
attributeData->closure = Utils::toEnum<ENUM__mathml__interval__closure, StringHash, ENUM__mathml__interval__closure__COUNT>(attributeValue, failed, ENUM__mathml__interval__closureMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTERVAL,
        HASH_ATTRIBUTE_CLOSURE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_INTERVAL, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTERVAL,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INTERVAL,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= interval__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INTERVAL,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= interval__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & interval__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & interval__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__interval()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__interval();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__interval( void* attributeData )
{
    interval__AttributeData* typedAttributeData = static_cast<interval__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~interval__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__mathml__interval__closure ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__interval__closure (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__mathml__interval__closure>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__mathml__interval__closure, StringHash, ENUM__mathml__interval__closure__COUNT, &toEnum_ENUM__mathml__interval__closure>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__mathml__interval__closure (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__interval__closure*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__mathml__interval__closure, StringHash, ENUM__mathml__interval__closure__COUNT>(text, textLength, dataFunction, ENUM__mathml__interval__closureMap, baseConversionFunc, &toEnum_ENUM__mathml__interval__closure, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__interval__closure);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__mathml__interval__closure (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__interval__closure*, size_t ),
    const std::pair<StringHash, ENUM__mathml__interval__closure>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__mathml__interval__closure (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__mathml__interval__closure>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__mathml__interval__closure, StringHash, ENUM__mathml__interval__closure__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const inverse__AttributeData inverse__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__inverse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__inverse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__inverse( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

inverse__AttributeData* attributeData = newData<inverse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INVERSE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= inverse__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_INVERSE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INVERSE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INVERSE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= inverse__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INVERSE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= inverse__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & inverse__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & inverse__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & inverse__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__inverse()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__inverse();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__inverse( void* attributeData )
{
    inverse__AttributeData* typedAttributeData = static_cast<inverse__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~inverse__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const condition__AttributeData condition__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__condition( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__condition( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__condition( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

condition__AttributeData* attributeData = newData<condition__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_CONDITION,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= condition__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_CONDITION, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & condition__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__condition()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__condition();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__condition( void* attributeData )
{
    condition__AttributeData* typedAttributeData = static_cast<condition__AttributeData*>(attributeData);

    typedAttributeData->~condition__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const declare__AttributeData declare__AttributeData::DEFAULT = {0, 0, 0, 0, ENUM__mathml__declare__occurrence__NOT_PRESENT, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__declare( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__declare( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__declare( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

declare__AttributeData* attributeData = newData<declare__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SCOPE:
    {

attributeData->scope = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NARGS:
    {
bool failed;
attributeData->nargs = GeneratedSaxParser::Utils::toUint64(attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DECLARE,
        HASH_ATTRIBUTE_NARGS,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= declare__AttributeData::ATTRIBUTE_NARGS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_OCCURRENCE:
    {
bool failed;
attributeData->occurrence = Utils::toEnum<ENUM__mathml__declare__occurrence, StringHash, ENUM__mathml__declare__occurrence__COUNT>(attributeValue, failed, ENUM__mathml__declare__occurrenceMap, Utils::calculateStringHash);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DECLARE,
        HASH_ATTRIBUTE_OCCURRENCE,
        attributeValue))
{
    return false;
}

    break;
    }
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DECLARE,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= declare__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_DECLARE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & declare__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__declare()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__declare();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__declare( void* attributeData )
{
    declare__AttributeData* typedAttributeData = static_cast<declare__AttributeData*>(attributeData);

    typedAttributeData->~declare__AttributeData();

    return true;
}

//---------------------------------------------------------------------
ENUM__mathml__declare__occurrence ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__declare__occurrence (
    const ParserChar* prefixedBuffer,
    const ParserChar* prefixedBufferEnd,
    const ParserChar** buffer,
    const ParserChar* bufferEnd,
    bool& failed,
    const std::pair<StringHash, ENUM__mathml__declare__occurrence>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return toEnumDataPrefix<ENUM__mathml__declare__occurrence, StringHash, ENUM__mathml__declare__occurrence__COUNT, &toEnum_ENUM__mathml__declare__occurrence>(prefixedBuffer, prefixedBufferEnd, buffer, bufferEnd, failed, enumMap, baseConversionFunc);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::characterData2EnumData_ENUM__mathml__declare__occurrence (
    const ParserChar* text,
    size_t textLength,
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__declare__occurrence*, size_t ),
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& )
)
{
    return characterData2EnumData<ENUM__mathml__declare__occurrence, StringHash, ENUM__mathml__declare__occurrence__COUNT>(text, textLength, dataFunction, ENUM__mathml__declare__occurrenceMap, baseConversionFunc, &toEnum_ENUM__mathml__declare__occurrence, &ColladaParserAutoGen15Private::toEnumDataPrefix_ENUM__mathml__declare__occurrence);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::dataEnumEnd_ENUM__mathml__declare__occurrence (
    bool ( ColladaParserAutoGen15::*dataFunction )(const ENUM__mathml__declare__occurrence*, size_t ),
    const std::pair<StringHash, ENUM__mathml__declare__occurrence>* enumMap,
    StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ),
    ENUM__mathml__declare__occurrence (*toEnumFunc)( const ParserChar**, const ParserChar*, bool&, const std::pair<StringHash, ENUM__mathml__declare__occurrence>* enumMap, StringHash (*baseConversionFunc)( const ParserChar**, const ParserChar*, bool& ))
)
{
    return dataEnumEnd<ENUM__mathml__declare__occurrence, StringHash, ENUM__mathml__declare__occurrence__COUNT>(dataFunction, enumMap, baseConversionFunc, toEnumFunc);
}

//---------------------------------------------------------------------
const lambda__AttributeData lambda__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__lambda( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__lambda( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__lambda( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

lambda__AttributeData* attributeData = newData<lambda__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_LAMBDA, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LAMBDA,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_LAMBDA,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= lambda__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_LAMBDA,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= lambda__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & lambda__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & lambda__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__lambda()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__lambda();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__lambda( void* attributeData )
{
    lambda__AttributeData* typedAttributeData = static_cast<lambda__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~lambda__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const piecewise__AttributeData piecewise__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__piecewise( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__piecewise( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__piecewise( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

piecewise__AttributeData* attributeData = newData<piecewise__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_PIECEWISE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PIECEWISE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_PIECEWISE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= piecewise__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_PIECEWISE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= piecewise__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & piecewise__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & piecewise__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__piecewise()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__piecewise();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__piecewise( void* attributeData )
{
    piecewise__AttributeData* typedAttributeData = static_cast<piecewise__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~piecewise__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__piece( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__piece( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__piece( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__piece()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__piece();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__piece( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const bvar__AttributeData bvar__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bvar( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bvar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bvar( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

bvar__AttributeData* attributeData = newData<bvar__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_BVAR, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BVAR,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BVAR,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= bvar__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_BVAR,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= bvar__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & bvar__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & bvar__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bvar()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bvar();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bvar( void* attributeData )
{
    bvar__AttributeData* typedAttributeData = static_cast<bvar__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~bvar__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const degree__AttributeData degree__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__degree( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__degree( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__degree( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

degree__AttributeData* attributeData = newData<degree__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_DEGREE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEGREE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_DEGREE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= degree__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_DEGREE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= degree__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & degree__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & degree__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__degree()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__degree();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__degree( void* attributeData )
{
    degree__AttributeData* typedAttributeData = static_cast<degree__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~degree__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const semantics__AttributeData semantics__AttributeData::DEFAULT = {0, 0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__semantics( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__semantics( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__semantics( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

semantics__AttributeData* attributeData = newData<semantics__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_DEFINITIONURL:
    {
bool failed;
attributeData->definitionURL = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SEMANTICS,
        HASH_ATTRIBUTE_DEFINITIONURL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= semantics__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_SEMANTICS, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SEMANTICS,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_SEMANTICS,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= semantics__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_SEMANTICS,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= semantics__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & semantics__AttributeData::ATTRIBUTE_DEFINITIONURL_PRESENT) == 0)
{
    attributeData->definitionURL = COLLADABU::URI("");
}
if ((attributeData->present_attributes & semantics__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & semantics__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__semantics()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__semantics();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__semantics( void* attributeData )
{
    semantics__AttributeData* typedAttributeData = static_cast<semantics__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~semantics__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const annotation__AttributeData annotation__AttributeData::DEFAULT = {0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__annotation( const ParserChar* text, size_t textLength )
{

return mImpl->data__annotation(text, textLength);
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__annotation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__annotation( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

annotation__AttributeData* attributeData = newData<annotation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ANNOTATION, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ANNOTATION,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ANNOTATION,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= annotation__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ANNOTATION,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= annotation__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & annotation__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & annotation__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__annotation()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__annotation();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__annotation( void* attributeData )
{
    annotation__AttributeData* typedAttributeData = static_cast<annotation__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~annotation__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const annotation_xml__AttributeData annotation_xml__AttributeData::DEFAULT = {0, 0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__annotation_xml( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__annotation_xml( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__annotation_xml( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

annotation_xml__AttributeData* attributeData = newData<annotation_xml__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ENCODING:
    {

attributeData->encoding = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_ANNOTATION_XML, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ANNOTATION_XML,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_ANNOTATION_XML,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= annotation_xml__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_ANNOTATION_XML,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= annotation_xml__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & annotation_xml__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & annotation_xml__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__annotation_xml()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__annotation_xml();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__annotation_xml( void* attributeData )
{
    annotation_xml__AttributeData* typedAttributeData = static_cast<annotation_xml__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~annotation_xml__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const otherwise__AttributeData otherwise__AttributeData::DEFAULT = {0, GeneratedSaxParser::XSList<ParserString>(), 0, 0, 0, 0, GeneratedSaxParser::XSList<const ParserChar*>()};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__otherwise( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__otherwise( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__otherwise( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

otherwise__AttributeData* attributeData = newData<otherwise__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLASS:
    {
bool failed;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
failed = !characterData2StringList(attributeValue, attributeData->_class, &validate__NMTOKEN, HASH_ELEMENT_OTHERWISE, HASH_ATTRIBUTE_CLASS);
    }
    else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    }
#else
    {
failed = !characterData2StringList(attributeValue, attributeData->_class);
    } // validation
#endif
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_OTHERWISE,
        HASH_ATTRIBUTE_CLASS,
        attributeValue))
{
    return false;
}
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKENS(attributeData->_class.data, attributeData->_class.size);
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_OTHERWISE,
            HASH_ATTRIBUTE_CLASS,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

if ( !failed )
    attributeData->present_attributes |= otherwise__AttributeData::ATTRIBUTE__CLASS_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_STYLE:
    {

attributeData->style = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_XREF:
    {

attributeData->xref = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HREF:
    {
bool failed;
attributeData->href = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_OTHERWISE,
        HASH_ATTRIBUTE_HREF,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= otherwise__AttributeData::ATTRIBUTE_HREF_PRESENT;

    break;
    }
    default:
    {
        if ( !attributeData->unknownAttributes.data )
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.newObject( 2 * sizeof( const ParserChar* ) );
        else
            attributeData->unknownAttributes.data = (const ParserChar**)mStackMemoryManager.growObject( 2 * sizeof( const ParserChar* ) );
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size ] = attribute;
        attributeData->unknownAttributes.data[ attributeData->unknownAttributes.size+1 ] = attributeValue;
        attributeData->unknownAttributes.size += 2;

    }
    }
    }
}
if ((attributeData->present_attributes & otherwise__AttributeData::ATTRIBUTE__CLASS_PRESENT) == 0)
{
    attributeData->_class = GeneratedSaxParser::XSList<ParserString>();
}
if ((attributeData->present_attributes & otherwise__AttributeData::ATTRIBUTE_HREF_PRESENT) == 0)
{
    attributeData->href = COLLADABU::URI("");
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__otherwise()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__otherwise();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__otherwise( void* attributeData )
{
    otherwise__AttributeData* typedAttributeData = static_cast<otherwise__AttributeData*>(attributeData);
    if (typedAttributeData->_class.data)
    {
        mStackMemoryManager.deleteObject();
    }

    if (typedAttributeData->unknownAttributes.data)
    {
        mStackMemoryManager.deleteObject();
    }


    typedAttributeData->~otherwise__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__sep( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__sep( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__sep( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__sep()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__sep();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__sep( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const library_articulated_systems__AttributeData library_articulated_systems__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_articulated_systems( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_articulated_systems( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_articulated_systems( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_articulated_systems__AttributeData* attributeData = newData<library_articulated_systems__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_ARTICULATED_SYSTEMS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_articulated_systems()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_articulated_systems();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_articulated_systems( void* attributeData )
{
    library_articulated_systems__AttributeData* typedAttributeData = static_cast<library_articulated_systems__AttributeData*>(attributeData);

    typedAttributeData->~library_articulated_systems__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const articulated_system__AttributeData articulated_system__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__articulated_system( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__articulated_system( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__articulated_system( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

articulated_system__AttributeData* attributeData = newData<articulated_system__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_ARTICULATED_SYSTEM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__articulated_system()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__articulated_system();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__articulated_system( void* attributeData )
{
    articulated_system__AttributeData* typedAttributeData = static_cast<articulated_system__AttributeData*>(attributeData);

    typedAttributeData->~articulated_system__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__kinematics( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__kinematics( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__kinematics( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__kinematics()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__kinematics();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__kinematics( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const instance_kinematics_model__AttributeData instance_kinematics_model__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_kinematics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_kinematics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_kinematics_model( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_kinematics_model__AttributeData* attributeData = newData<instance_kinematics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_KINEMATICS_MODEL,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_kinematics_model__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_KINEMATICS_MODEL,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_KINEMATICS_MODEL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_kinematics_model__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_kinematics_model__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_KINEMATICS_MODEL, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_kinematics_model()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_kinematics_model();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_kinematics_model( void* attributeData )
{
    instance_kinematics_model__AttributeData* typedAttributeData = static_cast<instance_kinematics_model__AttributeData*>(attributeData);

    typedAttributeData->~instance_kinematics_model__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const bind____kinematics_bind_type__AttributeData bind____kinematics_bind_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bind____kinematics_bind_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bind____kinematics_bind_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bind____kinematics_bind_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

bind____kinematics_bind_type__AttributeData* attributeData = newData<bind____kinematics_bind_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NCName(attributeData->symbol, strlen(attributeData->symbol));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_BIND,
            HASH_ATTRIBUTE_SYMBOL,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->symbol )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_BIND, HASH_ATTRIBUTE_SYMBOL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bind____kinematics_bind_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bind____kinematics_bind_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bind____kinematics_bind_type( void* attributeData )
{
    bind____kinematics_bind_type__AttributeData* typedAttributeData = static_cast<bind____kinematics_bind_type__AttributeData*>(attributeData);

    typedAttributeData->~bind____kinematics_bind_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const param____kinematics_param_type__AttributeData param____kinematics_param_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__param____kinematics_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__param____kinematics_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__param____kinematics_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

param____kinematics_param_type__AttributeData* attributeData = newData<param____kinematics_param_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_PARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_PARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__param____kinematics_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__param____kinematics_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__param____kinematics_param_type( void* attributeData )
{
    param____kinematics_param_type__AttributeData* typedAttributeData = static_cast<param____kinematics_param_type__AttributeData*>(attributeData);

    typedAttributeData->~param____kinematics_param_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const setparam____kinematics_setparam_type__AttributeData setparam____kinematics_setparam_type__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__setparam____kinematics_setparam_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__setparam____kinematics_setparam_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__setparam____kinematics_setparam_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

setparam____kinematics_setparam_type__AttributeData* attributeData = newData<setparam____kinematics_setparam_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_SETPARAM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->ref )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_SETPARAM, HASH_ATTRIBUTE_REF, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__setparam____kinematics_setparam_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__setparam____kinematics_setparam_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__setparam____kinematics_setparam_type( void* attributeData )
{
    setparam____kinematics_setparam_type__AttributeData* typedAttributeData = static_cast<setparam____kinematics_setparam_type__AttributeData*>(attributeData);

    typedAttributeData->~setparam____kinematics_setparam_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__technique_common____kinematics_technique_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__technique_common____kinematics_technique_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__technique_common____kinematics_technique_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__technique_common____kinematics_technique_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__technique_common____kinematics_technique_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__technique_common____kinematics_technique_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const axis_info____kinematics_axis_info_type__AttributeData axis_info____kinematics_axis_info_type__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__axis_info____kinematics_axis_info_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__axis_info____kinematics_axis_info_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__axis_info____kinematics_axis_info_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

axis_info____kinematics_axis_info_type__AttributeData* attributeData = newData<axis_info____kinematics_axis_info_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_AXIS_INFO,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_AXIS:
    {

attributeData->axis = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_AXIS_INFO, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->axis )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_AXIS_INFO, HASH_ATTRIBUTE_AXIS, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__axis_info____kinematics_axis_info_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__axis_info____kinematics_axis_info_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__axis_info____kinematics_axis_info_type( void* attributeData )
{
    axis_info____kinematics_axis_info_type__AttributeData* typedAttributeData = static_cast<axis_info____kinematics_axis_info_type__AttributeData*>(attributeData);

    typedAttributeData->~axis_info____kinematics_axis_info_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__active( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__active( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__active( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__active()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__active();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__active( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__locked( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__locked( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__locked( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__locked()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__locked();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__locked( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const index__AttributeData index__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__index( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__index( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__index( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

index__AttributeData* attributeData = newData<index__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__NMTOKEN(attributeData->semantic, strlen(attributeData->semantic));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INDEX,
            HASH_ATTRIBUTE_SEMANTIC,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INDEX, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__index()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__index();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__index( void* attributeData )
{
    index__AttributeData* typedAttributeData = static_cast<index__AttributeData*>(attributeData);

    typedAttributeData->~index__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__limits____kinematics_limits_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__limits____kinematics_limits_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__limits____kinematics_limits_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__limits____kinematics_limits_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__limits____kinematics_limits_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__limits____kinematics_limits_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__min____common_float_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__min____common_float_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__min____common_float_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__min____common_float_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__min____common_float_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__min____common_float_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__max____common_float_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__max____common_float_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__max____common_float_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__max____common_float_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__max____common_float_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__max____common_float_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const frame_origin__AttributeData frame_origin__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__frame_origin( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__frame_origin( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__frame_origin( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

frame_origin__AttributeData* attributeData = newData<frame_origin__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LINK:
    {

attributeData->link = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRAME_ORIGIN, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__frame_origin()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__frame_origin();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__frame_origin( void* attributeData )
{
    frame_origin__AttributeData* typedAttributeData = static_cast<frame_origin__AttributeData*>(attributeData);

    typedAttributeData->~frame_origin__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const frame_tip__AttributeData frame_tip__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__frame_tip( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__frame_tip( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__frame_tip( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

frame_tip__AttributeData* attributeData = newData<frame_tip__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LINK:
    {

attributeData->link = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRAME_TIP, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__frame_tip()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__frame_tip();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__frame_tip( void* attributeData )
{
    frame_tip__AttributeData* typedAttributeData = static_cast<frame_tip__AttributeData*>(attributeData);

    typedAttributeData->~frame_tip__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const frame_tcp__AttributeData frame_tcp__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__frame_tcp( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__frame_tcp( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__frame_tcp( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

frame_tcp__AttributeData* attributeData = newData<frame_tcp__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LINK:
    {

attributeData->link = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRAME_TCP, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__frame_tcp()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__frame_tcp();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__frame_tcp( void* attributeData )
{
    frame_tcp__AttributeData* typedAttributeData = static_cast<frame_tcp__AttributeData*>(attributeData);

    typedAttributeData->~frame_tcp__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const frame_object__AttributeData frame_object__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__frame_object( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__frame_object( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__frame_object( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

frame_object__AttributeData* attributeData = newData<frame_object__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LINK:
    {

attributeData->link = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_FRAME_OBJECT, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__frame_object()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__frame_object();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__frame_object( void* attributeData )
{
    frame_object__AttributeData* typedAttributeData = static_cast<frame_object__AttributeData*>(attributeData);

    typedAttributeData->~frame_object__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__motion( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__motion( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__motion( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__motion()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__motion();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__motion( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const instance_articulated_system__AttributeData instance_articulated_system__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_articulated_system( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_articulated_system( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_articulated_system( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_articulated_system__AttributeData* attributeData = newData<instance_articulated_system__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_ARTICULATED_SYSTEM,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_ARTICULATED_SYSTEM,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_articulated_system__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_ARTICULATED_SYSTEM, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_articulated_system__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_articulated_system__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_ARTICULATED_SYSTEM, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_articulated_system()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_articulated_system();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_articulated_system( void* attributeData )
{
    instance_articulated_system__AttributeData* typedAttributeData = static_cast<instance_articulated_system__AttributeData*>(attributeData);

    typedAttributeData->~instance_articulated_system__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__technique_common____motion_technique_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__technique_common____motion_technique_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__technique_common____motion_technique_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__technique_common____motion_technique_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__technique_common____motion_technique_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__technique_common____motion_technique_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const axis_info____motion_axis_info_type__AttributeData axis_info____motion_axis_info_type__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__axis_info____motion_axis_info_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__axis_info____motion_axis_info_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__axis_info____motion_axis_info_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

axis_info____motion_axis_info_type__AttributeData* attributeData = newData<axis_info____motion_axis_info_type__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_AXIS_INFO,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_AXIS:
    {

attributeData->axis = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_AXIS_INFO, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ( !attributeData->axis )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_AXIS_INFO, HASH_ATTRIBUTE_AXIS, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__axis_info____motion_axis_info_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__axis_info____motion_axis_info_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__axis_info____motion_axis_info_type( void* attributeData )
{
    axis_info____motion_axis_info_type__AttributeData* typedAttributeData = static_cast<axis_info____motion_axis_info_type__AttributeData*>(attributeData);

    typedAttributeData->~axis_info____motion_axis_info_type__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__speed____common_float_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__speed____common_float_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__speed____common_float_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__speed____common_float_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__speed____common_float_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__speed____common_float_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__acceleration____common_float_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__acceleration____common_float_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__acceleration____common_float_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__acceleration____common_float_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__acceleration____common_float_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__acceleration____common_float_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__deceleration____common_float_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__deceleration____common_float_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__deceleration____common_float_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__deceleration____common_float_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__deceleration____common_float_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__deceleration____common_float_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__jerk____common_float_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__jerk____common_float_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__jerk____common_float_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__jerk____common_float_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__jerk____common_float_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__jerk____common_float_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const effector_info__AttributeData effector_info__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__effector_info( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__effector_info( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__effector_info( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

effector_info__AttributeData* attributeData = newData<effector_info__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_EFFECTOR_INFO,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_EFFECTOR_INFO, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__effector_info()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__effector_info();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__effector_info( void* attributeData )
{
    effector_info__AttributeData* typedAttributeData = static_cast<effector_info__AttributeData*>(attributeData);

    typedAttributeData->~effector_info__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__speed____common_float2_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__speed____common_float2_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__speed____common_float2_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__speed____common_float2_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__speed____common_float2_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__speed____common_float2_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__acceleration____common_float2_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__acceleration____common_float2_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__acceleration____common_float2_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__acceleration____common_float2_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__acceleration____common_float2_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__acceleration____common_float2_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__deceleration____common_float2_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__deceleration____common_float2_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__deceleration____common_float2_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__deceleration____common_float2_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__deceleration____common_float2_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__deceleration____common_float2_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__jerk____common_float2_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__jerk____common_float2_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__jerk____common_float2_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__jerk____common_float2_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__jerk____common_float2_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__jerk____common_float2_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const library_kinematics_scenes__AttributeData library_kinematics_scenes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_kinematics_scenes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_kinematics_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_kinematics_scenes( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_kinematics_scenes__AttributeData* attributeData = newData<library_kinematics_scenes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_KINEMATICS_SCENES, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_kinematics_scenes()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_kinematics_scenes();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_kinematics_scenes( void* attributeData )
{
    library_kinematics_scenes__AttributeData* typedAttributeData = static_cast<library_kinematics_scenes__AttributeData*>(attributeData);

    typedAttributeData->~library_kinematics_scenes__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const kinematics_scene__AttributeData kinematics_scene__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__kinematics_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__kinematics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__kinematics_scene( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

kinematics_scene__AttributeData* attributeData = newData<kinematics_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_KINEMATICS_SCENE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__kinematics_scene()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__kinematics_scene();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__kinematics_scene( void* attributeData )
{
    kinematics_scene__AttributeData* typedAttributeData = static_cast<kinematics_scene__AttributeData*>(attributeData);

    typedAttributeData->~kinematics_scene__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const library_formulas__AttributeData library_formulas__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__library_formulas( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__library_formulas( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__library_formulas( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

library_formulas__AttributeData* attributeData = newData<library_formulas__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_LIBRARY_FORMULAS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__library_formulas()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__library_formulas();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__library_formulas( void* attributeData )
{
    library_formulas__AttributeData* typedAttributeData = static_cast<library_formulas__AttributeData*>(attributeData);

    typedAttributeData->~library_formulas__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__scene( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__scene()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__scene();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__scene( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
const instance_physics_scene__AttributeData instance_physics_scene__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_physics_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_physics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_physics_scene( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_physics_scene__AttributeData* attributeData = newData<instance_physics_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_PHYSICS_SCENE,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_physics_scene__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_PHYSICS_SCENE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_PHYSICS_SCENE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_physics_scene__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_physics_scene__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_PHYSICS_SCENE, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_physics_scene()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_physics_scene();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_physics_scene( void* attributeData )
{
    instance_physics_scene__AttributeData* typedAttributeData = static_cast<instance_physics_scene__AttributeData*>(attributeData);

    typedAttributeData->~instance_physics_scene__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_visual_scene__AttributeData instance_visual_scene__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_visual_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_visual_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_visual_scene( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_visual_scene__AttributeData* attributeData = newData<instance_visual_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_VISUAL_SCENE,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_visual_scene__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_VISUAL_SCENE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_VISUAL_SCENE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_visual_scene__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_visual_scene__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_VISUAL_SCENE, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_visual_scene()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_visual_scene();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_visual_scene( void* attributeData )
{
    instance_visual_scene__AttributeData* typedAttributeData = static_cast<instance_visual_scene__AttributeData*>(attributeData);

    typedAttributeData->~instance_visual_scene__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const instance_kinematics_scene__AttributeData instance_kinematics_scene__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__instance_kinematics_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__instance_kinematics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__instance_kinematics_scene( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

instance_kinematics_scene__AttributeData* attributeData = newData<instance_kinematics_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {
bool failed;
attributeData->url = GeneratedSaxParser::Utils::toURI(&attributeValue, failed);
if ( failed && handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
        ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,
        HASH_ELEMENT_INSTANCE_KINEMATICS_SCENE,
        HASH_ATTRIBUTE_URL,
        attributeValue))
{
    return false;
}
if ( !failed )
    attributeData->present_attributes |= instance_kinematics_scene__AttributeData::ATTRIBUTE_URL_PRESENT;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {
    ParserError::ErrorType simpleTypeValidationResult = validate__sid_type(attributeData->sid, strlen(attributeData->sid));
    if (simpleTypeValidationResult != ParserError::SIMPLE_TYPE_VALIDATION_OK)
    {
        if( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL,
            simpleTypeValidationResult,
            HASH_ELEMENT_INSTANCE_KINEMATICS_SCENE,
            HASH_ATTRIBUTE_SID,
            attributeValue) )
        {
            return false;
        }
    }
    } // validation
#endif

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_INSTANCE_KINEMATICS_SCENE, attribute, attributeValue))
            {return false;}
    }
    }
    }
}
if ((attributeData->present_attributes & instance_kinematics_scene__AttributeData::ATTRIBUTE_URL_PRESENT) == 0)
{
    attributeData->url = COLLADABU::URI("");
}
if ( (attributeData->present_attributes & instance_kinematics_scene__AttributeData::ATTRIBUTE_URL_PRESENT) == 0 )
{
    if ( handleError ( ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_REQUIRED_ATTRIBUTE_MISSING, HASH_ELEMENT_INSTANCE_KINEMATICS_SCENE, HASH_ATTRIBUTE_URL, 0 ) )
        return false;
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__instance_kinematics_scene()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__instance_kinematics_scene();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__instance_kinematics_scene( void* attributeData )
{
    instance_kinematics_scene__AttributeData* typedAttributeData = static_cast<instance_kinematics_scene__AttributeData*>(attributeData);

    typedAttributeData->~instance_kinematics_scene__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const bind_kinematics_model__AttributeData bind_kinematics_model__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bind_kinematics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bind_kinematics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bind_kinematics_model( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

bind_kinematics_model__AttributeData* attributeData = newData<bind_kinematics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NODE:
    {

attributeData->node = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_KINEMATICS_MODEL, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bind_kinematics_model()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bind_kinematics_model();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bind_kinematics_model( void* attributeData )
{
    bind_kinematics_model__AttributeData* typedAttributeData = static_cast<bind_kinematics_model__AttributeData*>(attributeData);

    typedAttributeData->~bind_kinematics_model__AttributeData();

    return true;
}

//---------------------------------------------------------------------
const bind_joint_axis__AttributeData bind_joint_axis__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__bind_joint_axis( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__bind_joint_axis( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__bind_joint_axis( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

bind_joint_axis__AttributeData* attributeData = newData<bind_joint_axis__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if ( attributeArray )
{
    while (true)
    {
        const ParserChar * attribute = *attributeArray;
        if ( !attribute )
            break;
        StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
        attributeArray++;
        if ( !attributeArray )
            return false;
        const ParserChar* attributeValue = *attributeArray;
        attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(ParserError::SEVERITY_ERROR_NONCRITICAL, ParserError::ERROR_UNKNOWN_ATTRIBUTE, HASH_ELEMENT_BIND_JOINT_AXIS, attribute, attributeValue))
            {return false;}
    }
    }
    }
}


    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__bind_joint_axis()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__bind_joint_axis();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__bind_joint_axis( void* attributeData )
{
    bind_joint_axis__AttributeData* typedAttributeData = static_cast<bind_joint_axis__AttributeData*>(attributeData);

    typedAttributeData->~bind_joint_axis__AttributeData();

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__axis____common_sidref_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__axis____common_sidref_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__axis____common_sidref_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__axis____common_sidref_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__axis____common_sidref_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__axis____common_sidref_or_param_type( void* attributeData )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_data__value____common_float_or_param_type( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preBegin__value____common_float_or_param_type( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateBegin__value____common_float_or_param_type( attributes, attributeDataPtr, validationDataPtr );
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_preEnd__value____common_float_or_param_type()
{
#ifdef GENERATEDSAXPARSER_VALIDATION
    if ( mValidate )
    {

        bool validationResult = _validateEnd__value____common_float_or_param_type();
        if ( !validationResult ) return false;

    } // validation
#endif

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen15Private::_freeAttributes__value____common_float_or_param_type( void* attributeData )
{
    return true;
}




} // namespace
